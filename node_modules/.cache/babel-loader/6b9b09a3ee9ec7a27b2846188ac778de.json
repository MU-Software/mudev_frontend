{"ast":null,"code":"// (c) MUsoftware 2022\n'use strict';\n\nimport _classPrivateFieldLooseBase from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { FrostError } from '../common/error';\nimport { APIResult } from './api_response';\nconst HTTP_METHOD = {\n  // We will support only these methods for now\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  PATCH: 'PATCH',\n  DELETE: 'DELETE'\n};\n\nfunction role2Object(roleStr) {\n  let result = {};\n  roleStr.split(\"&\").forEach(function (part) {\n    let item = part.split(\"=\");\n\n    if (item.length == 2) {\n      result[item[0]] = decodeURIComponent(item[1]);\n      if (result[item[0]] === 'true' || result[item[0]] === 'false') result[item[0]] = result[item[0]] === 'true' ? true : false;\n    }\n  });\n  return result;\n} // From https://stackoverflow.com/a/40031979\n\n\nfunction buf2hex(buffer) {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n} // Generate random safe string\n\n\nfunction generateRandomSecureToken(bytes) {\n  let randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}\n\nlet frostApiInstance;\n\nvar _API_USED_METHOD = /*#__PURE__*/_classPrivateFieldLooseKey(\"API_USED_METHOD\");\n\nvar _BASE_URL = /*#__PURE__*/_classPrivateFieldLooseKey(\"BASE_URL\");\n\nvar _DEFAULT_FETCH_OPTION = /*#__PURE__*/_classPrivateFieldLooseKey(\"DEFAULT_FETCH_OPTION\");\n\nvar _csrfToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"csrfToken\");\n\nvar _accessToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"accessToken\");\n\nvar _refreshResult = /*#__PURE__*/_classPrivateFieldLooseKey(\"refreshResult\");\n\nvar _apiRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"apiRequest\");\n\nclass FrostAPI {\n  // We only uses these http methods now.\n  // Refresh Token will be saved on cookie storage,\n  // And all of these attributes must be private.\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\n  // Although these HTTP Response status code means error,\n  // each routes have to handle these codes differently.\n  // Default fetch options,\n  // we'll copy and modify this default option object on every request.\n  // Account related properties\n  constructor() {\n    Object.defineProperty(this, _apiRequest, {\n      value: _apiRequest2\n    });\n    Object.defineProperty(this, _BASE_URL, {\n      writable: true,\n      value: 'https://hyperion.mudev.cc/api/dev/'\n    });\n    Object.defineProperty(this, _DEFAULT_FETCH_OPTION, {\n      writable: true,\n      value: {\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'same-origin',\n        redirect: 'follow',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }\n    });\n    Object.defineProperty(this, _csrfToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _accessToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _refreshResult, {\n      writable: true,\n      value: null\n    });\n    if (frostApiInstance) return frostApiInstance;\n    _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n    frostApiInstance = this;\n  }\n\n  isSignedIn(checkNetwork = false) {\n    if (checkNetwork) this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] ? true : false;\n  }\n\n  signUp(id, email, password, nickname) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signup', false, {\n      id: id,\n      pw: password,\n      nick: nickname,\n      email: email\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      } // We need to generate error message from the subcode.\n\n\n      let errorMsg = '';\n\n      switch (apiResult.subCode) {\n        case 'user.already_used':\n          let duplicatedItems = apiResult.data.duplicate[0];\n          let duplicatedItemsKor = '';\n\n          switch (duplicatedItems) {\n            case 'email':\n              duplicatedItemsKor = '이메일은';\n              break;\n\n            case 'id':\n              duplicatedItemsKor = '아이디는';\n              break;\n\n            case 'nick':\n            case 'nickname':\n              duplicatedItemsKor = '별명은';\n              break;\n\n            case 'pw':\n            case 'password':\n              // WTF??? HOW??????\n              duplicatedItemsKor = '비밀번호는';\n              break;\n\n            default:\n              duplicatedItemsKor = '정보는';\n              break;\n          }\n\n          errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\n          break;\n\n        case 'request.body.bad_semantics':\n          errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\n          let badSemanticsReason = apiResult.data.bad_semantics[0];\n          console.log(badSemanticsReason);\n\n          if (badSemanticsReason.hasOwnProperty('email')) {\n            errorMsg += '올바른 이메일 형식이 아니에요.';\n          } else if (badSemanticsReason.hasOwnProperty('pw')) {\n            let pwBadSemanticsReason = badSemanticsReason.pw;\n\n            switch (pwBadSemanticsReason) {\n              case 'TOO_SHORT':\n                errorMsg += '비밀번호가 너무 짧아요,\\n';\n                break;\n\n              case 'TOO_LONG':\n                errorMsg += '1024자는 비밀번호로 쓰기에 너무 길지 않을까요?\\n';\n                break;\n\n              case 'NEED_MORE_CHAR_TYPE':\n                errorMsg += '비밀번호가 너무 단순해요,\\n';\n                break;\n\n              case 'FORBIDDEN_CHAR':\n                errorMsg += '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n';\n                break;\n\n              default:\n                errorMsg += '사용할 수 있는 비밀번호가 아니에요,\\n';\n                break;\n            }\n\n            errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\n          } else if (badSemanticsReason.hasOwnProperty('id')) {\n            let idBadSemanticsReason = badSemanticsReason.id;\n\n            switch (idBadSemanticsReason) {\n              case 'TOO_SHORT':\n                errorMsg += '아이디가 너무 짧아요,\\n';\n                break;\n\n              case 'TOO_LONG':\n                errorMsg += '아이디가 너무 길어요,\\n';\n                break;\n\n              case 'FORBIDDEN_CHAR':\n                errorMsg += '아이디에 사용할 수 없는 문자가 들어있어요,\\n';\n                break;\n\n              default:\n                errorMsg += '사용할 수 있는 아이디가 아니에요,\\n';\n                break;\n            }\n\n            errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\n          } else {\n            errorMsg += '(정보가 올바르지 않습니다)';\n          }\n\n          break;\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signIn(idOrEmail, password) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signin', false, {\n      id: idOrEmail,\n      pw: password\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      } // We need to generate error message from the subcode.\n\n\n      let errorMsg = '';\n\n      switch (apiResult.subCode) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorMsg = '비밀번호가 맞지 않습니다,\\n비밀번호를 다시 입력해주세요.\\n';\n          errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\n          break;\n\n        case 'user.locked':\n          errorMsg = '계정이 잠겼습니다,\\n관리자에게 연락해주세요.\\n';\n          let accountLockReason = apiResult.data.reason;\n          errorMsg += `(잠긴 사유: ${accountLockReason})`;\n          break;\n\n        case 'user.deactivated':\n          errorMsg = '계정이 폐쇄되었습니다.,\\n관리자에게 연락해주세요.';\n          let accountDeactivateReason = apiResult.data.reason;\n          errorMsg += `(폐쇄된 사유: ${accountDeactivateReason})`;\n          break;\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signOut() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signout', false, {\n      signout: true\n    }).then(apiResult => {\n      // Actually, this action won't fail, except when the server is dead.\n      // Just reset the csrf token and access token.\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      return this;\n    });\n  }\n\n  refreshAuthentications() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/refresh', false).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n\n      throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  get userID() {\n    var _classPrivateFieldLoo;\n\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user.id;\n  }\n\n  get roles() {\n    if (!_classPrivateFieldLooseBase(this, _accessToken)[_accessToken]) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    let result = [];\n\n    try {\n      let token = JSON.parse(atob(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken].split('.')[1]));\n      JSON.parse(token.role).forEach(rolePart => {\n        if (rolePart === 'admin') return;\n        result.push(role2Object(rolePart));\n      });\n    } catch (e) {}\n\n    return result;\n  }\n\n  get(url, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.GET, url, accessTokenRequired);\n  }\n\n  post(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, url, accessTokenRequired, data);\n  }\n\n  put(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.PUT, url, accessTokenRequired, data);\n  }\n\n  patch(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.PATCH, url, accessTokenRequired, data);\n  }\n\n  delete(url, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.DELETE, url, accessTokenRequired);\n  }\n\n}\n\nfunction _apiRequest2(method = HTTP_METHOD.GET, url = '', accessTokenRequired = false, data = {}) {\n  // check if requested method is allowed\n  if (_classPrivateFieldLooseBase(FrostAPI, _API_USED_METHOD)[_API_USED_METHOD].indexOf(method) == -1) {\n    throw 'NOT_ALLOWED_METHOD';\n  } // deep copy fetch option object\n\n\n  let reqFetchOption = JSON.parse(JSON.stringify(_classPrivateFieldLooseBase(this, _DEFAULT_FETCH_OPTION)[_DEFAULT_FETCH_OPTION]));\n  reqFetchOption.method = method; // only add body on POST/PATCH/PUT methods\n\n  if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1) reqFetchOption.body = JSON.stringify(data); // always send X-Csrf-Token. This won't be a security hole.\n\n  reqFetchOption.headers['X-Csrf-Token'] = _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken]; // add access token on header if accessTokenRequired is true\n\n  if (accessTokenRequired) {\n    reqFetchOption.headers['Authorization'] = 'Bearer ' + _classPrivateFieldLooseBase(this, _accessToken)[_accessToken];\n  }\n\n  if (url.includes('account') || url.includes('admin')) {\n    reqFetchOption.credentials = 'include';\n  }\n\n  return fetch(_classPrivateFieldLooseBase(this, _BASE_URL)[_BASE_URL] + url, reqFetchOption).then(response => {\n    if (!response) {\n      // How is this possible???\n      throw new FrostError('서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.', 'fetchResult 객체가 undefined 또는 null입니다.', -1);\n    } else if (200 <= response.status && response.status <= 399) {\n      // this returns response.json()\n      // SUCCESS\n      return response.json();\n    } else if (400 <= response.status && response.status <= 499) {\n      if (response.status === 401) {\n        // this \"possibly\" returns response.json()\n        // token not given / token expired / token invalid\n        // wrong password / account locked / account deactivated\n        // We need to try refreshing access token and retry this.\n        // If access token refresh fails, then raise errors.\n        if (url.startsWith('account/')) return this.refreshAuthentications().then(_ => {\n          return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](method, url, accessTokenRequired, data);\n        });else throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\n        // this \"possibly\" returns response.json().\n        // See RETURNABLE_ERROR for more details.\n        return response.json();\n      } else if (response.status === 403) {\n        // Requested action was forbidden\n        throw new FrostError('해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 405) {\n        // Method not permitted\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 415) {\n        // requested response content-type not supported\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else {\n        // unknown client-fault error\n        throw new FrostError('알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      }\n    } else {\n      // HTTP status code is more than 500(server error)\n      throw new FrostError('서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `statusCode가 ${response.status}입니다.`, response.status);\n    } // This is just for type-checking, response.status won't be less than 200, right?\n    // ...right? please... no......\n\n\n    return response.json();\n  }).then(response => new APIResult(response)).catch(reason => {\n    // catch all exceptions and change it to FrostError\n    if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n      throw reason;\n    } else {\n      throw new FrostError('알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\n    }\n  });\n}\n\nObject.defineProperty(FrostAPI, _API_USED_METHOD, {\n  writable: true,\n  value: [HTTP_METHOD.GET, HTTP_METHOD.POST, HTTP_METHOD.PUT, HTTP_METHOD.PATCH, HTTP_METHOD.DELETE]\n});\nFrostAPI.RETURNABLE_ERROR = [// Actually, on 404, we need to filter http.not_found out,\n// and any other responses must be returned... but we can get subcode after response.json(),\n// And response.json() returns Promise<Any>, so we cannot get subCode directly... shit...\n404, // http || resource not found\n409, // already used / information mismatch, conflict\n410, // resource gone\n412, // resource prediction failed\n422 // request.body.bad_semantics - email address validation failure, etc.\n];\nexport default FrostAPI;","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/network/api.ts"],"names":["FrostError","APIResult","HTTP_METHOD","GET","POST","PUT","PATCH","DELETE","role2Object","roleStr","result","split","forEach","part","item","length","decodeURIComponent","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","frostApiInstance","FrostAPI","constructor","mode","cache","credentials","redirect","referrerPolicy","headers","isSignedIn","checkNetwork","refreshAuthentications","signUp","id","email","password","nickname","pw","nick","then","apiResult","success","data","user","access_token","token","errorMsg","subCode","duplicatedItems","duplicate","duplicatedItemsKor","badSemanticsReason","bad_semantics","console","log","hasOwnProperty","pwBadSemanticsReason","idBadSemanticsReason","code","catch","reason","signIn","idOrEmail","left_chance","accountLockReason","accountDeactivateReason","signOut","signout","userID","roles","JSON","parse","atob","role","rolePart","push","e","get","url","accessTokenRequired","post","put","patch","delete","method","indexOf","reqFetchOption","stringify","body","includes","fetch","response","status","json","startsWith","_","RETURNABLE_ERROR","name"],"mappings":"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","sourcesContent":["// (c) MUsoftware 2022\r\n'use strict';\r\n\r\nimport { FrostError } from '../common/error';\r\nimport { APIResult } from './api_response';\r\n\r\nconst HTTP_METHOD = {\r\n  // We will support only these methods for now\r\n  GET: 'GET',\r\n  POST: 'POST',\r\n  PUT: 'PUT',\r\n  PATCH: 'PATCH',\r\n  DELETE: 'DELETE',\r\n};\r\n\r\nfunction role2Object(roleStr: string) {\r\n  let result: { [roleName: string]: string | boolean } = {};\r\n\r\n  roleStr.split(\"&\").forEach(function (part) {\r\n    let item = part.split(\"=\");\r\n    if (item.length == 2) {\r\n      result[item[0]] = decodeURIComponent(item[1]);\r\n      if (result[item[0]] === 'true' || result[item[0]] === 'false')\r\n        result[item[0]] = (result[item[0]] === 'true') ? true : false;\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\nfunction buf2hex(buffer: ArrayBufferLike) {\r\n  return [...new Uint8Array(buffer)]\r\n    .map(x => x.toString(16).padStart(2, '0'))\r\n    .join('');\r\n}\r\n\r\n// Generate random safe string\r\nfunction generateRandomSecureToken(bytes: number) {\r\n  let randArray = new Uint32Array(bytes);\r\n  window.crypto.getRandomValues(randArray);\r\n  return buf2hex(randArray);\r\n}\r\n\r\nlet frostApiInstance: FrostAPI;\r\nclass FrostAPI {\r\n  // We only uses these http methods now.\r\n  static readonly #API_USED_METHOD = [\r\n    HTTP_METHOD.GET,\r\n    HTTP_METHOD.POST,\r\n    HTTP_METHOD.PUT,\r\n    HTTP_METHOD.PATCH,\r\n    HTTP_METHOD.DELETE,\r\n  ]\r\n  // Refresh Token will be saved on cookie storage,\r\n  // And all of these attributes must be private.\r\n  readonly #BASE_URL = 'https://hyperion.mudev.cc/api/dev/';\r\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\r\n  // Although these HTTP Response status code means error,\r\n  // each routes have to handle these codes differently.\r\n  static readonly RETURNABLE_ERROR = [\r\n    // Actually, on 404, we need to filter http.not_found out,\r\n    // and any other responses must be returned... but we can get subcode after response.json(),\r\n    // And response.json() returns Promise<Any>, so we cannot get subCode directly... shit...\r\n    404, // http || resource not found\r\n    409, // already used / information mismatch, conflict\r\n    410, // resource gone\r\n    412, // resource prediction failed\r\n    422, // request.body.bad_semantics - email address validation failure, etc.\r\n  ];\r\n  // Default fetch options,\r\n  // we'll copy and modify this default option object on every request.\r\n  readonly #DEFAULT_FETCH_OPTION = {\r\n    mode: 'cors',\r\n    cache: 'no-cache',\r\n    credentials: 'same-origin',\r\n    redirect: 'follow',\r\n    referrerPolicy: 'strict-origin-when-cross-origin',\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n\r\n  // Account related properties\r\n  #csrfToken: string = '';\r\n  #accessToken: string = '';\r\n  #refreshResult?: APIResult['data'] | null = null;\r\n\r\n  constructor() {\r\n    if (frostApiInstance) return frostApiInstance;\r\n\r\n    this.#csrfToken = generateRandomSecureToken(32);\r\n    frostApiInstance = this;\r\n  }\r\n\r\n  #apiRequest(method = HTTP_METHOD.GET, url = '', accessTokenRequired = false, data = {}): Promise<APIResult> {\r\n    // check if requested method is allowed\r\n    if (FrostAPI.#API_USED_METHOD.indexOf(method) == -1) { throw 'NOT_ALLOWED_METHOD'; }\r\n\r\n    // deep copy fetch option object\r\n    let reqFetchOption = JSON.parse(JSON.stringify(this.#DEFAULT_FETCH_OPTION));\r\n    reqFetchOption.method = method;\r\n\r\n    // only add body on POST/PATCH/PUT methods\r\n    if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1)\r\n      reqFetchOption.body = JSON.stringify(data);\r\n\r\n    // always send X-Csrf-Token. This won't be a security hole.\r\n    reqFetchOption.headers['X-Csrf-Token'] = this.#csrfToken;\r\n    // add access token on header if accessTokenRequired is true\r\n    if (accessTokenRequired) {\r\n      reqFetchOption.headers['Authorization'] = 'Bearer ' + this.#accessToken;\r\n    }\r\n\r\n    if (url.includes('account') || url.includes('admin')) {\r\n      reqFetchOption.credentials = 'include';\r\n    }\r\n\r\n    return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n      if (!response) {\r\n        // How is this possible???\r\n        throw new FrostError(\r\n          '서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.',\r\n          'fetchResult 객체가 undefined 또는 null입니다.', -1);\r\n      } else if (200 <= response.status && response.status <= 399) {  // this returns response.json()\r\n        // SUCCESS\r\n        return response.json();\r\n      } else if (400 <= response.status && response.status <= 499) {\r\n        if (response.status === 401) {  // this \"possibly\" returns response.json()\r\n          // token not given / token expired / token invalid\r\n          // wrong password / account locked / account deactivated\r\n          // We need to try refreshing access token and retry this.\r\n          // If access token refresh fails, then raise errors.\r\n          if (url.startsWith('account/'))\r\n            return this.refreshAuthentications().then((_) => {\r\n              return this.#apiRequest(method, url, accessTokenRequired, data);\r\n            });\r\n          else\r\n            throw new FrostError(\r\n              '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n              '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n              response.status);\r\n        } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\r\n          // this \"possibly\" returns response.json().\r\n          // See RETURNABLE_ERROR for more details.\r\n          return response.json();\r\n        } else if (response.status === 403) {\r\n          // Requested action was forbidden\r\n          throw new FrostError(\r\n            '해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 405) {\r\n          // Method not permitted\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 415) {\r\n          // requested response content-type not supported\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else {\r\n          // unknown client-fault error\r\n          throw new FrostError(\r\n            '알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        }\r\n      } else {  // HTTP status code is more than 500(server error)\r\n        throw new FrostError(\r\n          '서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `statusCode가 ${response.status}입니다.`, response.status);\r\n      }\r\n\r\n      // This is just for type-checking, response.status won't be less than 200, right?\r\n      // ...right? please... no......\r\n      return response.json();\r\n    }).then((response) => new APIResult(response)).catch((reason) => {\r\n      // catch all exceptions and change it to FrostError\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  isSignedIn(checkNetwork: boolean = false) {\r\n    if (checkNetwork)\r\n      this.refreshAuthentications();\r\n\r\n    return (this.#accessToken) ? true : false;\r\n  }\r\n\r\n  signUp(id: string, email: string, password: string, nickname: string) {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signup', false,\r\n      { id: id, pw: password, nick: nickname, email: email }).then((apiResult) => {\r\n        if (apiResult.success) {\r\n          this.#accessToken = apiResult.data.user.access_token.token;\r\n          this.#refreshResult = apiResult.data;\r\n          return this;\r\n        }\r\n\r\n        // We need to generate error message from the subcode.\r\n        let errorMsg: string = '';\r\n        switch (apiResult.subCode) {\r\n          case 'user.already_used':\r\n            let duplicatedItems: string = apiResult.data.duplicate[0];\r\n            let duplicatedItemsKor: string = '';\r\n            switch (duplicatedItems) {\r\n              case 'email':\r\n                duplicatedItemsKor = '이메일은'; break;\r\n              case 'id':\r\n                duplicatedItemsKor = '아이디는'; break;\r\n              case 'nick':\r\n              case 'nickname':\r\n                duplicatedItemsKor = '별명은'; break;\r\n              case 'pw':\r\n              case 'password':\r\n                // WTF??? HOW??????\r\n                duplicatedItemsKor = '비밀번호는'; break;\r\n              default:\r\n                duplicatedItemsKor = '정보는'; break;\r\n            }\r\n            errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\r\n            break;\r\n          case 'request.body.bad_semantics':\r\n            errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\r\n            let badSemanticsReason: any = apiResult.data.bad_semantics[0];\r\n            console.log(badSemanticsReason);\r\n            if (badSemanticsReason.hasOwnProperty('email')) {\r\n              errorMsg += '올바른 이메일 형식이 아니에요.';\r\n            } else if (badSemanticsReason.hasOwnProperty('pw')) {\r\n              let pwBadSemanticsReason: string = badSemanticsReason.pw;\r\n              switch (pwBadSemanticsReason) {\r\n                case 'TOO_SHORT':\r\n                  errorMsg += '비밀번호가 너무 짧아요,\\n'; break;\r\n                case 'TOO_LONG':\r\n                  errorMsg += '1024자는 비밀번호로 쓰기에 너무 길지 않을까요?\\n'; break;\r\n                case 'NEED_MORE_CHAR_TYPE':\r\n                  errorMsg += '비밀번호가 너무 단순해요,\\n'; break;\r\n                case 'FORBIDDEN_CHAR':\r\n                  errorMsg += '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n'; break;\r\n                default:\r\n                  errorMsg += '사용할 수 있는 비밀번호가 아니에요,\\n'; break;\r\n              }\r\n              errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\r\n            } else if (badSemanticsReason.hasOwnProperty('id')) {\r\n              let idBadSemanticsReason: string = badSemanticsReason.id;\r\n              switch (idBadSemanticsReason) {\r\n                case 'TOO_SHORT':\r\n                  errorMsg += '아이디가 너무 짧아요,\\n'; break;\r\n                case 'TOO_LONG':\r\n                  errorMsg += '아이디가 너무 길어요,\\n'; break;\r\n                case 'FORBIDDEN_CHAR':\r\n                  errorMsg += '아이디에 사용할 수 없는 문자가 들어있어요,\\n'; break;\r\n                default:\r\n                  errorMsg += '사용할 수 있는 아이디가 아니에요,\\n'; break;\r\n              }\r\n              errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\r\n            } else {\r\n              errorMsg += '(정보가 올바르지 않습니다)';\r\n            }\r\n            break;\r\n          default:\r\n            errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n        }\r\n\r\n        throw new FrostError(\r\n          errorMsg,\r\n          `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n          apiResult.code);\r\n      }).catch((reason) => {\r\n        // as reason might be a 'FrostError',\r\n        // we can just reset auth data and throw it directly.\r\n        this.#accessToken = '';\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#refreshResult = null;\r\n        throw reason;\r\n      });\r\n  }\r\n\r\n  signIn(idOrEmail: string, password: string) {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signin', false,\r\n      { id: idOrEmail, pw: password }).then((apiResult) => {\r\n        if (apiResult.success) {\r\n          this.#accessToken = apiResult.data.user.access_token.token;\r\n          this.#refreshResult = apiResult.data;\r\n          return this;\r\n        }\r\n\r\n        // We need to generate error message from the subcode.\r\n        let errorMsg: string = '';\r\n        switch (apiResult.subCode) {\r\n          case 'user.not_found':\r\n            errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n            break;\r\n          case 'user.wrong_password':\r\n            errorMsg = '비밀번호가 맞지 않습니다,\\n비밀번호를 다시 입력해주세요.\\n';\r\n            errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\r\n            break;\r\n          case 'user.locked':\r\n            errorMsg = '계정이 잠겼습니다,\\n관리자에게 연락해주세요.\\n';\r\n            let accountLockReason: string = apiResult.data.reason;\r\n            errorMsg += `(잠긴 사유: ${accountLockReason})`;\r\n            break;\r\n          case 'user.deactivated':\r\n            errorMsg = '계정이 폐쇄되었습니다.,\\n관리자에게 연락해주세요.';\r\n            let accountDeactivateReason: string = apiResult.data.reason;\r\n            errorMsg += `(폐쇄된 사유: ${accountDeactivateReason})`;\r\n            break;\r\n          default:\r\n            errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n        }\r\n\r\n        throw new FrostError(\r\n          errorMsg,\r\n          `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n          apiResult.code);\r\n      }).catch((reason) => {\r\n        // as reason might be a 'FrostError',\r\n        // we can just reset auth data and throw it directly.\r\n        this.#accessToken = '';\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#refreshResult = null;\r\n        throw reason;\r\n      });\r\n  }\r\n\r\n  signOut() {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signout', false, { signout: true }).then(\r\n      (apiResult) => {\r\n        // Actually, this action won't fail, except when the server is dead.\r\n        // Just reset the csrf token and access token.\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#accessToken = '';\r\n        this.#refreshResult = null;\r\n        return this;\r\n      });\r\n  }\r\n\r\n  refreshAuthentications() {\r\n    return this.#apiRequest(\r\n      HTTP_METHOD.POST,\r\n      'account/refresh',\r\n      false\r\n    ).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n      throw new FrostError(\r\n        '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n        `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#accessToken = '';\r\n      this.#csrfToken = generateRandomSecureToken(32);\r\n      this.#refreshResult = null;\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  get userID() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user.id;\r\n  }\r\n\r\n  get roles() {\r\n    if (!this.#accessToken)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    let result: Array<{ [roleName: string]: string | boolean; }> = [];\r\n    try {\r\n      let token = JSON.parse(atob(this.#accessToken.split('.')[1]));\r\n      JSON.parse(token.role).forEach((rolePart: string) => {\r\n        if (rolePart === 'admin') return;\r\n        result.push(role2Object(rolePart));\r\n      });\r\n    } catch (e) { }\r\n\r\n    return result;\r\n  }\r\n\r\n  get(url: string, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.GET, url, accessTokenRequired); }\r\n  post(url: string, data: object = {}, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.POST, url, accessTokenRequired, data); }\r\n  put(url: string, data: object = {}, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.PUT, url, accessTokenRequired, data); }\r\n  patch(url: string, data: object = {}, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.PATCH, url, accessTokenRequired, data); }\r\n  delete(url: string, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.DELETE, url, accessTokenRequired); }\r\n}\r\n\r\nexport default FrostAPI;\r\n"]},"metadata":{},"sourceType":"module"}