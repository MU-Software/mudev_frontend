{"ast":null,"code":"import { Manager } from 'socket.io-client';\nimport { FrostError } from 'src/common/error';\nimport FrostAPI from 'src/network/api';\nconst SIO_RESP_UNMOUNT_TIMEOUT = 15;\nconst SIO_DESCRIPTION = '재생목록의 실시간 정보를 받아오기 위한 연결';\nconst COMMON_ERR_MSG_ADD_MAP = {\n  retryAfter5Min: '\\n5분 후에 다시 시도해주세요.',\n  retryAfter10Min: '\\n10분 후에 다시 시도해주세요.',\n  retryFullReload: '\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\n  retryAfterSignIn: '\\n로그인 후 이용해주세요.'\n};\nconst COMMON_ERR_MSG_MAP = {\n  safeDisconnected: SIO_DESCRIPTION + '이 종료됐어요.',\n  unknownErrorRetry5Min: SIO_DESCRIPTION + '에서\\n알 수 없는 문제가 생겼어요,' + COMMON_ERR_MSG_ADD_MAP.retryAfter5Min,\n  unknownErrorRetryFullReload: SIO_DESCRIPTION + '에서\\n알 수 없는 문제가 생겼어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\n  signInRequired: '이 기능은 로그인 후 사용할 수 있어요,' + COMMON_ERR_MSG_ADD_MAP.retryAfterSignIn,\n  signInfoCheckFailed: '로그인 정보를 확인하는 중 문제가 발생했어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\n  connectFailed: SIO_DESCRIPTION + '을 만들지 못했어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\n  unknownDisconnected: SIO_DESCRIPTION + '이\\n알 수 없는 이유로 종료됐어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\n  authFailed: SIO_DESCRIPTION + '을 인증하지 못했어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\n  authResponseFailed: SIO_DESCRIPTION + '의 인증 정보를 받지 못했어요.' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\n  unknownAuthFailed: SIO_DESCRIPTION + '을 인증하는 중\\n알 수 없는 문제가 생겼어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload\n};\n\n// Generate random safe string, borrowed from FrostAPI implementation\nconst generateRandomSecureToken = bytes => {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}; // From https://stackoverflow.com/a/40031979\n// Buffer to hex, also borrowed from FrostAPI implementation\n\n\nconst buf2hex = buffer => {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}; // From https://stackoverflow.com/a/39977764/5702135\n\n\nconst assign = (target, ...sources) => Object.assign(target, ...sources.map(x => Object.entries(x).filter(([key, value]) => value !== undefined).reduce((obj, [key, value]) => (obj[key] = value, obj), {})));\n\nlet playCoSocketIOHandlerInstance;\nexport class PlayCoSocketIOHandler {\n  // UTIL METHOD\n  get connected() {\n    return this.socketIo.connected;\n  } // UTIL METHOD\n\n\n  getAuthBody(additionalBody) {\n    return assign({\n      sid: this.sessionId,\n      sio_token: this.sioToken,\n      sio_csrf_token: this.csrfToken\n    }, additionalBody !== null && additionalBody !== void 0 ? additionalBody : {});\n  } // UTIL METHOD\n\n\n  setSIOStatMsg(newMsg) {\n    this.socketIoStatusMessage = newMsg;\n\n    try {\n      if (this.onSocketIOStatusChanged) this.onSocketIOStatusChanged(newMsg);\n    } catch (e) {\n      console.log(e);\n    }\n  } // UTIL METHOD\n\n\n  defaultErrorHandler(reason, shouldDisconnect = true, alternativeShowMsg) {\n    const self = this !== null && this !== void 0 ? this : playCoSocketIOHandlerInstance;\n\n    if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n      console.log(reason.message);\n      console.log(reason.debugMessage);\n      console.log(reason.apiResponse);\n    } else {\n      console.log(reason);\n    } // Set error message\n\n\n    try {\n      self.setSIOStatMsg(alternativeShowMsg !== null && alternativeShowMsg !== void 0 ? alternativeShowMsg : reason.message);\n    } catch (e1) {\n      console.log(alternativeShowMsg !== null && alternativeShowMsg !== void 0 ? alternativeShowMsg : reason.message);\n      console.log(e1);\n    } // Disconnect from SocketIO.\n\n\n    if (shouldDisconnect) self.disconnect(false);\n    return false;\n  } // UTIL METHOD\n\n\n  unsubscribeAllHooks() {\n    this.onPlayCoConnected = undefined;\n    this.onPlaylistModified = undefined;\n    this.onUserStatusChanged = undefined;\n    this.onSocketIOStatusChanged = undefined;\n  } // EVENT HANDLER\n\n\n  constructor() {\n    this.socketIoMgr = void 0;\n    this.socketIo = void 0;\n    this.sioToken = void 0;\n    this.sioTokenExpiresAt = void 0;\n    this.csrfToken = void 0;\n    this.sessionId = void 0;\n    this.prevRoomStatus = void 0;\n    this.socketIoStatusMessage = void 0;\n    this.onPlayCoConnected = void 0;\n    this.onPlaylistModified = void 0;\n    this.onUserStatusChanged = void 0;\n    this.onSocketIOStatusChanged = void 0;\n    this.socketIoEventHandler = {\n      connect: () => {\n        this.sessionId = this.socketIo.id; // Get SIO Token and register session\n\n        this.refreshSIOToken(undefined, true, true);\n      },\n      reconnect: () => {\n        // Same as connect\n        this.sessionId = this.socketIo.id; // Get SIO Token and register session\n\n        this.refreshSIOToken(undefined, true, true);\n      },\n      disconnect: reason => {\n        console.log(`DISCONNECTED FROM PLAYCO SIO, REASON: ${reason}`); // Before disconnect and unconnect all hooks, we need to cleanup the UI if it's possible.\n\n        try {\n          var _this$prevRoomStatus$, _this$prevRoomStatus, _this$prevRoomStatus$2, _this$prevRoomStatus2;\n\n          if (this.onUserStatusChanged) this.onUserStatusChanged({\n            playlist_id: (_this$prevRoomStatus$ = (_this$prevRoomStatus = this.prevRoomStatus) === null || _this$prevRoomStatus === void 0 ? void 0 : _this$prevRoomStatus.playlist_id) !== null && _this$prevRoomStatus$ !== void 0 ? _this$prevRoomStatus$ : -1,\n            playlist_hash: (_this$prevRoomStatus$2 = (_this$prevRoomStatus2 = this.prevRoomStatus) === null || _this$prevRoomStatus2 === void 0 ? void 0 : _this$prevRoomStatus2.playlist_hash) !== null && _this$prevRoomStatus$2 !== void 0 ? _this$prevRoomStatus$2 : '',\n            participants: {},\n            db_modified: true\n          });\n        } catch (e) {\n          console.log(e);\n        }\n\n        this.unsubscribeAllHooks();\n        this.sessionId = '';\n        this.sioToken = '';\n        this.sioTokenExpiresAt = new Date();\n        this.csrfToken = generateRandomSecureToken(32);\n      },\n      REQUEST_RESPONSE_0: data => {\n        console.log('Unknown response received! Received data >>> ---------------');\n        console.log(data);\n        console.log('------------------------------------------------------------');\n      },\n      PLAYLIST_USER_ENTERED: data => {\n        // When some user entered to this room\n        const roomStatus = data.data.room;\n        this.prevRoomStatus = roomStatus;\n\n        try {\n          if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus);\n        } catch (e) {\n          console.log(e);\n        }\n      },\n      PLAYLIST_USER_EXITED: data => {\n        // When some user exited from this room\n        const roomStatus = data.data.room;\n\n        try {\n          if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus);\n        } catch (e) {\n          console.log(e);\n        }\n      },\n      PLAYLIST_MODIFIED: data => {\n        var _data$data$room$db_mo;\n\n        const roomStatus = data.data.room;\n        const shouldRoomRefreshed = (_data$data$room$db_mo = data.data.room.db_modified) !== null && _data$data$room$db_mo !== void 0 ? _data$data$room$db_mo : false;\n        this.prevRoomStatus = roomStatus;\n\n        try {\n          if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus);\n        } catch (e) {\n          console.log(e);\n        }\n\n        try {\n          if (shouldRoomRefreshed && this.onPlaylistModified) this.onPlaylistModified();\n        } catch (e) {\n          console.log(e);\n        }\n      },\n      OFFICIAL_ANNOUNCEMENT: data => {\n        // RESERVED\n        console.log('OFFICIAL_ANNOUNCEMENT event received! Received data >>> ----');\n        console.log(data);\n        console.log('------------------------------------------------------------');\n      }\n    };\n    if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\n    this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\n      reconnectionDelayMax: 5000,\n      path: '/api/dev/ws',\n      transports: ['websocket'],\n      upgrade: false,\n      forceNew: false,\n      autoConnect: false,\n      closeOnBeforeunload: false\n    });\n    this.socketIo = this.socketIoMgr.socket('/playco_ws');\n\n    for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\n      this.socketIo.on(key, value);\n    }\n\n    playCoSocketIOHandlerInstance = this;\n  } // EVENT MAKER\n\n\n  emitEvent(event, data, onSuccess, onFailure, isRetry) {\n    const requestId = generateRandomSecureToken(16);\n\n    if (data) {\n      data.request_id = requestId;\n    } else {\n      data = {\n        request_id: requestId\n      };\n    }\n\n    const eventName = `REQUEST_RESPONSE_${requestId}`; // Unregister request response handler after {SIO_RESP_UNMOUNT_TIMEOUT}sec.\n\n    const eventHandlerTimeoutID = setTimeout(() => {\n      console.log(`WARNING: ${eventName} didn't handled in ${SIO_RESP_UNMOUNT_TIMEOUT}sec, and handler is unmounted.`);\n      this.socketIo.removeAllListeners(eventName);\n    }, SIO_RESP_UNMOUNT_TIMEOUT * 1000);\n\n    const eventHandler = response => {\n      clearTimeout(eventHandlerTimeoutID); // This will clear eventHandlerTimeout.\n\n      try {\n        if (response === null || response === void 0 ? void 0 : response.success) {\n          if (onSuccess) onSuccess(response);\n        } else {\n          // Response contains (success == false)\n          let dbgMsg = 'sio:emitEvent error\\n';\n          dbgMsg += `(event=${event})=>\\n`;\n\n          if (response) {\n            for (const [key, value] of Object.entries(response !== null && response !== void 0 ? response : {})) {\n              if (key !== 'data') {\n                dbgMsg += `response?.${key} = ${value}\\n`;\n              } else {\n                dbgMsg += `response?.${key} = ${JSON.stringify(value)}\\n`;\n              }\n            }\n          } else {\n            dbgMsg += `response = ${response}\\n`;\n          }\n\n          if (event === 'playco_connect') {\n            var _response$message;\n\n            this.defaultErrorHandler(new FrostError((_response$message = response === null || response === void 0 ? void 0 : response.message) !== null && _response$message !== void 0 ? _response$message : COMMON_ERR_MSG_MAP.unknownAuthFailed, dbgMsg, response === null || response === void 0 ? void 0 : response.code, false), true, COMMON_ERR_MSG_MAP.unknownAuthFailed);\n            return;\n          } else if (isRetry) {\n            var _response$message2;\n\n            this.defaultErrorHandler(new FrostError((_response$message2 = response === null || response === void 0 ? void 0 : response.message) !== null && _response$message2 !== void 0 ? _response$message2 : COMMON_ERR_MSG_MAP.unknownAuthFailed, dbgMsg, response === null || response === void 0 ? void 0 : response.code, false), true, COMMON_ERR_MSG_MAP.unknownAuthFailed);\n            return;\n          } else if (response === null || response === void 0 ? void 0 : response.subCode.startsWith('SIO_TOKEN_')) {\n            // Refresh SIO Token and retry emitEvent.\n            this.refreshSIOToken(() => this.emitEvent(event, data, onSuccess, onFailure, true), false, true);\n            return;\n          } else {\n            this.defaultErrorHandler(new FrostError((response === null || response === void 0 ? void 0 : response.message) || COMMON_ERR_MSG_MAP.unknownErrorRetry5Min, dbgMsg, response === null || response === void 0 ? void 0 : response.code, false), false, COMMON_ERR_MSG_MAP.unknownErrorRetry5Min);\n            return;\n          }\n        }\n      } catch (e) {\n        if (onFailure) {\n          try {\n            onFailure(e, response);\n          } catch (e1) {\n            console.log(e);\n            console.log(e1);\n            this.defaultErrorHandler(e, false, COMMON_ERR_MSG_MAP.unknownErrorRetry5Min);\n          }\n        }\n      }\n    };\n\n    this.socketIo.once(eventName, eventHandler);\n    this.socketIo.emit(event, data);\n  } // EVENT MAKER\n\n\n  refreshSIOToken(callback = () => {\n    /* */\n  }, isOnConnect = false, forceRefresh = false) {\n    if (!forceRefresh && this.sioToken && this.sioTokenExpiresAt > new Date()) {\n      // We assumes that token is alive.\n      // If the callback is emitEvent and server returns SIO_TOKEN_EXPIRED or SIO_TOKEN_INVALID,\n      // then emitEvent method will handle it properly.\n      try {\n        callback();\n        return;\n      } catch (err) {\n        this.defaultErrorHandler(err);\n      }\n    }\n\n    const frostAPI = new FrostAPI();\n    frostAPI.isSignedIn(true).then(isSignedIn => {\n      if (!isSignedIn) {\n        // Check if Frost is signed in.\n        throw new FrostError(COMMON_ERR_MSG_MAP.signInRequired, 'on refreshSIOToken, isSignedIn == false', -1, false);\n      } else if (!this.socketIo.connected || !this.sessionId) {\n        // Check if Socket.IO is connected, and every statement is fulfilled.\n        throw new FrostError(COMMON_ERR_MSG_MAP.connectFailed, `this.socketIo.connected = ${this.socketIo.connected}, !this.sessionId = ${this.sessionId}`, -1, false);\n      } // We need to get a new SIO Token by request.\n\n\n      this.csrfToken = generateRandomSecureToken(32);\n      return frostAPI.post('playco/socketio/auth', this.getAuthBody(), true).then(result => {\n        if (!result.success) {\n          throw new FrostError(COMMON_ERR_MSG_MAP.authResponseFailed, '/playco/socketio/auth returns response.success == false', result.code, false, result);\n        } // Get SIO token from response\n\n\n        const sioTokenData = result.data.sio_token;\n        this.sioToken = sioTokenData.token;\n        this.sioTokenExpiresAt = new Date(sioTokenData.exp); // Register session if this function is called on SocketIO onConnect event.\n\n        if (isOnConnect) {\n          this.emitEvent('playco_connect', this.getAuthBody(), response => this.onPlayCoConnected ? this.onPlayCoConnected() : () => {\n            /* */\n          }, // Session creation failed\n          (reason, response) => this.defaultErrorHandler(reason, true, COMMON_ERR_MSG_MAP.authFailed));\n          return;\n        } else {\n          callback();\n          return;\n        }\n      }, reason => {\n        // Failed to get SIO token\n        reason.message = COMMON_ERR_MSG_MAP.authFailed;\n        throw reason;\n      });\n    }, reason => {\n      reason.message = COMMON_ERR_MSG_MAP.signInfoCheckFailed;\n      throw reason;\n    }).catch(this.defaultErrorHandler);\n  } // EVENT MAKER\n\n\n  connect() {\n    if (!this.socketIo.connected) // Connect SocketIO if it's not connected.\n      // This will fire this.socketIoEventHandler.connect if the connection is successfully established.\n      this.socketIo.connect();\n  } // EVENT MAKER\n\n\n  disconnect(isSafeDisconnect = true) {\n    if (this.socketIo.connected) {\n      this.socketIo.disconnect();\n      if (isSafeDisconnect) this.setSIOStatMsg(COMMON_ERR_MSG_MAP.safeDisconnected);\n    }\n  } // EVENT MAKER\n\n\n  enterPlaylist(playlistId, currentlyPlaying) {\n    this.refreshSIOToken(() => this.emitEvent('playlist_enter', this.getAuthBody({\n      playlist_id: playlistId,\n      currently_playing: currentlyPlaying\n    }), response => {\n      /* */\n    }, (reason, response) => {\n      /* */\n    }));\n  } // EVENT MAKER\n\n\n  leavePlaylist(playlistId) {\n    this.refreshSIOToken(() => this.emitEvent('playlist_leave', this.getAuthBody({\n      playlist_id: playlistId\n    }), response => {\n      /* */\n    }, (reason, response) => {\n      /* */\n    }));\n  } // EVENT MAKER\n\n\n  setSessionCurrentPlaying(playlistId, currentPlaying) {\n    this.refreshSIOToken(() => this.emitEvent('playlist_set_status', this.getAuthBody({\n      playlist_id: playlistId,\n      currently_playing: currentPlaying\n    }), response => {\n      /* */\n    }, (reason, response) => {\n      /* */\n    }));\n  }\n\n}","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/ui/page/playco/playco/sio.ts"],"names":["Manager","FrostError","FrostAPI","SIO_RESP_UNMOUNT_TIMEOUT","SIO_DESCRIPTION","COMMON_ERR_MSG_ADD_MAP","retryAfter5Min","retryAfter10Min","retryFullReload","retryAfterSignIn","COMMON_ERR_MSG_MAP","safeDisconnected","unknownErrorRetry5Min","unknownErrorRetryFullReload","signInRequired","signInfoCheckFailed","connectFailed","unknownDisconnected","authFailed","authResponseFailed","unknownAuthFailed","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","assign","target","sources","Object","entries","filter","key","value","undefined","reduce","obj","playCoSocketIOHandlerInstance","PlayCoSocketIOHandler","connected","socketIo","getAuthBody","additionalBody","sid","sessionId","sio_token","sioToken","sio_csrf_token","csrfToken","setSIOStatMsg","newMsg","socketIoStatusMessage","onSocketIOStatusChanged","e","console","log","defaultErrorHandler","reason","shouldDisconnect","alternativeShowMsg","self","constructor","name","message","debugMessage","apiResponse","e1","disconnect","unsubscribeAllHooks","onPlayCoConnected","onPlaylistModified","onUserStatusChanged","socketIoMgr","sioTokenExpiresAt","prevRoomStatus","socketIoEventHandler","connect","id","refreshSIOToken","reconnect","playlist_id","playlist_hash","participants","db_modified","Date","REQUEST_RESPONSE_0","data","PLAYLIST_USER_ENTERED","roomStatus","room","PLAYLIST_USER_EXITED","PLAYLIST_MODIFIED","shouldRoomRefreshed","OFFICIAL_ANNOUNCEMENT","reconnectionDelayMax","path","transports","upgrade","forceNew","autoConnect","closeOnBeforeunload","socket","on","emitEvent","event","onSuccess","onFailure","isRetry","requestId","request_id","eventName","eventHandlerTimeoutID","setTimeout","removeAllListeners","eventHandler","response","clearTimeout","success","dbgMsg","JSON","stringify","code","subCode","startsWith","once","emit","callback","isOnConnect","forceRefresh","err","frostAPI","isSignedIn","then","post","result","sioTokenData","token","exp","catch","isSafeDisconnect","enterPlaylist","playlistId","currentlyPlaying","currently_playing","leavePlaylist","setSessionCurrentPlaying","currentPlaying"],"mappings":"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","sourcesContent":["import { io, Manager } from 'socket.io-client';\r\nimport { FrostError } from 'src/common/error';\r\nimport FrostAPI from 'src/network/api';\r\n\r\nconst SIO_RESP_UNMOUNT_TIMEOUT = 15;\r\nconst SIO_DESCRIPTION = '재생목록의 실시간 정보를 받아오기 위한 연결';\r\nconst COMMON_ERR_MSG_ADD_MAP = {\r\n    retryAfter5Min: '\\n5분 후에 다시 시도해주세요.',\r\n    retryAfter10Min: '\\n10분 후에 다시 시도해주세요.',\r\n    retryFullReload: '\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n    retryAfterSignIn: '\\n로그인 후 이용해주세요.',\r\n}\r\nconst COMMON_ERR_MSG_MAP = {\r\n    safeDisconnected: SIO_DESCRIPTION + '이 종료됐어요.',\r\n\r\n    unknownErrorRetry5Min: SIO_DESCRIPTION + '에서\\n알 수 없는 문제가 생겼어요,' + COMMON_ERR_MSG_ADD_MAP.retryAfter5Min,\r\n    unknownErrorRetryFullReload: SIO_DESCRIPTION + '에서\\n알 수 없는 문제가 생겼어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n    signInRequired: '이 기능은 로그인 후 사용할 수 있어요,' + COMMON_ERR_MSG_ADD_MAP.retryAfterSignIn,\r\n    signInfoCheckFailed: '로그인 정보를 확인하는 중 문제가 발생했어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n    connectFailed: SIO_DESCRIPTION + '을 만들지 못했어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n    unknownDisconnected: SIO_DESCRIPTION + '이\\n알 수 없는 이유로 종료됐어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n    authFailed: SIO_DESCRIPTION + '을 인증하지 못했어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n    authResponseFailed: SIO_DESCRIPTION + '의 인증 정보를 받지 못했어요.' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n    unknownAuthFailed: SIO_DESCRIPTION + '을 인증하는 중\\n알 수 없는 문제가 생겼어요,' + COMMON_ERR_MSG_ADD_MAP.retryFullReload,\r\n}\r\n\r\ninterface PlayCoSocketIOResponseType {\r\n    code: number;\r\n    subCode: string;\r\n    success: boolean;\r\n    message: string;\r\n    data?: Record<string, unknown>;\r\n}\r\n\r\nexport interface PlayCoRoomType {\r\n    playlist_id: number;\r\n    playlist_hash: string;\r\n    participants: {\r\n        [nickname: string]: {\r\n            nickname: string;\r\n            data: Record<string, unknown>;\r\n            status: {\r\n                currently_playing: number;\r\n            };\r\n        }\r\n    };\r\n    current_play_target?: string; // NOT_USED\r\n    db_modified?: boolean;\r\n}\r\n\r\n// Generate random safe string, borrowed from FrostAPI implementation\r\nconst generateRandomSecureToken = (bytes: number) => {\r\n    const randArray = new Uint32Array(bytes);\r\n    window.crypto.getRandomValues(randArray);\r\n    return buf2hex(randArray);\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\n// Buffer to hex, also borrowed from FrostAPI implementation\r\nconst buf2hex = (buffer: ArrayBufferLike) => {\r\n    return [...new Uint8Array(buffer)]\r\n        .map(x => x.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n// From https://stackoverflow.com/a/39977764/5702135\r\nconst assign = (target, ...sources) =>\r\n    Object.assign(target, ...sources.map(x =>\r\n        Object.entries(x)\r\n            .filter(([key, value]) => value !== undefined)\r\n            .reduce((obj, [key, value]) => (obj[key] = value, obj), {})\r\n    ))\r\n\r\nlet playCoSocketIOHandlerInstance: PlayCoSocketIOHandler;\r\nexport class PlayCoSocketIOHandler {\r\n    private socketIoMgr: io.Manager;\r\n    private socketIo: io;\r\n\r\n    private sioToken: string;\r\n    private sioTokenExpiresAt: Date;\r\n    private csrfToken: string;\r\n    private sessionId: string;\r\n\r\n    private prevRoomStatus?: PlayCoRoomType;\r\n\r\n    socketIoStatusMessage: string;\r\n\r\n    onPlayCoConnected?: () => void;\r\n    onPlaylistModified?: () => void;\r\n    onUserStatusChanged?: (PlayCoRoomType) => void;\r\n    onSocketIOStatusChanged?: (string) => void;\r\n\r\n    // UTIL METHOD\r\n    get connected() {\r\n        return this.socketIo.connected;\r\n    }\r\n\r\n    // UTIL METHOD\r\n    private getAuthBody(additionalBody?: Record<string, unknown>) {\r\n        return assign(\r\n            {\r\n                sid: this.sessionId,\r\n                sio_token: this.sioToken,\r\n                sio_csrf_token: this.csrfToken,\r\n            },\r\n            additionalBody ?? {}\r\n        )\r\n    }\r\n\r\n    // UTIL METHOD\r\n    setSIOStatMsg(newMsg: string) {\r\n        this.socketIoStatusMessage = newMsg;\r\n        try { if (this.onSocketIOStatusChanged) this.onSocketIOStatusChanged(newMsg); } catch (e) { console.log(e); }\r\n    }\r\n\r\n    // UTIL METHOD\r\n    defaultErrorHandler(reason: FrostError, shouldDisconnect = true, alternativeShowMsg?: string) {\r\n        const self = this ?? playCoSocketIOHandlerInstance;\r\n\r\n        if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n            console.log(reason.message);\r\n            console.log(reason.debugMessage);\r\n            console.log(reason.apiResponse);\r\n        } else {\r\n            console.log(reason);\r\n        }\r\n\r\n        // Set error message\r\n        try {\r\n            self.setSIOStatMsg(alternativeShowMsg ?? reason.message);\r\n        } catch (e1) {\r\n            console.log(alternativeShowMsg ?? reason.message);\r\n            console.log(e1);\r\n        }\r\n\r\n        // Disconnect from SocketIO.\r\n        if (shouldDisconnect) self.disconnect(false);\r\n\r\n        return false;\r\n    }\r\n\r\n    // UTIL METHOD\r\n    unsubscribeAllHooks() {\r\n        this.onPlayCoConnected = undefined;\r\n        this.onPlaylistModified = undefined;\r\n        this.onUserStatusChanged = undefined;\r\n        this.onSocketIOStatusChanged = undefined;\r\n    }\r\n\r\n    // EVENT HANDLER\r\n    private socketIoEventHandler: Record<string, () => void> = {\r\n        connect: () => {\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            // Get SIO Token and register session\r\n            this.refreshSIOToken(undefined, true, true);\r\n        },\r\n        reconnect: () => {\r\n            // Same as connect\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            // Get SIO Token and register session\r\n            this.refreshSIOToken(undefined, true, true);\r\n        },\r\n        disconnect: (reason) => {\r\n            console.log(`DISCONNECTED FROM PLAYCO SIO, REASON: ${reason}`)\r\n\r\n            // Before disconnect and unconnect all hooks, we need to cleanup the UI if it's possible.\r\n            try {\r\n                if (this.onUserStatusChanged)\r\n                    this.onUserStatusChanged({\r\n                        playlist_id: this.prevRoomStatus?.playlist_id ?? -1,\r\n                        playlist_hash: this.prevRoomStatus?.playlist_hash ?? '',\r\n                        participants: {},\r\n                        db_modified: true,\r\n                    });\r\n            } catch (e) {\r\n                console.log(e);\r\n            }\r\n\r\n            this.unsubscribeAllHooks();\r\n\r\n            this.sessionId = '';\r\n            this.sioToken = '';\r\n            this.sioTokenExpiresAt = new Date();\r\n            this.csrfToken = generateRandomSecureToken(32);\r\n        },\r\n        REQUEST_RESPONSE_0: (data?: PlayCoSocketIOResponseType) => {\r\n            console.log('Unknown response received! Received data >>> ---------------');\r\n            console.log(data);\r\n            console.log('------------------------------------------------------------');\r\n        },\r\n        PLAYLIST_USER_ENTERED: (data: PlayCoSocketIOResponseType) => {\r\n            // When some user entered to this room\r\n            const roomStatus: PlayCoRoomType = data.data.room;\r\n            this.prevRoomStatus = roomStatus;\r\n            try { if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus); } catch (e) { console.log(e); }\r\n        },\r\n        PLAYLIST_USER_EXITED: (data: PlayCoSocketIOResponseType) => {\r\n            // When some user exited from this room\r\n            const roomStatus: PlayCoRoomType = data.data.room;\r\n            try { if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus); } catch (e) { console.log(e); }\r\n        },\r\n        PLAYLIST_MODIFIED: (data: PlayCoSocketIOResponseType) => {\r\n            const roomStatus: PlayCoRoomType = data.data.room;\r\n            const shouldRoomRefreshed: boolean = data.data.room.db_modified ?? false;\r\n            this.prevRoomStatus = roomStatus;\r\n            try { if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus); } catch (e) { console.log(e); }\r\n            try { if (shouldRoomRefreshed && this.onPlaylistModified) this.onPlaylistModified(); } catch (e) { console.log(e); }\r\n        },\r\n        OFFICIAL_ANNOUNCEMENT: (data?: PlayCoSocketIOResponseType) => {\r\n            // RESERVED\r\n            console.log('OFFICIAL_ANNOUNCEMENT event received! Received data >>> ----');\r\n            console.log(data)\r\n            console.log('------------------------------------------------------------');\r\n        },\r\n    };\r\n\r\n    constructor() {\r\n        if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\r\n\r\n        this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\r\n            reconnectionDelayMax: 5000,\r\n            path: '/api/dev/ws',\r\n            transports: ['websocket',],\r\n            upgrade: false,\r\n\r\n            forceNew: false,\r\n            autoConnect: false,\r\n\r\n            closeOnBeforeunload: false,\r\n        });\r\n\r\n        this.socketIo = this.socketIoMgr.socket('/playco_ws');\r\n        for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\r\n            this.socketIo.on(key, value);\r\n        }\r\n\r\n        playCoSocketIOHandlerInstance = this;\r\n    }\r\n\r\n    // EVENT MAKER\r\n    private emitEvent(\r\n        event: string,\r\n        data?: Record<string, unknown>,\r\n        onSuccess?: (response: PlayCoSocketIOResponseType) => void,\r\n        onFailure?: (reason: FrostError, response?: PlayCoSocketIOResponseType) => void,\r\n        isRetry?: boolean) {\r\n\r\n        const requestId = generateRandomSecureToken(16);\r\n        if (data) {\r\n            data.request_id = requestId;\r\n        } else {\r\n            data = { request_id: requestId };\r\n        }\r\n\r\n        const eventName = `REQUEST_RESPONSE_${requestId}`;\r\n\r\n        // Unregister request response handler after {SIO_RESP_UNMOUNT_TIMEOUT}sec.\r\n        const eventHandlerTimeoutID = setTimeout(() => {\r\n            console.log(`WARNING: ${eventName} didn't handled in ${SIO_RESP_UNMOUNT_TIMEOUT}sec, and handler is unmounted.`);\r\n            this.socketIo.removeAllListeners(eventName);\r\n        }, SIO_RESP_UNMOUNT_TIMEOUT * 1000);\r\n\r\n        const eventHandler = (response?: PlayCoSocketIOResponseType) => {\r\n            clearTimeout(eventHandlerTimeoutID); // This will clear eventHandlerTimeout.\r\n\r\n            try {\r\n                if (response?.success) {\r\n                    if (onSuccess) onSuccess(response);\r\n                } else {\r\n                    // Response contains (success == false)\r\n                    let dbgMsg = 'sio:emitEvent error\\n';\r\n                    dbgMsg += `(event=${event})=>\\n`\r\n                    if (response) {\r\n                        for (const [key, value] of Object.entries(response ?? {})) {\r\n                            if (key !== 'data') {\r\n                                dbgMsg += `response?.${key} = ${value}\\n`\r\n                            } else {\r\n                                dbgMsg += `response?.${key} = ${JSON.stringify(value)}\\n`\r\n                            }\r\n                        }\r\n                    } else { dbgMsg += `response = ${response}\\n`; }\r\n\r\n                    if (event === 'playco_connect') {\r\n                        this.defaultErrorHandler(\r\n                            new FrostError(\r\n                                response?.message ?? COMMON_ERR_MSG_MAP.unknownAuthFailed,\r\n                                dbgMsg, response?.code, false),\r\n                            true, COMMON_ERR_MSG_MAP.unknownAuthFailed);\r\n                        return;\r\n                    } else if (isRetry) {\r\n                        this.defaultErrorHandler(\r\n                            new FrostError(\r\n                                response?.message ?? COMMON_ERR_MSG_MAP.unknownAuthFailed,\r\n                                dbgMsg, response?.code, false),\r\n                            true, COMMON_ERR_MSG_MAP.unknownAuthFailed);\r\n                        return;\r\n                    } else if (response?.subCode.startsWith('SIO_TOKEN_')) {\r\n                        // Refresh SIO Token and retry emitEvent.\r\n                        this.refreshSIOToken(() => this.emitEvent(event, data, onSuccess, onFailure, true), false, true);\r\n                        return;\r\n                    } else {\r\n                        this.defaultErrorHandler(\r\n                            new FrostError(\r\n                                response?.message || COMMON_ERR_MSG_MAP.unknownErrorRetry5Min,\r\n                                dbgMsg, response?.code, false),\r\n                            false, COMMON_ERR_MSG_MAP.unknownErrorRetry5Min);\r\n                        return;\r\n                    }\r\n                }\r\n            } catch (e: FrostError) {\r\n                if (onFailure) {\r\n                    try {\r\n                        onFailure(e, response);\r\n                    } catch (e1) {\r\n                        console.log(e);\r\n                        console.log(e1);\r\n\r\n                        this.defaultErrorHandler(e, false, COMMON_ERR_MSG_MAP.unknownErrorRetry5Min);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this.socketIo.once(eventName, eventHandler);\r\n        this.socketIo.emit(event, data);\r\n    }\r\n\r\n    // EVENT MAKER\r\n    private refreshSIOToken(callback: (() => void) = (() => { /* */ }), isOnConnect = false, forceRefresh = false) {\r\n        if (!forceRefresh && this.sioToken && this.sioTokenExpiresAt > new Date()) {\r\n            // We assumes that token is alive.\r\n            // If the callback is emitEvent and server returns SIO_TOKEN_EXPIRED or SIO_TOKEN_INVALID,\r\n            // then emitEvent method will handle it properly.\r\n            try {\r\n                callback();\r\n                return;\r\n            } catch (err) {\r\n                this.defaultErrorHandler(err);\r\n            }\r\n        }\r\n\r\n        const frostAPI = new FrostAPI();\r\n        frostAPI\r\n            .isSignedIn(true)\r\n            .then(\r\n                (isSignedIn) => {\r\n                    if (!isSignedIn) { // Check if Frost is signed in.\r\n                        throw new FrostError(\r\n                            COMMON_ERR_MSG_MAP.signInRequired,\r\n                            'on refreshSIOToken, isSignedIn == false', -1, false);\r\n                    } else if (!this.socketIo.connected || !this.sessionId) { // Check if Socket.IO is connected, and every statement is fulfilled.\r\n                        throw new FrostError(\r\n                            COMMON_ERR_MSG_MAP.connectFailed,\r\n                            `this.socketIo.connected = ${this.socketIo.connected}, !this.sessionId = ${this.sessionId}`, -1, false);\r\n                    }\r\n\r\n                    // We need to get a new SIO Token by request.\r\n                    this.csrfToken = generateRandomSecureToken(32);\r\n                    return frostAPI\r\n                        .post('playco/socketio/auth', this.getAuthBody(), true)\r\n                        .then(\r\n                            (result) => {\r\n                                if (!result.success) {\r\n                                    throw new FrostError(\r\n                                        COMMON_ERR_MSG_MAP.authResponseFailed,\r\n                                        '/playco/socketio/auth returns response.success == false',\r\n                                        result.code, false, result);\r\n                                }\r\n\r\n                                // Get SIO token from response\r\n                                const sioTokenData: { 'exp': string, 'token': string } = result.data.sio_token;\r\n                                this.sioToken = sioTokenData.token;\r\n                                this.sioTokenExpiresAt = new Date(sioTokenData.exp);\r\n\r\n                                // Register session if this function is called on SocketIO onConnect event.\r\n                                if (isOnConnect) {\r\n                                    this.emitEvent(\r\n                                        'playco_connect', this.getAuthBody(),\r\n                                        (response) => ((this.onPlayCoConnected) ? this.onPlayCoConnected() : () => {/* */ }),\r\n                                        // Session creation failed\r\n                                        (reason, response) => this.defaultErrorHandler(reason, true, COMMON_ERR_MSG_MAP.authFailed)\r\n                                    );\r\n                                    return;\r\n                                } else {\r\n                                    callback();\r\n                                    return;\r\n                                }\r\n                            },\r\n                            (reason: FrostError) => { // Failed to get SIO token\r\n                                reason.message = COMMON_ERR_MSG_MAP.authFailed;\r\n                                throw reason;\r\n                            },\r\n                        );\r\n                },\r\n                (reason: FrostError) => {\r\n                    reason.message = COMMON_ERR_MSG_MAP.signInfoCheckFailed;\r\n                    throw reason;\r\n                }\r\n            ).catch(this.defaultErrorHandler);\r\n    }\r\n\r\n    // EVENT MAKER\r\n    connect() {\r\n        if (!this.socketIo.connected) // Connect SocketIO if it's not connected.\r\n            // This will fire this.socketIoEventHandler.connect if the connection is successfully established.\r\n            this.socketIo.connect();\r\n    }\r\n\r\n    // EVENT MAKER\r\n    disconnect(isSafeDisconnect = true) {\r\n        if (this.socketIo.connected) {\r\n            this.socketIo.disconnect();\r\n\r\n            if (isSafeDisconnect)\r\n                this.setSIOStatMsg(COMMON_ERR_MSG_MAP.safeDisconnected);\r\n        }\r\n    }\r\n\r\n    // EVENT MAKER\r\n    enterPlaylist(playlistId: number, currentlyPlaying?: number) {\r\n        this.refreshSIOToken(\r\n            () => this.emitEvent(\r\n                'playlist_enter',\r\n                this.getAuthBody(({ playlist_id: playlistId, currently_playing: currentlyPlaying })),\r\n                (response) => { /* */ },\r\n                (reason, response) => { /* */ },\r\n            )\r\n        );\r\n    }\r\n\r\n    // EVENT MAKER\r\n    leavePlaylist(playlistId: number) {\r\n        this.refreshSIOToken(\r\n            () => this.emitEvent(\r\n                'playlist_leave',\r\n                this.getAuthBody(({ playlist_id: playlistId })),\r\n                (response) => { /* */ },\r\n                (reason, response) => { /* */ },\r\n            )\r\n        );\r\n    }\r\n\r\n    // EVENT MAKER\r\n    setSessionCurrentPlaying(playlistId: number, currentPlaying: number) {\r\n        this.refreshSIOToken(\r\n            () => this.emitEvent(\r\n                'playlist_set_status',\r\n                this.getAuthBody(({ playlist_id: playlistId, currently_playing: currentPlaying })),\r\n                (response) => { /* */ },\r\n                (reason, response) => { /* */ },\r\n            )\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}