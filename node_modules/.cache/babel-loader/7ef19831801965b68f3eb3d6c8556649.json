{"ast":null,"code":"import { Manager } from 'socket.io-client';\nimport { FrostError } from 'src/common/error';\nimport FrostAPI from 'src/network/api';\n\n// Generate random safe string, borrowed from FrostAPI implementation\nconst generateRandomSecureToken = bytes => {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}; // From https://stackoverflow.com/a/40031979\n// Buffer to hex, also borrowed from FrostAPI implementation\n\n\nconst buf2hex = buffer => {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n};\n\nlet playCoSocketIOHandlerInstance;\nexport class PlayCoSocketIOHandler {\n  constructor() {\n    this.socketIoMgr = void 0;\n    this.socketIo = void 0;\n    this.sioToken = void 0;\n    this.sioTokenExpiresAt = void 0;\n    this.csrfToken = void 0;\n    this.sessionId = void 0;\n    this.socketIoStatusMessage = void 0;\n    this.onPlaylistModified = void 0;\n    this.onUserStatusChanged = void 0;\n    this.onSocketIOStatusChanged = void 0;\n    this.socketIoEventHandler = {\n      connect: () => {\n        this.sessionId = this.socketIo.id; // Get SIO Token and register session\n\n        this.refreshSIOToken(true);\n      },\n      reconnect: () => {\n        // Same as connect\n        this.sessionId = this.socketIo.id; // Get SIO Token and register session\n\n        this.refreshSIOToken(true);\n      },\n      disconnect: reason => {\n        this.unsubscribeAllHooks();\n        this.sessionId = '';\n        this.sioToken = '';\n        this.sioTokenExpiresAt = new Date();\n        this.csrfToken = generateRandomSecureToken(32);\n      },\n      REQUEST_RESPONSE_0: data => {\n        console.log('Unknown response received! Received data >>> ---------------');\n        console.log(data);\n        console.log('------------------------------------------------------------');\n      },\n      PLAYLIST_USER_ENTERED: data => {\n        // When some user entered to this room\n        const roomStatus = data.data.room;\n\n        try {\n          if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus);\n        } catch (e) {\n          console.log(e);\n        }\n      },\n      PLAYLIST_USER_EXITED: data => {\n        // When some user exited from this room\n        const roomStatus = data.data.room;\n\n        try {\n          if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus);\n        } catch (e) {\n          console.log(e);\n        }\n      },\n      PLAYLIST_MODIFIED: data => {\n        var _data$data$room$db_mo;\n\n        const shouldRoomRefreshed = (_data$data$room$db_mo = data.data.room.db_modified) !== null && _data$data$room$db_mo !== void 0 ? _data$data$room$db_mo : false;\n\n        try {\n          if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus);\n        } catch (e) {\n          console.log(e);\n        }\n\n        try {\n          if (shouldRoomRefreshed && this.onPlaylistModified) this.onPlaylistModified();\n        } catch (e) {}\n      },\n      OFFICIAL_ANNOUNCEMENT: data => {\n        // RESERVED\n        console.log('OFFICIAL_ANNOUNCEMENT event received! Received data >>> ----');\n        console.log(data);\n        console.log('------------------------------------------------------------');\n      }\n    };\n    if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\n    this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\n      reconnectionDelayMax: 5000,\n      path: '/api/dev/ws',\n      transports: ['websocket'],\n      upgrade: false,\n      forceNew: false,\n      autoConnect: false,\n      closeOnBeforeunload: false\n    });\n    this.socketIo = this.socketIoMgr.socket('/playco_ws');\n\n    for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\n      this.socketIo.on(key, value);\n    }\n\n    playCoSocketIOHandlerInstance = this;\n  }\n\n  emitEvent(event, data, onResponse) {\n    const requestId = generateRandomSecureToken(16);\n\n    if (data) {\n      data['requestId'] = requestId;\n    } else {\n      data = {\n        requestId: requestId\n      };\n    }\n\n    if (onResponse) {\n      const eventName = `REQUEST_RESPONSE_${requestId}`; // Unregister request response handler after 10sec.\n\n      const eventHandlerTimeoutID = setTimeout(() => {\n        console.log(`WARNING: ${eventName} didn't handled in 15sec, and handler is unmounted.`);\n        this.socketIo.removeAllListeners(eventName);\n      }, 15000);\n\n      const eventHandler = response => {\n        clearTimeout(eventHandlerTimeoutID); // This will clear eventHandlerTimeout.\n\n        onResponse(response);\n      };\n\n      this.socketIo.once(eventName, eventHandler);\n    }\n\n    this.socketIo.emit(event, data);\n  }\n\n  refreshSIOToken(isOnConnect = false) {\n    const frostAPI = new FrostAPI();\n    return frostAPI.isSignedIn(true).then(isSignedIn => {\n      if (!isSignedIn) {\n        this.disconnect();\n        return Promise.reject(new FrostError('로그인이 되어있지 않아요.', `on refreshSIOToken, isSignedIn == false`, -1, false));\n      } // Check if Socket.IO is connected, and every statement is fulfilled.\n\n\n      if (!this.socketIo.connected || !this.sessionId) {\n        this.disconnect();\n        return Promise.reject(new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결에 실패했어요.', `this.socketIo.connected = ${this.socketIo.connected}, !this.sessionId = ${this.sessionId}`, -1, false));\n      } // We need to get a new SIO Token by request.\n\n\n      this.csrfToken = generateRandomSecureToken(32);\n      return frostAPI.post('playco/socketio/auth', {\n        'sid': this.sessionId,\n        'sio_csrf_token': this.csrfToken\n      }, true).then(result => {\n        // Get SIO token from response\n        const sioTokenData = result.data.sio_token;\n        this.sioToken = sioTokenData;\n        this.sioTokenExpiresAt = new Date(sioTokenData.exp); // Register session if this function is called on SocketIO onConnect event.\n\n        if (isOnConnect) {\n          this.emitEvent('playco_connect', {\n            sio_token: this.sioToken,\n            sio_csrf_token: this.csrfToken\n          }, response => {\n            console.log(response);\n\n            if (response.success) {// Request success, do nothing\n            } else {\n              // Request failed = Session creation failed\n              const errMsg = response.message || '재생목록의 실시간 정보를 받아오기 위한 연결을 인증하는 중\\n알 수 없는 문제가 발생했어요.';\n              let dbgMsg = 'sio:playco_connect=>response.success=false, ';\n              dbgMsg += `code=${response.code}, subCode=${response.subCode}`;\n              throw new FrostError(errMsg, dbgMsg, response.code, false);\n            }\n          });\n        }\n      }, reason => {\n        console.log(reason);\n        console.log(reason.debugMessage); // Failed to get SIO token, disconnect from SocketIO.\n\n        this.disconnect(); // Continue onRejected.\n\n        reason.message = '재생목록의 실시간 정보를 받아오기 위한 연결을 인증하는데 실패했어요.';\n        throw reason;\n      });\n    }, reason => {\n      this.disconnect();\n      reason.message = '로그인 정보를 확인하는 중 문제가 발생했어요.';\n      return Promise.reject(reason);\n    });\n  }\n\n  get connected() {\n    return this.socketIo.connected;\n  }\n\n  setSIOStatMsg(newMsg) {\n    this.socketIoStatusMessage = newMsg;\n\n    try {\n      if (this.onSocketIOStatusChanged) this.onSocketIOStatusChanged(newMsg);\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  unsubscribeAllHooks() {\n    this.onPlaylistModified = undefined;\n    this.onUserStatusChanged = undefined;\n    this.onSocketIOStatusChanged = undefined;\n  }\n\n  connect() {\n    if (!this.socketIo.connected) // Connect SocketIO if it's not connected.\n      // This will fire this.socketIoEventHandler.connect if the connection is successfully established.\n      this.socketIo.connect();\n  }\n\n  disconnect() {\n    if (this.socketIo.connected) this.socketIo.disconnect();\n  }\n\n  enterPlaylist(playlistId) {\n    const frostAPI = new FrostAPI();\n    return frostAPI.isSignedIn(true).then(isSignedIn => {\n      if (!isSignedIn) {\n        throw new FrostError('로그아웃 되었어요, 다시 로그인을 해 주세요.', 'on enterPlaylist, isSignedIn == false', 400, true);\n      }\n\n      if (!this.socketIo.connected) {\n        throw new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.', 'enterPlaylist->this.socketIo.connected == false', -1, false);\n      }\n\n      this.emitEvent('playlist_enter', {\n        playlist_id: playlistId,\n        sio_token: this.sioToken,\n        sio_csrf_token: this.csrfToken\n      }, response => {\n        console.log(response);\n\n        if (response.success) {// Request success\n        } else {// Request failed\n          }\n      });\n    });\n  }\n\n  leavePlaylist(playlistId) {\n    const frostAPI = new FrostAPI();\n    return frostAPI.isSignedIn(true).then(isSignedIn => {\n      if (!isSignedIn) {\n        throw new FrostError('로그아웃 되었어요, 다시 로그인을 해 주세요.', 'on enterPlaylist, isSignedIn == false', 400, true);\n      }\n\n      if (!this.socketIo.connected) {\n        throw new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.', 'enterPlaylist->this.socketIo.connected == false', -1, false);\n      }\n\n      this.emitEvent('playlist_leave', {\n        playlist_id: playlistId,\n        sio_token: this.sioToken,\n        sio_csrf_token: this.csrfToken\n      }, response => {\n        console.log(response);\n\n        if (response.success) {// Request success\n        } else {// Request failed\n          }\n      });\n    });\n  }\n\n  setSessionCurrentPlaying(playlistId, currentPlaying) {\n    const frostAPI = new FrostAPI();\n    return frostAPI.isSignedIn(true).then(isSignedIn => {\n      if (!isSignedIn) {\n        throw new FrostError('로그아웃 되었어요, 다시 로그인을 해 주세요.', 'on enterPlaylist, isSignedIn == false', 400, true);\n      }\n\n      if (!this.socketIo.connected) {\n        throw new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.', 'enterPlaylist->this.socketIo.connected == false', -1, false);\n      }\n\n      this.emitEvent('playlist_set_status', {\n        sio_token: this.sioToken,\n        sio_csrf_token: this.csrfToken,\n        playlist_id: playlistId,\n        currently_playing: currentPlaying\n      }, response => {\n        console.log(response);\n\n        if (response.success) {// Request success\n        } else {// Request failed\n          }\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/ui/page/playco/playco/sio.ts"],"names":["Manager","FrostError","FrostAPI","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","playCoSocketIOHandlerInstance","PlayCoSocketIOHandler","constructor","socketIoMgr","socketIo","sioToken","sioTokenExpiresAt","csrfToken","sessionId","socketIoStatusMessage","onPlaylistModified","onUserStatusChanged","onSocketIOStatusChanged","socketIoEventHandler","connect","id","refreshSIOToken","reconnect","disconnect","reason","unsubscribeAllHooks","Date","REQUEST_RESPONSE_0","data","console","log","PLAYLIST_USER_ENTERED","roomStatus","room","e","PLAYLIST_USER_EXITED","PLAYLIST_MODIFIED","shouldRoomRefreshed","db_modified","OFFICIAL_ANNOUNCEMENT","reconnectionDelayMax","path","transports","upgrade","forceNew","autoConnect","closeOnBeforeunload","socket","key","value","Object","entries","on","emitEvent","event","onResponse","requestId","eventName","eventHandlerTimeoutID","setTimeout","removeAllListeners","eventHandler","response","clearTimeout","once","emit","isOnConnect","frostAPI","isSignedIn","then","Promise","reject","connected","post","result","sioTokenData","sio_token","exp","sio_csrf_token","success","errMsg","message","dbgMsg","code","subCode","debugMessage","setSIOStatMsg","newMsg","undefined","enterPlaylist","playlistId","playlist_id","leavePlaylist","setSessionCurrentPlaying","currentPlaying","currently_playing"],"mappings":"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","sourcesContent":["import { io, Manager } from 'socket.io-client';\r\nimport { FrostError } from 'src/common/error';\r\nimport FrostAPI from 'src/network/api';\r\n\r\ninterface PlayCoSocketIOResponseType {\r\n    code: number;\r\n    subCode: string;\r\n    success: boolean;\r\n    message: string;\r\n    data?: Record<string, unknown>;\r\n}\r\n\r\nexport interface PlayCoRoomType {\r\n    playlist_id: number;\r\n    playlist_hash: string;\r\n    participants: {\r\n        [nickname: string]: {\r\n            nickname: string;\r\n            data: Record<string, unknown>;\r\n            status: {\r\n                currently_playing: number;\r\n            };\r\n        }\r\n    };\r\n    current_play_target?: string; // NOT_USED\r\n    db_modified?: boolean;\r\n}\r\n\r\n// Generate random safe string, borrowed from FrostAPI implementation\r\nconst generateRandomSecureToken = (bytes: number) => {\r\n    const randArray = new Uint32Array(bytes);\r\n    window.crypto.getRandomValues(randArray);\r\n    return buf2hex(randArray);\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\n// Buffer to hex, also borrowed from FrostAPI implementation\r\nconst buf2hex = (buffer: ArrayBufferLike) => {\r\n    return [...new Uint8Array(buffer)]\r\n        .map(x => x.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\nlet playCoSocketIOHandlerInstance: PlayCoSocketIOHandler;\r\nexport class PlayCoSocketIOHandler {\r\n    private socketIoMgr: io.Manager;\r\n    private socketIo: io;\r\n\r\n    private sioToken: string;\r\n    private sioTokenExpiresAt: Date;\r\n    private csrfToken: string;\r\n    private sessionId: string;\r\n\r\n    socketIoStatusMessage: string;\r\n\r\n    onPlaylistModified?: () => void;\r\n    onUserStatusChanged?: (PlayCoRoomType) => void;\r\n    onSocketIOStatusChanged?: (string) => void;\r\n\r\n    private socketIoEventHandler: Record<string, () => void> = {\r\n        connect: () => {\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            // Get SIO Token and register session\r\n            this.refreshSIOToken(true);\r\n        },\r\n        reconnect: () => {\r\n            // Same as connect\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            // Get SIO Token and register session\r\n            this.refreshSIOToken(true);\r\n        },\r\n        disconnect: (reason) => {\r\n            this.unsubscribeAllHooks();\r\n\r\n            this.sessionId = '';\r\n            this.sioToken = '';\r\n            this.sioTokenExpiresAt = new Date();\r\n            this.csrfToken = generateRandomSecureToken(32);\r\n        },\r\n        REQUEST_RESPONSE_0: (data?: PlayCoSocketIOResponseType) => {\r\n            console.log('Unknown response received! Received data >>> ---------------');\r\n            console.log(data);\r\n            console.log('------------------------------------------------------------');\r\n        },\r\n        PLAYLIST_USER_ENTERED: (data: PlayCoSocketIOResponseType) => {\r\n            // When some user entered to this room\r\n            const roomStatus: PlayCoRoomType = data.data.room;\r\n            try { if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus); } catch (e) { console.log(e); }\r\n        },\r\n        PLAYLIST_USER_EXITED: (data: PlayCoSocketIOResponseType) => {\r\n            // When some user exited from this room\r\n            const roomStatus: PlayCoRoomType = data.data.room;\r\n            try { if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus); } catch (e) { console.log(e); }\r\n        },\r\n        PLAYLIST_MODIFIED: (data: PlayCoSocketIOResponseType) => {\r\n            const shouldRoomRefreshed: boolean = data.data.room.db_modified ?? false;\r\n            try { if (this.onUserStatusChanged) this.onUserStatusChanged(roomStatus); } catch (e) { console.log(e); }\r\n            try { if (shouldRoomRefreshed && this.onPlaylistModified) this.onPlaylistModified(); } catch (e) { }\r\n        },\r\n        OFFICIAL_ANNOUNCEMENT: (data?: PlayCoSocketIOResponseType) => {\r\n            // RESERVED\r\n            console.log('OFFICIAL_ANNOUNCEMENT event received! Received data >>> ----');\r\n            console.log(data)\r\n            console.log('------------------------------------------------------------');\r\n        },\r\n    };\r\n\r\n    constructor() {\r\n        if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\r\n\r\n        this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\r\n            reconnectionDelayMax: 5000,\r\n            path: '/api/dev/ws',\r\n            transports: ['websocket',],\r\n            upgrade: false,\r\n\r\n            forceNew: false,\r\n            autoConnect: false,\r\n\r\n            closeOnBeforeunload: false,\r\n        });\r\n\r\n        this.socketIo = this.socketIoMgr.socket('/playco_ws');\r\n        for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\r\n            this.socketIo.on(key, value);\r\n        }\r\n\r\n        playCoSocketIOHandlerInstance = this;\r\n    }\r\n\r\n    private emitEvent(\r\n        event: string,\r\n        data?: Record<string, unknown>,\r\n        onResponse?: (response: PlayCoSocketIOResponseType) => void) {\r\n\r\n        const requestId = generateRandomSecureToken(16);\r\n        if (data) {\r\n            data['requestId'] = requestId;\r\n        } else {\r\n            data = { requestId: requestId };\r\n        }\r\n\r\n        if (onResponse) {\r\n            const eventName = `REQUEST_RESPONSE_${requestId}`;\r\n\r\n            // Unregister request response handler after 10sec.\r\n            const eventHandlerTimeoutID = setTimeout(() => {\r\n                console.log(`WARNING: ${eventName} didn't handled in 15sec, and handler is unmounted.`);\r\n                this.socketIo.removeAllListeners(eventName);\r\n            }, 15000);\r\n\r\n            const eventHandler = (response: PlayCoSocketIOResponseType) => {\r\n                clearTimeout(eventHandlerTimeoutID); // This will clear eventHandlerTimeout.\r\n                onResponse(response);\r\n            };\r\n\r\n            this.socketIo.once(eventName, eventHandler);\r\n        }\r\n\r\n        this.socketIo.emit(event, data);\r\n    }\r\n\r\n    private refreshSIOToken(isOnConnect = false) {\r\n        const frostAPI = new FrostAPI();\r\n        return frostAPI.isSignedIn(true).then(\r\n            (isSignedIn) => {\r\n                if (!isSignedIn) {\r\n                    this.disconnect();\r\n                    return Promise.reject(new FrostError(\r\n                        '로그인이 되어있지 않아요.',\r\n                        `on refreshSIOToken, isSignedIn == false`,\r\n                        -1, false\r\n                    ));\r\n                }\r\n\r\n                // Check if Socket.IO is connected, and every statement is fulfilled.\r\n                if (!this.socketIo.connected || !this.sessionId) {\r\n                    this.disconnect();\r\n                    return Promise.reject(new FrostError(\r\n                        '재생목록의 실시간 정보를 받아오기 위한 연결에 실패했어요.',\r\n                        `this.socketIo.connected = ${this.socketIo.connected}, !this.sessionId = ${this.sessionId}`,\r\n                        -1, false\r\n                    ));\r\n                }\r\n\r\n                // We need to get a new SIO Token by request.\r\n                this.csrfToken = generateRandomSecureToken(32);\r\n                return frostAPI\r\n                    .post('playco/socketio/auth', { 'sid': this.sessionId, 'sio_csrf_token': this.csrfToken, }, true)\r\n                    .then(\r\n                        (result) => {\r\n                            // Get SIO token from response\r\n                            const sioTokenData: { 'exp': string, 'token': string } = result.data.sio_token;\r\n                            this.sioToken = sioTokenData;\r\n                            this.sioTokenExpiresAt = new Date(sioTokenData.exp);\r\n\r\n                            // Register session if this function is called on SocketIO onConnect event.\r\n                            if (isOnConnect) {\r\n                                this.emitEvent(\r\n                                    'playco_connect',\r\n                                    { sio_token: this.sioToken, sio_csrf_token: this.csrfToken, },\r\n                                    (response: PlayCoSocketIOResponseType) => {\r\n                                        console.log(response);\r\n                                        if (response.success) {\r\n                                            // Request success, do nothing\r\n                                        } else {\r\n                                            // Request failed = Session creation failed\r\n                                            const errMsg = response.message || '재생목록의 실시간 정보를 받아오기 위한 연결을 인증하는 중\\n알 수 없는 문제가 발생했어요.';\r\n                                            let dbgMsg = 'sio:playco_connect=>response.success=false, ';\r\n                                            dbgMsg += `code=${response.code}, subCode=${response.subCode}`;\r\n                                            throw new FrostError(errMsg, dbgMsg, response.code, false);\r\n                                        }\r\n                                    }\r\n                                );\r\n                            }\r\n                        },\r\n                        (reason: FrostError) => {\r\n                            console.log(reason);\r\n                            console.log(reason.debugMessage);\r\n\r\n                            // Failed to get SIO token, disconnect from SocketIO.\r\n                            this.disconnect();\r\n\r\n                            // Continue onRejected.\r\n                            reason.message = '재생목록의 실시간 정보를 받아오기 위한 연결을 인증하는데 실패했어요.';\r\n                            throw reason;\r\n                        },\r\n                    );\r\n            },\r\n            (reason: FrostError) => {\r\n                this.disconnect();\r\n                reason.message = '로그인 정보를 확인하는 중 문제가 발생했어요.';\r\n                return Promise.reject(reason);\r\n            }\r\n        );\r\n    }\r\n\r\n    get connected() {\r\n        return this.socketIo.connected;\r\n    }\r\n\r\n    setSIOStatMsg(newMsg: string) {\r\n        this.socketIoStatusMessage = newMsg;\r\n        try { if (this.onSocketIOStatusChanged) this.onSocketIOStatusChanged(newMsg); } catch (e) { console.log(e); }\r\n    }\r\n\r\n    unsubscribeAllHooks() {\r\n        this.onPlaylistModified = undefined;\r\n        this.onUserStatusChanged = undefined;\r\n        this.onSocketIOStatusChanged = undefined;\r\n    }\r\n\r\n    connect() {\r\n        if (!this.socketIo.connected) // Connect SocketIO if it's not connected.\r\n            // This will fire this.socketIoEventHandler.connect if the connection is successfully established.\r\n            this.socketIo.connect();\r\n    }\r\n\r\n    disconnect() {\r\n        if (this.socketIo.connected)\r\n            this.socketIo.disconnect();\r\n    }\r\n\r\n    enterPlaylist(playlistId: number) {\r\n        const frostAPI = new FrostAPI();\r\n        return frostAPI.isSignedIn(true).then(\r\n            (isSignedIn) => {\r\n                if (!isSignedIn) {\r\n                    throw new FrostError('로그아웃 되었어요, 다시 로그인을 해 주세요.', 'on enterPlaylist, isSignedIn == false', 400, true);\r\n                }\r\n\r\n                if (!this.socketIo.connected) {\r\n                    throw new FrostError(\r\n                        '재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n                        'enterPlaylist->this.socketIo.connected == false', -1, false);\r\n                }\r\n\r\n                this.emitEvent(\r\n                    'playlist_enter',\r\n                    { playlist_id: playlistId, sio_token: this.sioToken, sio_csrf_token: this.csrfToken, },\r\n                    (response: PlayCoSocketIOResponseType) => {\r\n                        console.log(response);\r\n                        if (response.success) {\r\n                            // Request success\r\n                        } else {\r\n                            // Request failed\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        );\r\n    }\r\n\r\n    leavePlaylist(playlistId: number) {\r\n        const frostAPI = new FrostAPI();\r\n        return frostAPI.isSignedIn(true).then(\r\n            (isSignedIn) => {\r\n                if (!isSignedIn) {\r\n                    throw new FrostError('로그아웃 되었어요, 다시 로그인을 해 주세요.', 'on enterPlaylist, isSignedIn == false', 400, true);\r\n                }\r\n\r\n                if (!this.socketIo.connected) {\r\n                    throw new FrostError(\r\n                        '재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n                        'enterPlaylist->this.socketIo.connected == false', -1, false);\r\n                }\r\n\r\n                this.emitEvent(\r\n                    'playlist_leave',\r\n                    { playlist_id: playlistId, sio_token: this.sioToken, sio_csrf_token: this.csrfToken, },\r\n                    (response: PlayCoSocketIOResponseType) => {\r\n                        console.log(response);\r\n                        if (response.success) {\r\n                            // Request success\r\n                        } else {\r\n                            // Request failed\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        );\r\n    }\r\n\r\n    setSessionCurrentPlaying(playlistId: number, currentPlaying: number) {\r\n        const frostAPI = new FrostAPI();\r\n        return frostAPI.isSignedIn(true).then(\r\n            (isSignedIn) => {\r\n                if (!isSignedIn) {\r\n                    throw new FrostError('로그아웃 되었어요, 다시 로그인을 해 주세요.', 'on enterPlaylist, isSignedIn == false', 400, true);\r\n                }\r\n\r\n                if (!this.socketIo.connected) {\r\n                    throw new FrostError(\r\n                        '재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n                        'enterPlaylist->this.socketIo.connected == false', -1, false);\r\n                }\r\n\r\n                this.emitEvent(\r\n                    'playlist_set_status',\r\n                    {\r\n                        sio_token: this.sioToken,\r\n                        sio_csrf_token: this.csrfToken,\r\n                        playlist_id: playlistId,\r\n                        currently_playing: currentPlaying,\r\n                    },\r\n                    (response: PlayCoSocketIOResponseType) => {\r\n                        console.log(response);\r\n                        if (response.success) {\r\n                            // Request success\r\n                        } else {\r\n                            // Request failed\r\n                        }\r\n                    }\r\n                );\r\n            }\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}