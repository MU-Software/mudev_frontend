{"ast":null,"code":"\"use strict\";\n\nvar url = require('url');\n\nvar parse_url = function parse_url(remote_url, options) {\n  if (typeof remote_url == \"string\") remote_url = url.parse(remote_url);\n  return parse_host(remote_url.hostname, options);\n};\n\nvar tlds = null;\n\nvar parse_host = function parse_host(host, options) {\n  var allowPrivateTLD = options && options.allowPrivateTLD || false;\n  var allowUnknownTLD = options && options.allowUnknownTLD || false;\n\n  if (!tlds) {\n    tlds = require('./effective_tld_names.json');\n    tlds.combined = Object.assign({}, tlds.icann, tlds.private);\n  }\n\n  var parts = host.split(\".\");\n  var stack = \"\",\n      tld_level = -1;\n  var roots = allowPrivateTLD ? tlds.combined : tlds.icann;\n\n  for (var i = parts.length - 1, part; i >= 0; i--) {\n    part = parts[i];\n    stack = stack ? part + \".\" + stack : part;\n    if (roots[stack]) tld_level = roots[stack];\n  }\n\n  if (tld_level == -1 && allowUnknownTLD) tld_level = 1;\n  if (parts.length <= tld_level || tld_level == -1) throw new Error(\"Invalid TLD \" + JSON.stringify({\n    parts: parts,\n    tld_level: tld_level,\n    allowUnknownTLD: allowUnknownTLD\n  }));\n  return {\n    tld: parts.slice(-tld_level).join('.'),\n    domain: parts.slice(-tld_level - 1).join('.'),\n    sub: parts.slice(0, -tld_level - 1).join('.')\n  };\n};\n\nmodule.exports = parse_url;\nmodule.exports.parse_host = parse_host;","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/tld-extract-npm-2.0.1-c8943623c3-748ef6a5c6.zip/node_modules/tld-extract/index.js"],"names":["url","require","parse_url","remote_url","options","parse","parse_host","hostname","tlds","host","allowPrivateTLD","allowUnknownTLD","combined","Object","assign","icann","private","parts","split","stack","tld_level","roots","i","length","part","Error","JSON","stringify","tld","slice","join","domain","sub","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAjB;;AAGA,IAAIC,SAAS,GAAG,SAAZA,SAAY,CAASC,UAAT,EAAqBC,OAArB,EAA8B;AAC5C,MAAG,OAAOD,UAAP,IAAqB,QAAxB,EACEA,UAAU,GAAGH,GAAG,CAACK,KAAJ,CAAUF,UAAV,CAAb;AACF,SAAOG,UAAU,CAACH,UAAU,CAACI,QAAZ,EAAsBH,OAAtB,CAAjB;AACD,CAJD;;AAMA,IAAII,IAAI,GAAG,IAAX;;AAEA,IAAIF,UAAU,GAAG,SAAbA,UAAa,CAASG,IAAT,EAAeL,OAAf,EAAwB;AACvC,MAAIM,eAAe,GAAGN,OAAO,IAAIA,OAAO,CAACM,eAAnB,IAAsC,KAA5D;AACA,MAAIC,eAAe,GAAGP,OAAO,IAAIA,OAAO,CAACO,eAAnB,IAAsC,KAA5D;;AAEA,MAAG,CAACH,IAAJ,EAAU;AACRA,IAAAA,IAAI,GAAGP,OAAO,CAAC,4BAAD,CAAd;AACAO,IAAAA,IAAI,CAACI,QAAL,GAAgBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBN,IAAI,CAACO,KAAvB,EAA8BP,IAAI,CAACQ,OAAnC,CAAhB;AACD;;AAED,MAAIC,KAAK,GAAGR,IAAI,CAACS,KAAL,CAAW,GAAX,CAAZ;AACA,MAAIC,KAAK,GAAG,EAAZ;AAAA,MAAgBC,SAAS,GAAG,CAAC,CAA7B;AAEA,MAAIC,KAAK,GAAGX,eAAe,GAAGF,IAAI,CAACI,QAAR,GAAmBJ,IAAI,CAACO,KAAnD;;AAEA,OAAI,IAAIO,CAAC,GAAGL,KAAK,CAACM,MAAN,GAAe,CAAvB,EAA0BC,IAA9B,EAAoCF,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAC/CE,IAAAA,IAAI,GAAGP,KAAK,CAACK,CAAD,CAAZ;AACAH,IAAAA,KAAK,GAAGA,KAAK,GAAGK,IAAI,GAAG,GAAP,GAAaL,KAAhB,GAAwBK,IAArC;AACA,QAAGH,KAAK,CAACF,KAAD,CAAR,EACEC,SAAS,GAAGC,KAAK,CAACF,KAAD,CAAjB;AACH;;AAED,MAAGC,SAAS,IAAI,CAAC,CAAd,IAAmBT,eAAtB,EACES,SAAS,GAAG,CAAZ;AAEF,MAAGH,KAAK,CAACM,MAAN,IAAgBH,SAAhB,IAA6BA,SAAS,IAAI,CAAC,CAA9C,EACE,MAAM,IAAIK,KAAJ,CAAU,iBAAiBC,IAAI,CAACC,SAAL,CAAe;AAACV,IAAAA,KAAK,EAALA,KAAD;AAAQG,IAAAA,SAAS,EAATA,SAAR;AAAmBT,IAAAA,eAAe,EAAfA;AAAnB,GAAf,CAA3B,CAAN;AAEF,SAAQ;AACNiB,IAAAA,GAAG,EAAOX,KAAK,CAACY,KAAN,CAAY,CAACT,SAAb,EAAwBU,IAAxB,CAA6B,GAA7B,CADJ;AAENC,IAAAA,MAAM,EAAId,KAAK,CAACY,KAAN,CAAY,CAACT,SAAD,GAAa,CAAzB,EAA4BU,IAA5B,CAAiC,GAAjC,CAFJ;AAGNE,IAAAA,GAAG,EAAOf,KAAK,CAACY,KAAN,CAAY,CAAZ,EAAgB,CAACT,SAAD,GAAa,CAA7B,EAAiCU,IAAjC,CAAsC,GAAtC;AAHJ,GAAR;AAKD,CAhCD;;AAqCAG,MAAM,CAACC,OAAP,GAA4BhC,SAA5B;AACA+B,MAAM,CAACC,OAAP,CAAe5B,UAAf,GAA4BA,UAA5B","sourcesContent":["\"use strict\";\n\nvar url = require('url');\n\n\nvar parse_url = function(remote_url, options) {\n  if(typeof remote_url == \"string\")\n    remote_url = url.parse(remote_url);\n  return parse_host(remote_url.hostname, options);\n};\n\nvar tlds = null;\n\nvar parse_host = function(host, options) {\n  let allowPrivateTLD = options && options.allowPrivateTLD || false;\n  let allowUnknownTLD = options && options.allowUnknownTLD || false;\n\n  if(!tlds) {\n    tlds = require('./effective_tld_names.json');\n    tlds.combined = Object.assign({}, tlds.icann, tlds.private);\n  }\n\n  var parts = host.split(\".\");\n  var stack = \"\", tld_level = -1;\n\n  var roots = allowPrivateTLD ? tlds.combined : tlds.icann;\n\n  for(var i = parts.length - 1, part; i >= 0; i--) {\n    part = parts[i];\n    stack = stack ? part + \".\" + stack : part;\n    if(roots[stack])\n      tld_level = roots[stack];\n  }\n\n  if(tld_level == -1 && allowUnknownTLD)\n    tld_level = 1;\n\n  if(parts.length <= tld_level || tld_level == -1)\n    throw new Error(\"Invalid TLD \" + JSON.stringify({parts, tld_level, allowUnknownTLD}));\n\n  return  {\n    tld     : parts.slice(-tld_level).join('.'),\n    domain  : parts.slice(-tld_level - 1).join('.'),\n    sub     : parts.slice(0, (-tld_level - 1)).join('.'),\n  };\n};\n\n\n\n\nmodule.exports            = parse_url;\nmodule.exports.parse_host = parse_host;\n\n\n"]},"metadata":{},"sourceType":"script"}