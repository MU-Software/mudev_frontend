{"ast":null,"code":"// (c) MUsoftware 2022\n'use strict';\n\nimport _classPrivateFieldLooseBase from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { FrostError } from '../common/error';\nimport { APIResult } from './api_response';\nconst HTTP_METHOD = {\n  // We will support only these methods for now\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  PATCH: 'PATCH',\n  DELETE: 'DELETE'\n};\n\nfunction role2Object(roleStr) {\n  const result = {};\n  roleStr.split(\"&\").forEach(function (part) {\n    const item = part.split(\"=\");\n\n    if (item.length == 2) {\n      result[item[0]] = decodeURIComponent(item[1]);\n      if (result[item[0]] === 'true' || result[item[0]] === 'false') result[item[0]] = result[item[0]] === 'true' ? true : false;\n    }\n  });\n  return result;\n} // From https://stackoverflow.com/a/40031979\n\n\nfunction buf2hex(buffer) {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n} // Generate random safe string\n\n\nfunction generateRandomSecureToken(bytes) {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}\n\nlet frostApiInstance;\n\nvar _API_USED_METHOD = /*#__PURE__*/_classPrivateFieldLooseKey(\"API_USED_METHOD\");\n\nvar _BASE_URL = /*#__PURE__*/_classPrivateFieldLooseKey(\"BASE_URL\");\n\nvar _DEFAULT_FETCH_OPTION = /*#__PURE__*/_classPrivateFieldLooseKey(\"DEFAULT_FETCH_OPTION\");\n\nvar _csrfToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"csrfToken\");\n\nvar _accessToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"accessToken\");\n\nvar _refreshResult = /*#__PURE__*/_classPrivateFieldLooseKey(\"refreshResult\");\n\nvar _apiRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"apiRequest\");\n\nclass FrostAPI {\n  // We only uses these http methods now.\n  // Refresh Token will be saved on cookie storage,\n  // And all of these attributes must be private.\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\n  // Although these HTTP Response status code means error,\n  // each routes have to handle these codes differently.\n  // Default fetch options,\n  // we'll copy and modify this default option object on every request.\n  // Account related properties\n  constructor() {\n    Object.defineProperty(this, _apiRequest, {\n      value: _apiRequest2\n    });\n    Object.defineProperty(this, _BASE_URL, {\n      writable: true,\n      value: 'https://hyperion.mudev.cc/api/dev/'\n    });\n    Object.defineProperty(this, _DEFAULT_FETCH_OPTION, {\n      writable: true,\n      value: {\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'same-origin',\n        redirect: 'follow',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }\n    });\n    Object.defineProperty(this, _csrfToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _accessToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _refreshResult, {\n      writable: true,\n      value: null\n    });\n    if (frostApiInstance) return frostApiInstance;\n    _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n    frostApiInstance = this;\n  }\n\n  isSignedIn(checkNetwork = false) {\n    if (checkNetwork) return this.refreshAuthentications().then(_ => true, _ => false);\n    return Promise.resolve(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken] ? true : false);\n  }\n\n  signUp(id, email, password, nickname) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signup', false, {\n      id: id,\n      pw: password,\n      nick: nickname,\n      email: email\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      } // We need to generate error message from the subcode.\n\n\n      let errorMsg = '';\n\n      switch (apiResult.subCode) {\n        case 'user.already_used':\n          {\n            const duplicatedItems = apiResult.data.duplicate[0];\n            let duplicatedItemsKor = '';\n\n            switch (duplicatedItems) {\n              case 'email':\n                duplicatedItemsKor = '이메일은';\n                break;\n\n              case 'id':\n                duplicatedItemsKor = '아이디는';\n                break;\n\n              case 'nick':\n              case 'nickname':\n                duplicatedItemsKor = '별명은';\n                break;\n\n              case 'pw':\n              case 'password':\n                // WTF??? HOW??????\n                duplicatedItemsKor = '비밀번호는';\n                break;\n\n              default:\n                duplicatedItemsKor = '정보는';\n                break;\n            }\n\n            errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\n            break;\n          }\n\n        case 'request.body.bad_semantics':\n          {\n            errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\n            const badSemanticsReason = apiResult.data.bad_semantics[0];\n            console.log(badSemanticsReason);\n\n            if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'email')) {\n              errorMsg += '올바른 이메일 형식이 아니에요.';\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'pw')) {\n              const pwBadSemanticsReason = badSemanticsReason.pw;\n\n              switch (pwBadSemanticsReason) {\n                case 'TOO_SHORT':\n                  errorMsg += '비밀번호가 너무 짧아요,\\n';\n                  break;\n\n                case 'TOO_LONG':\n                  errorMsg += '1024자는 비밀번호로 쓰기에 너무 길지 않을까요?\\n';\n                  break;\n\n                case 'NEED_MORE_CHAR_TYPE':\n                  errorMsg += '비밀번호가 너무 단순해요,\\n';\n                  break;\n\n                case 'FORBIDDEN_CHAR':\n                  errorMsg += '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n';\n                  break;\n\n                default:\n                  errorMsg += '사용할 수 있는 비밀번호가 아니에요,\\n';\n                  break;\n              }\n\n              errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'id')) {\n              const idBadSemanticsReason = badSemanticsReason.id;\n\n              switch (idBadSemanticsReason) {\n                case 'TOO_SHORT':\n                  errorMsg += '아이디가 너무 짧아요,\\n';\n                  break;\n\n                case 'TOO_LONG':\n                  errorMsg += '아이디가 너무 길어요,\\n';\n                  break;\n\n                case 'FORBIDDEN_CHAR':\n                  errorMsg += '아이디에 사용할 수 없는 문자가 들어있어요,\\n';\n                  break;\n\n                default:\n                  errorMsg += '사용할 수 있는 아이디가 아니에요,\\n';\n                  break;\n              }\n\n              errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\n            } else {\n              errorMsg += '(정보가 올바르지 않습니다)';\n            }\n\n            break;\n          }\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signIn(idOrEmail, password) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signin', false, {\n      id: idOrEmail,\n      pw: password\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n    }).catch(reason => {\n      const apiResult = reason.apiResponse;\n      let errorMsg = '';\n      if (!apiResult) throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/signin=>UNHANDLED_EXCEPTION(${reason})`, -1); // If apiResponse is in FrostError obj, We can generate error message from the subcode.\n\n      switch (apiResult.subCode) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorMsg = '비밀번호가 맞지 않습니다,\\n비밀번호를 다시 입력해주세요.\\n';\n          errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\n          break;\n\n        case 'user.locked':\n          errorMsg = '계정이 잠겼습니다,\\n관리자에게 연락해주세요.\\n';\n          errorMsg += `(잠긴 사유: ${apiResult.data.reason})`;\n          break;\n\n        case 'user.deactivated':\n          errorMsg = '계정이 폐쇄되었습니다.,\\n관리자에게 연락해주세요';\n          errorMsg += `(폐쇄된 사유: ${apiResult.data.reason})`;\n          break;\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signOut() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signout', false, {\n      signout: true\n    }).then(() => {\n      // Actually, this action won't fail, except when the server is dead.\n      // Just reset the csrf token and access token.\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      return this;\n    });\n  }\n\n  refreshAuthentications() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/refresh', false).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n\n      throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  get userID() {\n    var _classPrivateFieldLoo;\n\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user.id;\n  }\n\n  get roles() {\n    if (!_classPrivateFieldLooseBase(this, _accessToken)[_accessToken]) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    const result = [];\n\n    try {\n      const token = JSON.parse(atob(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken].split('.')[1]));\n      JSON.parse(token.role).forEach(rolePart => {\n        if (rolePart === 'admin') return;\n        result.push(role2Object(rolePart));\n      });\n    } catch (e) {\n      /* tslint:disable:no-empty */\n    }\n\n    return result;\n  }\n\n  get(url, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.GET, url, accessTokenRequired);\n  }\n\n  post(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, url, accessTokenRequired, data);\n  }\n\n  put(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.PUT, url, accessTokenRequired, data);\n  }\n\n  patch(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.PATCH, url, accessTokenRequired, data);\n  }\n\n  delete(url, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.DELETE, url, accessTokenRequired);\n  }\n\n}\n\nfunction _apiRequest2(method = HTTP_METHOD.GET, url = '', accessTokenRequired = false, data = {}, isRetry = false) {\n  // check if requested method is allowed\n  if (_classPrivateFieldLooseBase(FrostAPI, _API_USED_METHOD)[_API_USED_METHOD].indexOf(method) == -1) {\n    throw 'NOT_ALLOWED_METHOD';\n  } // deep copy fetch option object\n\n\n  const reqFetchOption = JSON.parse(JSON.stringify(_classPrivateFieldLooseBase(this, _DEFAULT_FETCH_OPTION)[_DEFAULT_FETCH_OPTION]));\n  reqFetchOption.method = method; // only add body on POST/PATCH/PUT methods\n\n  if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1) reqFetchOption.body = JSON.stringify(data); // always send X-Csrf-Token. This won't be a security hole.\n\n  reqFetchOption.headers['X-Csrf-Token'] = _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken]; // add access token on header if accessTokenRequired is true\n\n  if (accessTokenRequired) {\n    reqFetchOption.headers['Authorization'] = 'Bearer ' + _classPrivateFieldLooseBase(this, _accessToken)[_accessToken];\n  }\n\n  if (url.includes('account') || url.includes('admin')) {\n    reqFetchOption.credentials = 'include';\n  }\n\n  return fetch(_classPrivateFieldLooseBase(this, _BASE_URL)[_BASE_URL] + url, reqFetchOption).then(response => {\n    if (!response) {\n      // How is this possible???\n      throw new FrostError('서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.', 'fetchResult 객체가 undefined 또는 null입니다.', -1);\n    } else if (200 <= response.status && response.status <= 399) {\n      // this returns response.json()\n      // SUCCESS\n      return response.json();\n    } else if (400 <= response.status && response.status <= 499) {\n      if (response.status === 401) {\n        // this \"possibly\" returns response.json()\n        // This code can be returned on both resource and account related routes,\n        // and we need to handle those separately.\n        //\n        // Possible subCodes: (== maybe one of resource related routes?)\n        // > token not given / token expired / token invalid\n        //    - We need to try refreshing access token and retry this.\n        //      If access token refresh fails, then raise errors.\n        // > wrong password / account locked / account deactivated (== maybe one of account related routes?)\n        //    - These will be raised when we signing in.\n        //      We need to throw a proper FrostError.\n        //\n        // If the error-occurred-request is related to resource routes,\n        // then we'll refresh access token and and retry the request.\n        // and if it fails, then we'll throw FrostError.\n        //\n        // If the error-occurred-request is related to account routes,\n        // then we need to parse subCode, so we'll handle this error on second stage.\n        if (!url.startsWith('account/')) {\n          if (!isRetry) return this.refreshAuthentications().then(api => _classPrivateFieldLooseBase(api, _apiRequest)[_apiRequest](method, url, accessTokenRequired, data, true));\n          throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`, response.status);\n        }\n\n        return response.json();\n      } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\n        // this \"possibly\" returns response.json().\n        // See RETURNABLE_ERROR for more details.\n        return response.json();\n      } else if (response.status === 403) {\n        // Requested action was forbidden\n        throw new FrostError('해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 405) {\n        // Method not permitted\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 415) {\n        // requested response content-type not supported\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 429) {\n        throw new FrostError('요청이 너무 빈번해요,\\n조금 천천히 진행해주세요.', `429 rate limit`, 429);\n      } else {\n        // unknown client-fault error\n        throw new FrostError('알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      }\n    } else {\n      // HTTP status code is more than 500(server error)\n      throw new FrostError('서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `statusCode가 ${response.status}입니다.`, response.status);\n    } // This is just for type-checking, response.status won't be less than 200, right?\n    // ...right? please... no......\n\n\n    return response.json();\n  }).then(response => {\n    const apiResult = new APIResult(response);\n\n    if (apiResult.code === 404 && apiResult.subCode === 'http.not_found') {\n      throw new FrostError('무엇을 할 지 모르는 요청이에요,\\n사이트 개발자에게 문의해주세요ㅠㅜ', 'http.not_found입니다.', apiResult.code, false);\n    } else if (apiResult.code === 401) {\n      // Possible subCodes:\n      // > token not given / token expired / token invalid\n      //   (== resource related routes, already handled)\n      //    - We need to try refreshing access token and retry this.\n      //      If access token refresh fails, then raise errors.\n      // > wrong password / account locked / account deactivated\n      //   (== account related routes, we need to handle this here.)\n      //    - These will be raised when we signing in.\n      //      We need to throw a proper FrostError.\n      throw new FrostError('로그인을 할 수 없어요.', '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`, apiResult.code, true, apiResult);\n    }\n\n    return apiResult;\n  }).catch(reason => {\n    // catch all exceptions and change it to FrostError\n    if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n      throw reason;\n    } else {\n      throw new FrostError('알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\n    }\n  });\n}\n\nObject.defineProperty(FrostAPI, _API_USED_METHOD, {\n  writable: true,\n  value: [HTTP_METHOD.GET, HTTP_METHOD.POST, HTTP_METHOD.PUT, HTTP_METHOD.PATCH, HTTP_METHOD.DELETE]\n});\nFrostAPI.RETURNABLE_ERROR = [// Actually, on 404, we need to filter http.not_found out only,\n// and any other responses must be returned, but we can get subcode after response.json().\n// And response.json() returns Promise<Any> and we cannot get subCode directly,\n// so we need to handle 404 on second stage.\n404, // http || resource not found\n409, // already used / information mismatch, conflict\n410, // resource gone\n412, // resource prediction failed\n422 // request.body.bad_semantics - email address validation failure, etc.\n];\nexport default FrostAPI;","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/network/api.ts"],"names":["FrostError","APIResult","HTTP_METHOD","GET","POST","PUT","PATCH","DELETE","role2Object","roleStr","result","split","forEach","part","item","length","decodeURIComponent","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","frostApiInstance","FrostAPI","constructor","mode","cache","credentials","redirect","referrerPolicy","headers","isSignedIn","checkNetwork","refreshAuthentications","then","_","Promise","resolve","signUp","id","email","password","nickname","pw","nick","apiResult","success","data","user","access_token","token","errorMsg","subCode","duplicatedItems","duplicate","duplicatedItemsKor","badSemanticsReason","bad_semantics","console","log","Object","prototype","hasOwnProperty","call","pwBadSemanticsReason","idBadSemanticsReason","code","catch","reason","signIn","idOrEmail","apiResponse","left_chance","signOut","signout","userID","roles","JSON","parse","atob","role","rolePart","push","e","get","url","accessTokenRequired","post","put","patch","delete","method","isRetry","indexOf","reqFetchOption","stringify","body","includes","fetch","response","status","json","startsWith","api","RETURNABLE_ERROR","name"],"mappings":"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","sourcesContent":["// (c) MUsoftware 2022\r\n'use strict';\r\n\r\nimport { FrostError } from '../common/error';\r\nimport { APIResult } from './api_response';\r\n\r\nconst HTTP_METHOD = {\r\n  // We will support only these methods for now\r\n  GET: 'GET',\r\n  POST: 'POST',\r\n  PUT: 'PUT',\r\n  PATCH: 'PATCH',\r\n  DELETE: 'DELETE',\r\n};\r\n\r\nfunction role2Object(roleStr: string) {\r\n  const result: { [roleName: string]: string | boolean } = {};\r\n\r\n  roleStr.split(\"&\").forEach(function (part) {\r\n    const item = part.split(\"=\");\r\n    if (item.length == 2) {\r\n      result[item[0]] = decodeURIComponent(item[1]);\r\n      if (result[item[0]] === 'true' || result[item[0]] === 'false')\r\n        result[item[0]] = (result[item[0]] === 'true') ? true : false;\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\nfunction buf2hex(buffer: ArrayBufferLike) {\r\n  return [...new Uint8Array(buffer)]\r\n    .map(x => x.toString(16).padStart(2, '0'))\r\n    .join('');\r\n}\r\n\r\n// Generate random safe string\r\nfunction generateRandomSecureToken(bytes: number) {\r\n  const randArray = new Uint32Array(bytes);\r\n  window.crypto.getRandomValues(randArray);\r\n  return buf2hex(randArray);\r\n}\r\n\r\nlet frostApiInstance: FrostAPI;\r\nclass FrostAPI {\r\n  // We only uses these http methods now.\r\n  static readonly #API_USED_METHOD = [\r\n    HTTP_METHOD.GET,\r\n    HTTP_METHOD.POST,\r\n    HTTP_METHOD.PUT,\r\n    HTTP_METHOD.PATCH,\r\n    HTTP_METHOD.DELETE,\r\n  ]\r\n  // Refresh Token will be saved on cookie storage,\r\n  // And all of these attributes must be private.\r\n  readonly #BASE_URL = 'https://hyperion.mudev.cc/api/dev/';\r\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\r\n  // Although these HTTP Response status code means error,\r\n  // each routes have to handle these codes differently.\r\n  static readonly RETURNABLE_ERROR = [\r\n    // Actually, on 404, we need to filter http.not_found out only,\r\n    // and any other responses must be returned, but we can get subcode after response.json().\r\n    // And response.json() returns Promise<Any> and we cannot get subCode directly,\r\n    // so we need to handle 404 on second stage.\r\n    404, // http || resource not found\r\n    409, // already used / information mismatch, conflict\r\n    410, // resource gone\r\n    412, // resource prediction failed\r\n    422, // request.body.bad_semantics - email address validation failure, etc.\r\n  ];\r\n  // Default fetch options,\r\n  // we'll copy and modify this default option object on every request.\r\n  readonly #DEFAULT_FETCH_OPTION = {\r\n    mode: 'cors',\r\n    cache: 'no-cache',\r\n    credentials: 'same-origin',\r\n    redirect: 'follow',\r\n    referrerPolicy: 'strict-origin-when-cross-origin',\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n\r\n  // Account related properties\r\n  #csrfToken: string = '';\r\n  #accessToken: string = '';\r\n  #refreshResult?: APIResult['data'] | null = null;\r\n\r\n  constructor() {\r\n    if (frostApiInstance) return frostApiInstance;\r\n\r\n    this.#csrfToken = generateRandomSecureToken(32);\r\n    frostApiInstance = this;\r\n  }\r\n\r\n  #apiRequest(method = HTTP_METHOD.GET, url = '', accessTokenRequired = false, data = {}, isRetry = false): Promise<APIResult> {\r\n    // check if requested method is allowed\r\n    if (FrostAPI.#API_USED_METHOD.indexOf(method) == -1) { throw 'NOT_ALLOWED_METHOD'; }\r\n\r\n    // deep copy fetch option object\r\n    const reqFetchOption = JSON.parse(JSON.stringify(this.#DEFAULT_FETCH_OPTION));\r\n    reqFetchOption.method = method;\r\n\r\n    // only add body on POST/PATCH/PUT methods\r\n    if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1)\r\n      reqFetchOption.body = JSON.stringify(data);\r\n\r\n    // always send X-Csrf-Token. This won't be a security hole.\r\n    reqFetchOption.headers['X-Csrf-Token'] = this.#csrfToken;\r\n    // add access token on header if accessTokenRequired is true\r\n    if (accessTokenRequired) {\r\n      reqFetchOption.headers['Authorization'] = 'Bearer ' + this.#accessToken;\r\n    }\r\n\r\n    if (url.includes('account') || url.includes('admin')) {\r\n      reqFetchOption.credentials = 'include';\r\n    }\r\n\r\n    return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n      if (!response) {\r\n        // How is this possible???\r\n        throw new FrostError(\r\n          '서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.',\r\n          'fetchResult 객체가 undefined 또는 null입니다.', -1);\r\n      } else if (200 <= response.status && response.status <= 399) {  // this returns response.json()\r\n        // SUCCESS\r\n        return response.json();\r\n      } else if (400 <= response.status && response.status <= 499) {\r\n        if (response.status === 401) {  // this \"possibly\" returns response.json()\r\n          // This code can be returned on both resource and account related routes,\r\n          // and we need to handle those separately.\r\n          //\r\n          // Possible subCodes: (== maybe one of resource related routes?)\r\n          // > token not given / token expired / token invalid\r\n          //    - We need to try refreshing access token and retry this.\r\n          //      If access token refresh fails, then raise errors.\r\n          // > wrong password / account locked / account deactivated (== maybe one of account related routes?)\r\n          //    - These will be raised when we signing in.\r\n          //      We need to throw a proper FrostError.\r\n          //\r\n          // If the error-occurred-request is related to resource routes,\r\n          // then we'll refresh access token and and retry the request.\r\n          // and if it fails, then we'll throw FrostError.\r\n          //\r\n          // If the error-occurred-request is related to account routes,\r\n          // then we need to parse subCode, so we'll handle this error on second stage.\r\n          if (!url.startsWith('account/')) {\r\n            if (!isRetry)\r\n              return this.refreshAuthentications().then((api) => api.#apiRequest(method, url, accessTokenRequired, data, true));\r\n            throw new FrostError(\r\n              '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n              '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n              response.status);\r\n          }\r\n\r\n          return response.json();\r\n        } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\r\n          // this \"possibly\" returns response.json().\r\n          // See RETURNABLE_ERROR for more details.\r\n          return response.json();\r\n        } else if (response.status === 403) {\r\n          // Requested action was forbidden\r\n          throw new FrostError(\r\n            '해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 405) {\r\n          // Method not permitted\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 415) {\r\n          // requested response content-type not supported\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 429) {\r\n          throw new FrostError(\r\n            '요청이 너무 빈번해요,\\n조금 천천히 진행해주세요.',\r\n            `429 rate limit`, 429);\r\n        } else {\r\n          // unknown client-fault error\r\n          throw new FrostError(\r\n            '알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        }\r\n      } else {  // HTTP status code is more than 500(server error)\r\n        throw new FrostError(\r\n          '서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `statusCode가 ${response.status}입니다.`, response.status);\r\n      }\r\n\r\n      // This is just for type-checking, response.status won't be less than 200, right?\r\n      // ...right? please... no......\r\n      return response.json();\r\n    }).then((response) => {\r\n      const apiResult = new APIResult(response);\r\n\r\n      if (apiResult.code === 404 && apiResult.subCode === 'http.not_found') {\r\n        throw new FrostError(\r\n          '무엇을 할 지 모르는 요청이에요,\\n사이트 개발자에게 문의해주세요ㅠㅜ',\r\n          'http.not_found입니다.', apiResult.code, false);\r\n      }\r\n      else if (apiResult.code === 401) {\r\n        // Possible subCodes:\r\n        // > token not given / token expired / token invalid\r\n        //   (== resource related routes, already handled)\r\n        //    - We need to try refreshing access token and retry this.\r\n        //      If access token refresh fails, then raise errors.\r\n        // > wrong password / account locked / account deactivated\r\n        //   (== account related routes, we need to handle this here.)\r\n        //    - These will be raised when we signing in.\r\n        //      We need to throw a proper FrostError.\r\n        throw new FrostError(\r\n          '로그인을 할 수 없어요.',\r\n          '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n          apiResult.code, true, apiResult);\r\n      }\r\n\r\n      return apiResult;\r\n    }).catch((reason) => {\r\n      // catch all exceptions and change it to FrostError\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  isSignedIn(checkNetwork = false) {\r\n    if (checkNetwork)\r\n      return this.refreshAuthentications().then((_) => true, (_) => false);\r\n\r\n    return Promise.resolve((this.#accessToken) ? true : false);\r\n  }\r\n\r\n  signUp(id: string, email: string, password: string, nickname: string) {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signup', false,\r\n      { id: id, pw: password, nick: nickname, email: email }).then((apiResult) => {\r\n        if (apiResult.success) {\r\n          this.#accessToken = apiResult.data.user.access_token.token;\r\n          this.#refreshResult = apiResult.data;\r\n          return this;\r\n        }\r\n\r\n        // We need to generate error message from the subcode.\r\n        let errorMsg = '';\r\n        switch (apiResult.subCode) {\r\n          case 'user.already_used': {\r\n            const duplicatedItems: string = apiResult.data.duplicate[0];\r\n            let duplicatedItemsKor = '';\r\n            switch (duplicatedItems) {\r\n              case 'email':\r\n                duplicatedItemsKor = '이메일은'; break;\r\n              case 'id':\r\n                duplicatedItemsKor = '아이디는'; break;\r\n              case 'nick':\r\n              case 'nickname':\r\n                duplicatedItemsKor = '별명은'; break;\r\n              case 'pw':\r\n              case 'password':\r\n                // WTF??? HOW??????\r\n                duplicatedItemsKor = '비밀번호는'; break;\r\n              default:\r\n                duplicatedItemsKor = '정보는'; break;\r\n            }\r\n            errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\r\n            break;\r\n          }\r\n          case 'request.body.bad_semantics': {\r\n            errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\r\n            const badSemanticsReason: Record<string, unknown> = apiResult.data.bad_semantics[0];\r\n            console.log(badSemanticsReason);\r\n            if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'email')) {\r\n              errorMsg += '올바른 이메일 형식이 아니에요.';\r\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'pw')) {\r\n              const pwBadSemanticsReason: string = badSemanticsReason.pw;\r\n              switch (pwBadSemanticsReason) {\r\n                case 'TOO_SHORT':\r\n                  errorMsg += '비밀번호가 너무 짧아요,\\n'; break;\r\n                case 'TOO_LONG':\r\n                  errorMsg += '1024자는 비밀번호로 쓰기에 너무 길지 않을까요?\\n'; break;\r\n                case 'NEED_MORE_CHAR_TYPE':\r\n                  errorMsg += '비밀번호가 너무 단순해요,\\n'; break;\r\n                case 'FORBIDDEN_CHAR':\r\n                  errorMsg += '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n'; break;\r\n                default:\r\n                  errorMsg += '사용할 수 있는 비밀번호가 아니에요,\\n'; break;\r\n              }\r\n              errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\r\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'id')) {\r\n              const idBadSemanticsReason: string = badSemanticsReason.id;\r\n              switch (idBadSemanticsReason) {\r\n                case 'TOO_SHORT':\r\n                  errorMsg += '아이디가 너무 짧아요,\\n'; break;\r\n                case 'TOO_LONG':\r\n                  errorMsg += '아이디가 너무 길어요,\\n'; break;\r\n                case 'FORBIDDEN_CHAR':\r\n                  errorMsg += '아이디에 사용할 수 없는 문자가 들어있어요,\\n'; break;\r\n                default:\r\n                  errorMsg += '사용할 수 있는 아이디가 아니에요,\\n'; break;\r\n              }\r\n              errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\r\n            } else {\r\n              errorMsg += '(정보가 올바르지 않습니다)';\r\n            }\r\n            break;\r\n          }\r\n          default:\r\n            errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n        }\r\n\r\n        throw new FrostError(\r\n          errorMsg,\r\n          `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n          apiResult.code);\r\n      }).catch((reason) => {\r\n        // as reason might be a 'FrostError',\r\n        // we can just reset auth data and throw it directly.\r\n        this.#accessToken = '';\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#refreshResult = null;\r\n        throw reason;\r\n      });\r\n  }\r\n\r\n  signIn(idOrEmail: string, password: string) {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signin', false,\r\n      { id: idOrEmail, pw: password }).then((apiResult: APIResult) => {\r\n        if (apiResult.success) {\r\n          this.#accessToken = apiResult.data.user.access_token.token;\r\n          this.#refreshResult = apiResult.data;\r\n          return this;\r\n        }\r\n      }).catch((reason: FrostError) => {\r\n        const apiResult: APIResult | undefined | null = reason.apiResponse;\r\n        let errorMsg = '';\r\n        if (!apiResult)\r\n          throw new FrostError(\r\n            '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n            `account/signin=>UNHANDLED_EXCEPTION(${reason})`, -1);\r\n\r\n        // If apiResponse is in FrostError obj, We can generate error message from the subcode.\r\n        switch (apiResult.subCode) {\r\n          case 'user.not_found':\r\n            errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n            break;\r\n          case 'user.wrong_password':\r\n            errorMsg = '비밀번호가 맞지 않습니다,\\n비밀번호를 다시 입력해주세요.\\n';\r\n            errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\r\n            break;\r\n          case 'user.locked':\r\n            errorMsg = '계정이 잠겼습니다,\\n관리자에게 연락해주세요.\\n';\r\n            errorMsg += `(잠긴 사유: ${apiResult.data.reason})`;\r\n            break;\r\n          case 'user.deactivated':\r\n            errorMsg = '계정이 폐쇄되었습니다.,\\n관리자에게 연락해주세요'\r\n            errorMsg += `(폐쇄된 사유: ${apiResult.data.reason})`;\r\n            break;\r\n          default:\r\n            errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n        }\r\n\r\n        throw new FrostError(\r\n          errorMsg,\r\n          `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n          apiResult.code);\r\n      }).catch((reason) => {\r\n        // as reason might be a 'FrostError',\r\n        // we can just reset auth data and throw it directly.\r\n        this.#accessToken = '';\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#refreshResult = null;\r\n        throw reason;\r\n      });\r\n  }\r\n\r\n  signOut() {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signout', false, { signout: true }).then(\r\n      () => {\r\n        // Actually, this action won't fail, except when the server is dead.\r\n        // Just reset the csrf token and access token.\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#accessToken = '';\r\n        this.#refreshResult = null;\r\n        return this;\r\n      });\r\n  }\r\n\r\n  refreshAuthentications() {\r\n    return this.#apiRequest(\r\n      HTTP_METHOD.POST,\r\n      'account/refresh',\r\n      false\r\n    ).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n      throw new FrostError(\r\n        '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n        `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#accessToken = '';\r\n      this.#csrfToken = generateRandomSecureToken(32);\r\n      this.#refreshResult = null;\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  get userID() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user.id;\r\n  }\r\n\r\n  get roles() {\r\n    if (!this.#accessToken)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    const result: Array<{ [roleName: string]: string | boolean; }> = [];\r\n    try {\r\n      const token = JSON.parse(atob(this.#accessToken.split('.')[1]));\r\n      JSON.parse(token.role).forEach((rolePart: string) => {\r\n        if (rolePart === 'admin') return;\r\n        result.push(role2Object(rolePart));\r\n      });\r\n    } catch (e) {\r\n      /* tslint:disable:no-empty */\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  get(url: string, accessTokenRequired = false) { return this.#apiRequest(HTTP_METHOD.GET, url, accessTokenRequired); }\r\n  post(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false) { return this.#apiRequest(HTTP_METHOD.POST, url, accessTokenRequired, data); }\r\n  put(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false) { return this.#apiRequest(HTTP_METHOD.PUT, url, accessTokenRequired, data); }\r\n  patch(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false) { return this.#apiRequest(HTTP_METHOD.PATCH, url, accessTokenRequired, data); }\r\n  delete(url: string, accessTokenRequired = false) { return this.#apiRequest(HTTP_METHOD.DELETE, url, accessTokenRequired); }\r\n}\r\n\r\nexport default FrostAPI;\r\n"]},"metadata":{},"sourceType":"module"}