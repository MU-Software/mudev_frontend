{"ast":null,"code":"// (c) MUsoftware 2022\n'use strict';\n\nimport _classPrivateFieldLooseBase from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { FrostError } from '../common/error';\nimport { APIResult } from './api_response';\nconst HTTP_METHOD = {\n  // We will support only these methods for now\n  HEAD: 'HEAD',\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  PATCH: 'PATCH',\n  DELETE: 'DELETE'\n};\n\nconst role2Object = roleStr => {\n  const result = {};\n  roleStr.split(\"&\").forEach(function (part) {\n    const item = part.split(\"=\");\n\n    if (item.length == 2) {\n      result[item[0]] = decodeURIComponent(item[1]);\n      if (result[item[0]] === 'true' || result[item[0]] === 'false') result[item[0]] = result[item[0]] === 'true' ? true : false;\n    }\n  });\n  return result;\n}; // From https://stackoverflow.com/a/40031979\n\n\nconst buf2hex = buffer => {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}; // Generate random safe string\n\n\nconst generateRandomSecureToken = bytes => {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n};\n\nlet frostApiInstance;\n\nvar _API_USED_METHOD = /*#__PURE__*/_classPrivateFieldLooseKey(\"API_USED_METHOD\");\n\nvar _BASE_URL = /*#__PURE__*/_classPrivateFieldLooseKey(\"BASE_URL\");\n\nvar _DEFAULT_FETCH_OPTION = /*#__PURE__*/_classPrivateFieldLooseKey(\"DEFAULT_FETCH_OPTION\");\n\nvar _csrfToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"csrfToken\");\n\nvar _accessToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"accessToken\");\n\nvar _accessTokenExpiresAt = /*#__PURE__*/_classPrivateFieldLooseKey(\"accessTokenExpiresAt\");\n\nvar _refreshResult = /*#__PURE__*/_classPrivateFieldLooseKey(\"refreshResult\");\n\nvar _clearAuthenticationInfo = /*#__PURE__*/_classPrivateFieldLooseKey(\"clearAuthenticationInfo\");\n\nvar _apiRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"apiRequest\");\n\nclass FrostAPI {\n  // We only uses these http methods now.\n  // Refresh Token will be saved on cookie storage,\n  // And all of these attributes must be private.\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\n  // Although these HTTP Response status code means error,\n  // each routes have to handle these codes differently.\n  // Default fetch options,\n  // we'll copy and modify this default option object on every request.\n  // Account related properties\n  constructor() {\n    Object.defineProperty(this, _apiRequest, {\n      value: _apiRequest2\n    });\n    Object.defineProperty(this, _clearAuthenticationInfo, {\n      value: _clearAuthenticationInfo2\n    });\n    Object.defineProperty(this, _BASE_URL, {\n      writable: true,\n      value: 'https://hyperion.mudev.cc/api/dev/'\n    });\n    Object.defineProperty(this, _DEFAULT_FETCH_OPTION, {\n      writable: true,\n      value: {\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'same-origin',\n        redirect: 'follow',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }\n    });\n    Object.defineProperty(this, _csrfToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _accessToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _accessTokenExpiresAt, {\n      writable: true,\n      value: new Date('Thu, 01 Jan 1970 00:00:00 GMT')\n    });\n    Object.defineProperty(this, _refreshResult, {\n      writable: true,\n      value: null\n    });\n    if (frostApiInstance) return frostApiInstance;\n    _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n    frostApiInstance = this;\n  }\n\n  isSignedIn(checkNetwork = false) {\n    if (checkNetwork) return this.refreshAuthentications().then(_ => true, _ => false);\n    return Promise.resolve(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken] ? true : false);\n  }\n\n  signUp(id, email, password, nickname) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/signup',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        id: id,\n        pw: password,\n        nick: nickname,\n        email: email\n      }\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _accessTokenExpiresAt)[_accessTokenExpiresAt] = new Date(apiResult.data.user.access_token.exp);\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      } // We need to generate error message from the subcode.\n\n\n      let errorMsg = '';\n      let errorFieldName = '';\n\n      switch (apiResult.subCode) {\n        case 'user.already_used':\n          {\n            const duplicatedItems = apiResult.data.duplicate[0];\n            let duplicatedItemsKor = '';\n\n            switch (duplicatedItems) {\n              case 'email':\n                errorFieldName = 'email';\n                duplicatedItemsKor = '이메일은';\n                break;\n\n              case 'id':\n                errorFieldName = 'id';\n                duplicatedItemsKor = '아이디는';\n                break;\n\n              case 'nick':\n              case 'nickname':\n                errorFieldName = 'nick';\n                duplicatedItemsKor = '별명은';\n                break;\n\n              case 'pw':\n              case 'password':\n                // WTF??? HOW??????\n                errorFieldName = 'pw';\n                duplicatedItemsKor = '비밀번호는';\n                break;\n\n              default:\n                duplicatedItemsKor = '정보는';\n                break;\n            }\n\n            errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\n            break;\n          }\n\n        case 'request.body.bad_semantics':\n          {\n            // errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\n            const badSemanticsReason = apiResult.data.bad_semantics[0];\n\n            if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'email')) {\n              errorFieldName = 'email';\n              errorMsg = '올바른 이메일 형식이 아니에요.';\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'pw')) {\n              const pwBadSemanticsReason = badSemanticsReason.pw;\n\n              switch (pwBadSemanticsReason) {\n                case 'TOO_SHORT':\n                  errorMsg = '비밀번호가 너무 짧아요,\\n';\n                  break;\n\n                case 'TOO_LONG':\n                  errorMsg = '1024자가 넘으면 비밀번호로 쓰기에 너무 길지 않을까요?\\n';\n                  break;\n\n                case 'NEED_MORE_CHAR_TYPE':\n                  errorMsg = '비밀번호가 너무 단순해요,\\n';\n                  break;\n\n                case 'FORBIDDEN_CHAR':\n                  errorMsg = '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n';\n                  break;\n\n                case 'PW_REUSED_ON_ID_EMAIL_NICK':\n                  errorMsg = '비밀번호가 이메일, 별칭, 또는 아이디와 같아요,\\n';\n                  break;\n\n                default:\n                  errorMsg = '사용할 수 있는 비밀번호가 아니에요,\\n';\n                  break;\n              }\n\n              errorFieldName = 'pw'; // errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'id')) {\n              const idBadSemanticsReason = badSemanticsReason.id;\n\n              switch (idBadSemanticsReason) {\n                case 'TOO_SHORT':\n                  errorMsg = '아이디가 너무 짧아요,\\n';\n                  break;\n\n                case 'TOO_LONG':\n                  errorMsg = '아이디가 너무 길어요,\\n';\n                  break;\n\n                case 'FORBIDDEN_CHAR':\n                  errorMsg = '아이디에 사용할 수 없는 문자가 들어있어요,\\n';\n                  break;\n\n                default:\n                  errorMsg = '사용할 수 있는 아이디가 아니에요,\\n';\n                  break;\n              }\n\n              errorFieldName = 'id';\n              errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\n            } else {\n              errorMsg += '정보가 올바르지 않아요,\\n새로고침 후 다시 시도해주세요.';\n            }\n\n            break;\n          }\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code, true, apiResult, errorFieldName, 'account/signup');\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _clearAuthenticationInfo)[_clearAuthenticationInfo]();\n\n      throw reason;\n    });\n  }\n\n  signIn(idOrEmail, password) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/signin',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        id: idOrEmail,\n        pw: password\n      }\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _accessTokenExpiresAt)[_accessTokenExpiresAt] = new Date(apiResult.data.user.access_token.exp);\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        this.userData;\n        return this;\n      }\n\n      let errorMsg = '';\n      let errorFieldName = '';\n      if (!apiResult) throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/signin=>!apiResult`, -1, true, undefined, undefined, 'account/signin'); // If apiResponse is in FrostError obj, We can generate error message from the subcode.\n\n      switch (apiResult.subCode) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorFieldName = 'pw';\n          errorMsg = '비밀번호가 맞지 않아요.\\n';\n          errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\n          break;\n\n        case 'user.locked':\n          errorMsg = '계정이 잠겼습니다, 관리자에게 연락해주세요.\\n';\n          errorMsg += `(잠긴 이유: ${apiResult.data.reason})`;\n          break;\n\n        case 'user.deactivated':\n          errorMsg = '계정이 폐쇄되었습니다, 관리자에게 연락해주세요.\\n';\n          errorMsg += `(폐쇄된 이유: ${apiResult.data.reason})`;\n          break;\n\n        case 'user.email_not_verified':\n          errorMsg = '아직 가입 시 적으신 메일 주소를 인증하지 않으셨어요,\\n메일함을 확인 후 메일 인증을 진행해주세요.';\n          break;\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후 새로고침을 한 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code, true, apiResult, errorFieldName, 'account/signin');\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _clearAuthenticationInfo)[_clearAuthenticationInfo]();\n\n      throw reason;\n    });\n  }\n\n  signOut() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/signout',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        signout: 'OK'\n      }\n    }).then(() => {\n      // Actually, this action won't fail, except when the server is dead.\n      // Just reset the csrf token and access token.\n      _classPrivateFieldLooseBase(this, _clearAuthenticationInfo)[_clearAuthenticationInfo]();\n\n      return this;\n    });\n  }\n\n  refreshAuthentications(forceRefresh = false) {\n    if (!forceRefresh && _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] && _classPrivateFieldLooseBase(this, _accessTokenExpiresAt)[_accessTokenExpiresAt] > new Date()) {\n      return Promise.resolve(this);\n    }\n\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/refresh',\n      accessTokenRequired: false\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _accessTokenExpiresAt)[_accessTokenExpiresAt] = new Date(apiResult.data.user.access_token.exp);\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n\n      throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400, true, apiResult, undefined, 'account/refresh');\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _clearAuthenticationInfo)[_clearAuthenticationInfo]();\n\n      throw reason;\n    });\n  }\n\n  changePassword(currentPw, newPw, newPwReType) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/change-password',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        original_password: currentPw,\n        new_password: newPw,\n        new_password_check: newPwReType\n      }\n    }).then(apiResult => {\n      if (apiResult.success) {\n        return this;\n      }\n\n      let errorMsg = '';\n      let errorFieldName = '';\n      if (!apiResult) throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/change-password=>!apiResult`, -1, true, undefined, undefined, 'account/change-password'); // If apiResponse is in FrostError obj, We can generate error message from the subcode.\n\n      switch (apiResult.subCode) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorFieldName = 'currentPw';\n          errorMsg = '현재 사용 중인 비밀번호가 맞지 않아요,\\n다시 시도해주세요.';\n          break;\n\n        case 'password.change_failed':\n          {\n            // apiResult.data.reason can be...\n            // RETYPE_MISMATCH, TOO_SHORT, TOO_LONG, NEED_MORE_CHAR_TYPE, FORBIDDEN_CHAR\n            const reasonType = apiResult.data.reason;\n\n            switch (reasonType) {\n              case 'RETYPE_MISMATCH':\n                errorFieldName = 'newPwReType';\n                errorMsg = '위에 입력하신 새 비밀번호와 일치하지 않아요,\\n새 비밀번호를 다시 입력해주세요.\\n';\n                break;\n\n              case 'TOO_SHORT':\n                errorFieldName = 'newPw';\n                errorMsg = '비밀번호가 너무 짧아요,\\n';\n                break;\n\n              case 'TOO_LONG':\n                errorFieldName = 'newPw';\n                errorMsg = '1024자가 넘으면 비밀번호로 쓰기에 너무 길지 않을까요?\\n';\n                break;\n\n              case 'NEED_MORE_CHAR_TYPE':\n                errorFieldName = 'newPw';\n                errorMsg = '비밀번호가 너무 단순해요,\\n';\n                break;\n\n              case 'FORBIDDEN_CHAR':\n                errorFieldName = 'newPw';\n                errorMsg = '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n';\n                break;\n\n              case 'PW_REUSED_ON_ID_EMAIL_NICK':\n                errorFieldName = 'newPw';\n                errorMsg = '비밀번호가 이메일, 별칭, 또는 아이디와 같아요,\\n';\n                break;\n\n              default:\n                errorFieldName = 'newPw';\n                errorMsg = '사용할 수 있는 비밀번호가 아니에요,\\n';\n                break;\n            }\n\n            break;\n          }\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n          break;\n      }\n\n      throw new FrostError(errorMsg, 'account/change-password=>\\n' + 'response.success=false\\n' + `code = ${apiResult.code}\\n` + `subCode=${apiResult.subCode}`, apiResult.code, true, apiResult, errorFieldName, 'account/change-password');\n    }).catch(reason => {\n      if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n        throw reason;\n      } else {\n        throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/change-password=>${reason}`, -1, true, undefined, undefined, 'account/change-password');\n      }\n    });\n  }\n\n  deactivate(email, pw) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/deactivate',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        email: email,\n        password: pw\n      }\n    }).then(apiResult => {\n      if (apiResult.success) {\n        // User will be signed out if account deactivation succeed.\n        _classPrivateFieldLooseBase(this, _clearAuthenticationInfo)[_clearAuthenticationInfo]();\n\n        return this;\n      }\n\n      let errorMsg = '';\n      let errorFieldName = '';\n      if (!apiResult) throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/deactivate=>!apiResult`, -1, true, undefined, undefined, 'account/deactivate'); // If apiResponse is in FrostError obj, We can generate error message from the subcode.\n\n      switch (apiResult.subCode) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorFieldName = 'currentPw';\n          errorMsg = '비밀번호가 맞지 않아요,\\n다시 시도해주세요.';\n          break;\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n          break;\n      }\n\n      throw new FrostError(errorMsg, 'account/deactivate=>\\n' + 'response.success=false\\n' + `code = ${apiResult.code}\\n` + `subCode=${apiResult.subCode}`, apiResult.code, true, apiResult, errorFieldName, 'account/deactivate');\n    }).catch(reason => {\n      if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n        throw reason;\n      } else {\n        throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/deactivate=>${reason}`, -1, true, undefined, undefined, 'account/deactivate');\n      }\n    });\n  }\n\n  get userID() {\n    var _classPrivateFieldLoo;\n\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user.id;\n  }\n\n  get userData() {\n    var _classPrivateFieldLoo2;\n\n    if (!((_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo2 === void 0 ? void 0 : _classPrivateFieldLoo2.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user;\n  }\n\n  get roles() {\n    if (!_classPrivateFieldLooseBase(this, _accessToken)[_accessToken]) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    const result = [];\n\n    try {\n      const token = JSON.parse(atob(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken].split('.')[1]));\n      JSON.parse(token.role).forEach(rolePart => {\n        if (rolePart === 'admin') return;\n        result.push(role2Object(rolePart));\n      });\n    } catch (e) {\n      /* tslint:disable:no-empty */\n    }\n\n    return result;\n  }\n\n  head(url, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.HEAD,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders\n    });\n  }\n\n  get(url, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.GET,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders\n    });\n  }\n\n  post(url, data = {}, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders,\n      data: data\n    });\n  }\n\n  put(url, data = {}, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.PUT,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders,\n      data: data\n    });\n  }\n\n  patch(url, data = {}, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.PATCH,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders,\n      data: data\n    });\n  }\n\n  delete(url, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.DELETE,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders\n    });\n  }\n\n}\n\nfunction _clearAuthenticationInfo2() {\n  _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n  _classPrivateFieldLooseBase(this, _accessTokenExpiresAt)[_accessTokenExpiresAt] = new Date('Thu, 01 Jan 1970 00:00:00 GMT');\n  _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n  _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n}\n\nfunction _apiRequest2({\n  method,\n  url,\n  accessTokenRequired,\n  additionalHeaders,\n  data,\n  isRetry\n} = {\n  method: HTTP_METHOD.GET,\n  url: '',\n  accessTokenRequired: false,\n  additionalHeaders: {},\n  data: {},\n  isRetry: false\n}) {\n  // check if requested method is allowed\n  if (_classPrivateFieldLooseBase(FrostAPI, _API_USED_METHOD)[_API_USED_METHOD].indexOf(method) == -1) {\n    throw 'NOT_ALLOWED_METHOD';\n  } // deep copy fetch option object\n\n\n  const reqFetchOption = JSON.parse(JSON.stringify(_classPrivateFieldLooseBase(this, _DEFAULT_FETCH_OPTION)[_DEFAULT_FETCH_OPTION]));\n  reqFetchOption.method = method; // only add body on POST/PATCH/PUT methods\n\n  if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1) reqFetchOption.body = JSON.stringify(data); // always send X-Csrf-Token. This won't be a security hole.\n\n  reqFetchOption.headers['X-Csrf-Token'] = _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken]; // add access token on header if accessTokenRequired is true\n\n  if (accessTokenRequired) {\n    reqFetchOption.headers['Authorization'] = 'Bearer ' + _classPrivateFieldLooseBase(this, _accessToken)[_accessToken];\n  }\n\n  if (url.includes('account') || url.includes('admin')) {\n    reqFetchOption.credentials = 'include';\n  }\n\n  if (additionalHeaders) for (const [key, value] of Object.entries(additionalHeaders)) reqFetchOption.headers[key] = value; // // We need to handle HEAD method separately as this method doesn't return any body.\n  // if (method === HTTP_METHOD.HEAD) {\n  //   return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\n  //   });\n  // }\n\n  return fetch(_classPrivateFieldLooseBase(this, _BASE_URL)[_BASE_URL] + url, reqFetchOption).then(response => {\n    if (!response) {\n      // How is this possible???\n      throw new FrostError('서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.', 'fetchResult 객체가 undefined 또는 null입니다.', -1, false, undefined, undefined, url);\n    } else if (200 <= response.status && response.status <= 399) {\n      // this returns response.json()\n      // SUCCESS\n      if (response.status === 204) {\n        // resource.deleted\n        // As 204 response means that resource is deleted and response does not include a response body,\n        // we need to make and return a fake response object.\n        return {\n          header: response.headers,\n          body: {\n            success: true,\n            code: 204,\n            subCode: 'resource.deleted',\n            message: 'Resource successfully deleted'\n          }\n        };\n      }\n\n      return response.json().then(responseBody => ({\n        header: response.headers,\n        body: responseBody\n      }));\n    } else if (400 <= response.status && response.status <= 499) {\n      if (response.status === 401) {\n        // this \"possibly\" returns response.json()\n        // This code can be returned on both resource and account related routes,\n        // and we need to handle those separately.\n        //\n        // Possible subCodes:\n        // > wrong password / account locked / account deactivated (== maybe one of account related routes?)\n        //    - These will be raised when we signing in.\n        //      We need to throw a proper FrostError.\n        // > token not given / token expired / token invalid\n        //    - We need to try refreshing access token and retry this.\n        //      If access token refresh fails, then raise errors.\n        //\n        // If the error-occurred-request is related to resource routes,\n        // then we'll refresh access token and and retry the request.\n        // and if it fails, then we'll throw FrostError.\n        //\n        // If the error-occurred-request is related to account routes,\n        // then we need to parse subCode, so we'll handle this error on second stage.\n        if (!url.startsWith('account/')) {\n          if (!isRetry) return this.refreshAuthentications(true).then(api => _classPrivateFieldLooseBase(api, _apiRequest)[_apiRequest]({\n            method: method,\n            url: url,\n            accessTokenRequired: accessTokenRequired,\n            additionalHeaders: additionalHeaders,\n            data: data,\n            isRetry: true\n          }));\n          throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`, response.status, false, undefined, undefined, url);\n        }\n\n        return response.json().then(responseBody => ({\n          header: response.headers,\n          body: responseBody\n        }));\n      } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\n        // this \"possibly\" returns response.json().\n        // See RETURNABLE_ERROR for more details.\n        return response.json().then(responseBody => ({\n          header: response.headers,\n          body: responseBody\n        }));\n      } else if (response.status === 403) {\n        // Requested action was forbidden\n        throw new FrostError('해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.', `${url} | ${method} | response.status === ${response.status}`, response.status, false, undefined, undefined, url);\n      } else if (response.status === 405) {\n        // Method not permitted\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status, false, undefined, undefined, url);\n      } else if (response.status === 415) {\n        // requested response content-type not supported\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status, false, undefined, undefined, url);\n      } else if (response.status === 429) {\n        throw new FrostError('요청이 너무 빈번해요,\\n조금 천천히 진행해주세요.', `429 rate limit`, 429, false, undefined, undefined, url);\n      } else {\n        // unknown client-fault error\n        throw new FrostError('알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.', `${url} | ${method} | response.status === ${response.status}`, response.status, false, undefined, undefined, url);\n      }\n    } else {\n      // HTTP status code is more than 500(server error)\n      throw new FrostError('서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `statusCode가 ${response.status}입니다.`, response.status, false, undefined, undefined, url);\n    } // This is just for type-checking, response.status won't be less than 200, right?\n    // ...right? please... no......\n\n\n    return response.json().then(responseBody => ({\n      header: response.headers,\n      body: responseBody\n    }));\n  }).then(response => {\n    if (response instanceof APIResult) return response;\n    const apiResult = new APIResult(response);\n\n    if (apiResult.code === 404 && apiResult.subCode === 'http.not_found') {\n      throw new FrostError('무엇을 할 지 모르는 요청이에요,\\n사이트 개발자에게 문의해주세요ㅠㅜ', 'http.not_found입니다.', apiResult.code, false, apiResult, undefined, url);\n    } // else if (apiResult.code === 401) {\n    //   // Possible subCodes:\n    //   // > token not given / token expired / token invalid\n    //   //   (== resource related routes, !!!ALREADY HANDLED!!!)\n    //   //    - We need to try refreshing access token and retry this.\n    //   //      If access token refresh fails, then raise errors.\n    //   // > wrong password / account locked / account deactivated\n    //   //   (== account related routes, we need to handle this here.)\n    //   //    - These will be raised when we signing in.\n    //   //      We need to throw a proper FrostError.\n    //   throw new FrostError(\n    //     '로그인을 할 수 없어요.',\n    //     '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\n    //     apiResult.code, true, apiResult, undefined, url);\n    // }\n\n\n    return apiResult;\n  }).catch(reason => {\n    // catch all exceptions and change it to FrostError\n    if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n      throw reason;\n    } else {\n      throw new FrostError('알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `on FrostAPI.#apiRequest -> reason = ${reason}`, -1, false, undefined, undefined, url);\n    }\n  });\n}\n\nObject.defineProperty(FrostAPI, _API_USED_METHOD, {\n  writable: true,\n  value: [// HTTP_METHOD.HEAD,  // NOT ALLOWED YET!!!\n  HTTP_METHOD.GET, HTTP_METHOD.POST, HTTP_METHOD.PUT, HTTP_METHOD.PATCH, HTTP_METHOD.DELETE]\n});\nFrostAPI.RETURNABLE_ERROR = [// Actually, on 404, we need to filter http.not_found out only,\n// and any other responses must be returned, but we can get subcode after response.json().\n// And response.json() returns Promise<Any> and we cannot get subCode directly,\n// so we need to handle 404 on second stage.\n404, // http || resource not found\n409, // already used / information mismatch, conflict\n410, // resource gone\n412, // resource prediction failed\n422 // request.body.bad_semantics - email address validation failure, etc.\n];\nexport default FrostAPI;","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/network/api.ts"],"names":["FrostError","APIResult","HTTP_METHOD","HEAD","GET","POST","PUT","PATCH","DELETE","role2Object","roleStr","result","split","forEach","part","item","length","decodeURIComponent","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","frostApiInstance","FrostAPI","constructor","mode","cache","credentials","redirect","referrerPolicy","headers","Date","isSignedIn","checkNetwork","refreshAuthentications","then","_","Promise","resolve","signUp","id","email","password","nickname","method","url","accessTokenRequired","additionalHeaders","data","pw","nick","apiResult","success","user","access_token","token","exp","errorMsg","errorFieldName","subCode","duplicatedItems","duplicate","duplicatedItemsKor","badSemanticsReason","bad_semantics","Object","prototype","hasOwnProperty","call","pwBadSemanticsReason","idBadSemanticsReason","code","catch","reason","signIn","idOrEmail","userData","undefined","left_chance","signOut","signout","forceRefresh","changePassword","currentPw","newPw","newPwReType","original_password","new_password","new_password_check","reasonType","name","deactivate","userID","roles","JSON","parse","atob","role","rolePart","push","e","head","get","post","put","patch","delete","isRetry","indexOf","reqFetchOption","stringify","body","includes","key","value","entries","fetch","response","status","header","message","json","responseBody","startsWith","api","RETURNABLE_ERROR"],"mappings":"AAAA;AACA;;;;AAEA,SAASA,UAAT,QAA2B,iBAA3B;AACA,SAASC,SAAT,QAA0B,gBAA1B;AAEA,MAAMC,WAAmC,GAAG;AAC1C;AACAC,EAAAA,IAAI,EAAE,MAFoC;AAG1CC,EAAAA,GAAG,EAAE,KAHqC;AAI1CC,EAAAA,IAAI,EAAE,MAJoC;AAK1CC,EAAAA,GAAG,EAAE,KALqC;AAM1CC,EAAAA,KAAK,EAAE,OANmC;AAO1CC,EAAAA,MAAM,EAAE;AAPkC,CAA5C;;AAUA,MAAMC,WAAW,GAAIC,OAAD,IAAqB;AACvC,QAAMC,MAAgD,GAAG,EAAzD;AAEAD,EAAAA,OAAO,CAACE,KAAR,CAAc,GAAd,EAAmBC,OAAnB,CAA2B,UAAUC,IAAV,EAAgB;AACzC,UAAMC,IAAI,GAAGD,IAAI,CAACF,KAAL,CAAW,GAAX,CAAb;;AACA,QAAIG,IAAI,CAACC,MAAL,IAAe,CAAnB,EAAsB;AACpBL,MAAAA,MAAM,CAACI,IAAI,CAAC,CAAD,CAAL,CAAN,GAAkBE,kBAAkB,CAACF,IAAI,CAAC,CAAD,CAAL,CAApC;AACA,UAAIJ,MAAM,CAACI,IAAI,CAAC,CAAD,CAAL,CAAN,KAAoB,MAApB,IAA8BJ,MAAM,CAACI,IAAI,CAAC,CAAD,CAAL,CAAN,KAAoB,OAAtD,EACEJ,MAAM,CAACI,IAAI,CAAC,CAAD,CAAL,CAAN,GAAmBJ,MAAM,CAACI,IAAI,CAAC,CAAD,CAAL,CAAN,KAAoB,MAArB,GAA+B,IAA/B,GAAsC,KAAxD;AACH;AACF,GAPD;AASA,SAAOJ,MAAP;AACD,CAbD,C,CAeA;;;AACA,MAAMO,OAAO,GAAIC,MAAD,IAA6B;AAC3C,SAAO,CAAC,GAAG,IAAIC,UAAJ,CAAeD,MAAf,CAAJ,EACJE,GADI,CACAC,CAAC,IAAIA,CAAC,CAACC,QAAF,CAAW,EAAX,EAAeC,QAAf,CAAwB,CAAxB,EAA2B,GAA3B,CADL,EAEJC,IAFI,CAEC,EAFD,CAAP;AAGD,CAJD,C,CAMA;;;AACA,MAAMC,yBAAyB,GAAIC,KAAD,IAAmB;AACnD,QAAMC,SAAS,GAAG,IAAIC,WAAJ,CAAgBF,KAAhB,CAAlB;AACAG,EAAAA,MAAM,CAACC,MAAP,CAAcC,eAAd,CAA8BJ,SAA9B;AACA,SAAOV,OAAO,CAACU,SAAD,CAAd;AACD,CAJD;;AAeA,IAAIK,gBAAJ;;;;;;;;;;;;;;;;;;;;AACA,MAAMC,QAAN,CAAe;AACb;AASA;AACA;AAEA;AACA;AACA;AAYA;AACA;AAYA;AAMAC,EAAAA,WAAW,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAlCO;AAkCP;AAAA;AAAA;AAAA,aAjBmB;AAC/BC,QAAAA,IAAI,EAAE,MADyB;AAE/BC,QAAAA,KAAK,EAAE,UAFwB;AAG/BC,QAAAA,WAAW,EAAE,aAHkB;AAI/BC,QAAAA,QAAQ,EAAE,QAJqB;AAK/BC,QAAAA,cAAc,EAAE,iCALe;AAM/BC,QAAAA,OAAO,EAAE;AACP,0BAAgB;AADT;AANsB;AAiBnB;AAAA;AAAA;AAAA,aALO;AAKP;AAAA;AAAA;AAAA,aAJS;AAIT;AAAA;AAAA;AAAA,aAHgB,IAAIC,IAAJ,CAAS,+BAAT;AAGhB;AAAA;AAAA;AAAA,aAF8B;AAE9B;AACZ,QAAIT,gBAAJ,EAAsB,OAAOA,gBAAP;AAEtB,gEAAkBP,yBAAyB,CAAC,EAAD,CAA3C;AACAO,IAAAA,gBAAgB,GAAG,IAAnB;AACD;;AA+LDU,EAAAA,UAAU,CAACC,YAAY,GAAG,KAAhB,EAAuB;AAC/B,QAAIA,YAAJ,EACE,OAAO,KAAKC,sBAAL,GAA8BC,IAA9B,CAAoCC,CAAD,IAAO,IAA1C,EAAiDA,CAAD,IAAO,KAAvD,CAAP;AAEF,WAAOC,OAAO,CAACC,OAAR,CAAgB,4BAAC,IAAD,gCAAsB,IAAtB,GAA6B,KAA7C,CAAP;AACD;;AAEDC,EAAAA,MAAM,CAACC,EAAD,EAAaC,KAAb,EAA4BC,QAA5B,EAA8CC,QAA9C,EAAgE;AACpE,WAAO,4DAAiB;AACtBC,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAE,gBAFiB;AAGtBC,MAAAA,mBAAmB,EAAE,KAHC;AAItBC,MAAAA,iBAAiB,EAAE,EAJG;AAICC,MAAAA,IAAI,EAAE;AAAER,QAAAA,EAAE,EAAEA,EAAN;AAAUS,QAAAA,EAAE,EAAEP,QAAd;AAAwBQ,QAAAA,IAAI,EAAEP,QAA9B;AAAwCF,QAAAA,KAAK,EAAEA;AAA/C;AAJP,KAAjB,EAKJN,IALI,CAKEgB,SAAD,IAAe;AACrB,UAAIA,SAAS,CAACC,OAAd,EAAuB;AACrB,wEAAoBD,SAAS,CAACH,IAAV,CAAeK,IAAf,CAAoBC,YAApB,CAAiCC,KAArD;AACA,0FAA6B,IAAIxB,IAAJ,CAASoB,SAAS,CAACH,IAAV,CAAeK,IAAf,CAAoBC,YAApB,CAAiCE,GAA1C,CAA7B;AACA,4EAAsBL,SAAS,CAACH,IAAhC;AACA,eAAO,IAAP;AACD,OANoB,CAQrB;;;AACA,UAAIS,QAAQ,GAAG,EAAf;AACA,UAAIC,cAAc,GAAG,EAArB;;AACA,cAAQP,SAAS,CAACQ,OAAlB;AACE,aAAK,mBAAL;AAA0B;AACxB,kBAAMC,eAAuB,GAAGT,SAAS,CAACH,IAAV,CAAea,SAAf,CAAyB,CAAzB,CAAhC;AACA,gBAAIC,kBAAkB,GAAG,EAAzB;;AACA,oBAAQF,eAAR;AACE,mBAAK,OAAL;AACEF,gBAAAA,cAAc,GAAG,OAAjB;AACAI,gBAAAA,kBAAkB,GAAG,MAArB;AACA;;AACF,mBAAK,IAAL;AACEJ,gBAAAA,cAAc,GAAG,IAAjB;AACAI,gBAAAA,kBAAkB,GAAG,MAArB;AACA;;AACF,mBAAK,MAAL;AACA,mBAAK,UAAL;AACEJ,gBAAAA,cAAc,GAAG,MAAjB;AACAI,gBAAAA,kBAAkB,GAAG,KAArB;AACA;;AACF,mBAAK,IAAL;AACA,mBAAK,UAAL;AACE;AACAJ,gBAAAA,cAAc,GAAG,IAAjB;AACAI,gBAAAA,kBAAkB,GAAG,OAArB;AACA;;AACF;AACEA,gBAAAA,kBAAkB,GAAG,KAArB;AACA;AAtBJ;;AAwBAL,YAAAA,QAAQ,GAAI,QAAOK,kBAAmB,sBAAtC;AACA;AACD;;AACD,aAAK,4BAAL;AAAmC;AACjC;AACA,kBAAMC,kBAA2C,GAAGZ,SAAS,CAACH,IAAV,CAAegB,aAAf,CAA6B,CAA7B,CAApD;;AACA,gBAAIC,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,kBAArC,EAAyD,OAAzD,CAAJ,EAAuE;AACrEL,cAAAA,cAAc,GAAG,OAAjB;AACAD,cAAAA,QAAQ,GAAG,mBAAX;AACD,aAHD,MAGO,IAAIQ,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,kBAArC,EAAyD,IAAzD,CAAJ,EAAoE;AACzE,oBAAMM,oBAA4B,GAAGN,kBAAkB,CAACd,EAAxD;;AACA,sBAAQoB,oBAAR;AACE,qBAAK,WAAL;AACEZ,kBAAAA,QAAQ,GAAG,iBAAX;AAA8B;;AAChC,qBAAK,UAAL;AACEA,kBAAAA,QAAQ,GAAG,oCAAX;AAAiD;;AACnD,qBAAK,qBAAL;AACEA,kBAAAA,QAAQ,GAAG,kBAAX;AAA+B;;AACjC,qBAAK,gBAAL;AACEA,kBAAAA,QAAQ,GAAG,gCAAX;AAA6C;;AAC/C,qBAAK,4BAAL;AACEA,kBAAAA,QAAQ,GAAG,+BAAX;AAA4C;;AAC9C;AACEA,kBAAAA,QAAQ,GAAG,wBAAX;AAAqC;AAZzC;;AAcAC,cAAAA,cAAc,GAAG,IAAjB,CAhByE,CAiBzE;AACD,aAlBM,MAkBA,IAAIO,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,kBAArC,EAAyD,IAAzD,CAAJ,EAAoE;AACzE,oBAAMO,oBAA4B,GAAGP,kBAAkB,CAACvB,EAAxD;;AACA,sBAAQ8B,oBAAR;AACE,qBAAK,WAAL;AACEb,kBAAAA,QAAQ,GAAG,gBAAX;AAA6B;;AAC/B,qBAAK,UAAL;AACEA,kBAAAA,QAAQ,GAAG,gBAAX;AAA6B;;AAC/B,qBAAK,gBAAL;AACEA,kBAAAA,QAAQ,GAAG,4BAAX;AAAyC;;AAC3C;AACEA,kBAAAA,QAAQ,GAAG,uBAAX;AAAoC;AARxC;;AAUAC,cAAAA,cAAc,GAAG,IAAjB;AACAD,cAAAA,QAAQ,IAAI,8BAAZ;AACD,aAdM,MAcA;AACLA,cAAAA,QAAQ,IAAI,kCAAZ;AACD;;AACD;AACD;;AACD;AACEA,UAAAA,QAAQ,GAAG,sCAAX;AA3EJ;;AA8EA,YAAM,IAAIpE,UAAJ,CACJoE,QADI,EAEH,kDAAiDN,SAAS,CAACoB,IAAK,aAAYpB,SAAS,CAACQ,OAAQ,EAF3F,EAGJR,SAAS,CAACoB,IAHN,EAGY,IAHZ,EAGkBpB,SAHlB,EAG6BO,cAH7B,EAG6C,gBAH7C,CAAN;AAID,KAlGM,EAkGJc,KAlGI,CAkGGC,MAAD,IAAY;AACnB;AACA;AACA;;AACA,YAAMA,MAAN;AACD,KAvGM,CAAP;AAwGD;;AAEDC,EAAAA,MAAM,CAACC,SAAD,EAAoBjC,QAApB,EAAsC;AAC1C,WAAO,4DAAiB;AACtBE,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAE,gBAFiB;AAGtBC,MAAAA,mBAAmB,EAAE,KAHC;AAItBC,MAAAA,iBAAiB,EAAE,EAJG;AAICC,MAAAA,IAAI,EAAE;AAAER,QAAAA,EAAE,EAAEmC,SAAN;AAAiB1B,QAAAA,EAAE,EAAEP;AAArB;AAJP,KAAjB,EAKJP,IALI,CAKEgB,SAAD,IAA0B;AAChC,UAAIA,SAAS,CAACC,OAAd,EAAuB;AACrB,wEAAoBD,SAAS,CAACH,IAAV,CAAeK,IAAf,CAAoBC,YAApB,CAAiCC,KAArD;AACA,0FAA6B,IAAIxB,IAAJ,CAASoB,SAAS,CAACH,IAAV,CAAeK,IAAf,CAAoBC,YAApB,CAAiCE,GAA1C,CAA7B;AACA,4EAAsBL,SAAS,CAACH,IAAhC;AACA,aAAK4B,QAAL;AACA,eAAO,IAAP;AACD;;AAED,UAAInB,QAAQ,GAAG,EAAf;AACA,UAAIC,cAAc,GAAG,EAArB;AACA,UAAI,CAACP,SAAL,EACE,MAAM,IAAI9D,UAAJ,CACJ,sCADI,EAEH,4BAFG,EAE0B,CAAC,CAF3B,EAE8B,IAF9B,EAEoCwF,SAFpC,EAE+CA,SAF/C,EAE0D,gBAF1D,CAAN,CAZ8B,CAgBhC;;AACA,cAAQ1B,SAAS,CAACQ,OAAlB;AACE,aAAK,gBAAL;AACEF,UAAAA,QAAQ,GAAG,oCAAX;AACA;;AACF,aAAK,qBAAL;AACEC,UAAAA,cAAc,GAAG,IAAjB;AACAD,UAAAA,QAAQ,GAAG,iBAAX;AACAA,UAAAA,QAAQ,IAAK,IAAGN,SAAS,CAACH,IAAV,CAAe8B,WAAY,qBAA3C;AACA;;AACF,aAAK,aAAL;AACErB,UAAAA,QAAQ,GAAG,4BAAX;AACAA,UAAAA,QAAQ,IAAK,WAAUN,SAAS,CAACH,IAAV,CAAeyB,MAAO,GAA7C;AACA;;AACF,aAAK,kBAAL;AACEhB,UAAAA,QAAQ,GAAG,8BAAX;AACAA,UAAAA,QAAQ,IAAK,YAAWN,SAAS,CAACH,IAAV,CAAeyB,MAAO,GAA9C;AACA;;AACF,aAAK,yBAAL;AACEhB,UAAAA,QAAQ,GAAG,0DAAX;AACA;;AACF;AACEA,UAAAA,QAAQ,GAAG,gDAAX;AArBJ;;AAwBA,YAAM,IAAIpE,UAAJ,CACJoE,QADI,EAEH,kDAAiDN,SAAS,CAACoB,IAAK,aAAYpB,SAAS,CAACQ,OAAQ,EAF3F,EAGJR,SAAS,CAACoB,IAHN,EAGY,IAHZ,EAGkBpB,SAHlB,EAG6BO,cAH7B,EAG6C,gBAH7C,CAAN;AAID,KAlDM,EAkDJc,KAlDI,CAkDGC,MAAD,IAAY;AACnB;AACA;AACA;;AACA,YAAMA,MAAN;AACD,KAvDM,CAAP;AAwDD;;AAEDM,EAAAA,OAAO,GAAG;AACR,WAAO,4DAAiB;AACtBnC,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAE,iBAFiB;AAGtBC,MAAAA,mBAAmB,EAAE,KAHC;AAItBC,MAAAA,iBAAiB,EAAE,EAJG;AAICC,MAAAA,IAAI,EAAE;AAAEgC,QAAAA,OAAO,EAAE;AAAX;AAJP,KAAjB,EAKJ7C,IALI,CAML,MAAM;AACJ;AACA;AACA;;AACA,aAAO,IAAP;AACD,KAXI,CAAP;AAYD;;AAEDD,EAAAA,sBAAsB,CAAC+C,YAAY,GAAG,KAAhB,EAAuB;AAC3C,QAAI,CAACA,YAAD,gCAAiB,IAAjB,iCAAsC,kFAA6B,IAAIlD,IAAJ,EAAvE,EAAmF;AACjF,aAAOM,OAAO,CAACC,OAAR,CAAgB,IAAhB,CAAP;AACD;;AAED,WAAO,4DAAiB;AACtBM,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAE,iBAFiB;AAGtBC,MAAAA,mBAAmB,EAAE;AAHC,KAAjB,EAKLX,IALK,CAKCgB,SAAD,IAAe;AACpB,UAAIA,SAAS,CAACC,OAAd,EAAuB;AACrB,wEAAoBD,SAAS,CAACH,IAAV,CAAeK,IAAf,CAAoBC,YAApB,CAAiCC,KAArD;AACA,0FAA6B,IAAIxB,IAAJ,CAASoB,SAAS,CAACH,IAAV,CAAeK,IAAf,CAAoBC,YAApB,CAAiCE,GAA1C,CAA7B;AACA,4EAAsBL,SAAS,CAACH,IAAhC;AACA,eAAO,IAAP;AACD;;AACD,YAAM,IAAI3D,UAAJ,CACJ,+BADI,EAEH,wDAAuD8D,SAAS,CAACoB,IAAK,EAFnE,EAGJ,GAHI,EAGC,IAHD,EAGOpB,SAHP,EAGkB0B,SAHlB,EAG6B,iBAH7B,CAAN;AAID,KAhBM,EAgBJL,KAhBI,CAgBGC,MAAD,IAAY;AACnB;AACA;AACA;;AACA,YAAMA,MAAN;AACD,KArBM,CAAP;AAsBD;;AAEDS,EAAAA,cAAc,CAACC,SAAD,EAAoBC,KAApB,EAAmCC,WAAnC,EAAwD;AACpE,WAAO,4DAAiB;AACtBzC,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAE,yBAFiB;AAGtBC,MAAAA,mBAAmB,EAAE,KAHC;AAItBC,MAAAA,iBAAiB,EAAE,EAJG;AAKtBC,MAAAA,IAAI,EAAE;AACJsC,QAAAA,iBAAiB,EAAEH,SADf;AAEJI,QAAAA,YAAY,EAAEH,KAFV;AAGJI,QAAAA,kBAAkB,EAAEH;AAHhB;AALgB,KAAjB,EAUJlD,IAVI,CAUEgB,SAAD,IAA0B;AAChC,UAAIA,SAAS,CAACC,OAAd,EAAuB;AACrB,eAAO,IAAP;AACD;;AAED,UAAIK,QAAQ,GAAG,EAAf;AACA,UAAIC,cAAc,GAAG,EAArB;AACA,UAAI,CAACP,SAAL,EACE,MAAM,IAAI9D,UAAJ,CACJ,sCADI,EAEH,qCAFG,EAEmC,CAAC,CAFpC,EAEuC,IAFvC,EAE6CwF,SAF7C,EAEwDA,SAFxD,EAGJ,yBAHI,CAAN,CAR8B,CAahC;;AACA,cAAQ1B,SAAS,CAACQ,OAAlB;AACE,aAAK,gBAAL;AACEF,UAAAA,QAAQ,GAAG,oCAAX;AACA;;AACF,aAAK,qBAAL;AACEC,UAAAA,cAAc,GAAG,WAAjB;AACAD,UAAAA,QAAQ,GAAG,oCAAX;AACA;;AACF,aAAK,wBAAL;AAA+B;AAC7B;AACA;AACA,kBAAMgC,UAAkB,GAAGtC,SAAS,CAACH,IAAV,CAAeyB,MAA1C;;AACA,oBAAQgB,UAAR;AACE,mBAAK,iBAAL;AACE/B,gBAAAA,cAAc,GAAG,aAAjB;AACAD,gBAAAA,QAAQ,GAAG,iDAAX;AACA;;AACF,mBAAK,WAAL;AACEC,gBAAAA,cAAc,GAAG,OAAjB;AACAD,gBAAAA,QAAQ,GAAG,iBAAX;AACA;;AACF,mBAAK,UAAL;AACEC,gBAAAA,cAAc,GAAG,OAAjB;AACAD,gBAAAA,QAAQ,GAAG,oCAAX;AACA;;AACF,mBAAK,qBAAL;AACEC,gBAAAA,cAAc,GAAG,OAAjB;AACAD,gBAAAA,QAAQ,GAAG,kBAAX;AACA;;AACF,mBAAK,gBAAL;AACEC,gBAAAA,cAAc,GAAG,OAAjB;AACAD,gBAAAA,QAAQ,GAAG,gCAAX;AACA;;AACF,mBAAK,4BAAL;AACEC,gBAAAA,cAAc,GAAG,OAAjB;AACAD,gBAAAA,QAAQ,GAAG,+BAAX;AACA;;AACF;AACEC,gBAAAA,cAAc,GAAG,OAAjB;AACAD,gBAAAA,QAAQ,GAAG,wBAAX;AACA;AA5BJ;;AA8BA;AACD;;AAED;AACEA,UAAAA,QAAQ,GAAG,sCAAX;AACA;AA/CJ;;AAkDA,YAAM,IAAIpE,UAAJ,CACJoE,QADI,EAEJ,gCACE,0BADF,GAEG,UAASN,SAAS,CAACoB,IAAK,IAF3B,GAGG,WAAUpB,SAAS,CAACQ,OAAQ,EAL3B,EAMJR,SAAS,CAACoB,IANN,EAMY,IANZ,EAMkBpB,SANlB,EAM6BO,cAN7B,EAOJ,yBAPI,CAAN;AAQD,KAlFM,EAkFJc,KAlFI,CAkFGC,MAAD,IAAY;AACnB,UAAI,OAAQA,MAAR,KAAoB,QAApB,IAAgCA,MAAM,CAACjD,WAAP,CAAmBkE,IAAnB,KAA4B,YAAhE,EAA8E;AAC5E,cAAMjB,MAAN;AACD,OAFD,MAEO;AACL,cAAM,IAAIpF,UAAJ,CACJ,sCADI,EAEH,4BAA2BoF,MAAO,EAF/B,EAEkC,CAAC,CAFnC,EAEsC,IAFtC,EAE4CI,SAF5C,EAEuDA,SAFvD,EAGJ,yBAHI,CAAN;AAID;AACF,KA3FM,CAAP;AA4FD;;AAEDc,EAAAA,UAAU,CAAClD,KAAD,EAAgBQ,EAAhB,EAA4B;AACpC,WAAO,4DAAiB;AACtBL,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAE,oBAFiB;AAGtBC,MAAAA,mBAAmB,EAAE,KAHC;AAItBC,MAAAA,iBAAiB,EAAE,EAJG;AAICC,MAAAA,IAAI,EAAE;AAAEP,QAAAA,KAAK,EAAEA,KAAT;AAAgBC,QAAAA,QAAQ,EAAEO;AAA1B;AAJP,KAAjB,EAKJd,IALI,CAKEgB,SAAD,IAA0B;AAChC,UAAIA,SAAS,CAACC,OAAd,EAAuB;AACrB;AACA;;AACA,eAAO,IAAP;AACD;;AAED,UAAIK,QAAQ,GAAG,EAAf;AACA,UAAIC,cAAc,GAAG,EAArB;AACA,UAAI,CAACP,SAAL,EACE,MAAM,IAAI9D,UAAJ,CACJ,sCADI,EAEH,gCAFG,EAE8B,CAAC,CAF/B,EAEkC,IAFlC,EAEwCwF,SAFxC,EAEmDA,SAFnD,EAGJ,oBAHI,CAAN,CAV8B,CAehC;;AACA,cAAQ1B,SAAS,CAACQ,OAAlB;AACE,aAAK,gBAAL;AACEF,UAAAA,QAAQ,GAAG,oCAAX;AACA;;AACF,aAAK,qBAAL;AACEC,UAAAA,cAAc,GAAG,WAAjB;AACAD,UAAAA,QAAQ,GAAG,2BAAX;AACA;;AACF;AACEA,UAAAA,QAAQ,GAAG,sCAAX;AACA;AAVJ;;AAaA,YAAM,IAAIpE,UAAJ,CACJoE,QADI,EAEJ,2BACE,0BADF,GAEG,UAASN,SAAS,CAACoB,IAAK,IAF3B,GAGG,WAAUpB,SAAS,CAACQ,OAAQ,EAL3B,EAMJR,SAAS,CAACoB,IANN,EAMY,IANZ,EAMkBpB,SANlB,EAM6BO,cAN7B,EAOJ,oBAPI,CAAN;AAQD,KA1CM,EA0CJc,KA1CI,CA0CGC,MAAD,IAAY;AACnB,UAAI,OAAQA,MAAR,KAAoB,QAApB,IAAgCA,MAAM,CAACjD,WAAP,CAAmBkE,IAAnB,KAA4B,YAAhE,EAA8E;AAC5E,cAAMjB,MAAN;AACD,OAFD,MAEO;AACL,cAAM,IAAIpF,UAAJ,CACJ,sCADI,EAEH,uBAAsBoF,MAAO,EAF1B,EAE6B,CAAC,CAF9B,EAEiC,IAFjC,EAEuCI,SAFvC,EAEkDA,SAFlD,EAGJ,oBAHI,CAAN;AAID;AACF,KAnDM,CAAP;AAoDD;;AAES,MAANe,MAAM,GAAG;AAAA;;AACX,QAAI,uDAAC,IAAD,2FAAC,sBAAqBvC,IAAtB,CAAJ,EACE;AACA,WAAKnB,sBAAL;AAEF,WAAO,kEAAoBmB,IAApB,CAAyBb,EAAhC;AACD;;AAEW,MAARoC,QAAQ,GAAG;AAAA;;AACb,QAAI,wDAAC,IAAD,4FAAC,uBAAqBvB,IAAtB,CAAJ,EACE;AACA,WAAKnB,sBAAL;AAEF,WAAO,kEAAoBmB,IAA3B;AACD;;AAEQ,MAALwC,KAAK,GAAG;AACV,QAAI,6BAAC,IAAD,6BAAJ,EACE;AACA,WAAK3D,sBAAL;AAEF,UAAMlC,MAAwD,GAAG,EAAjE;;AACA,QAAI;AACF,YAAMuD,KAAK,GAAGuC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAAC,8DAAkB/F,KAAlB,CAAwB,GAAxB,EAA6B,CAA7B,CAAD,CAAf,CAAd;AACA6F,MAAAA,IAAI,CAACC,KAAL,CAAWxC,KAAK,CAAC0C,IAAjB,EAAuB/F,OAAvB,CAAgCgG,QAAD,IAAsB;AACnD,YAAIA,QAAQ,KAAK,OAAjB,EAA0B;AAC1BlG,QAAAA,MAAM,CAACmG,IAAP,CAAYrG,WAAW,CAACoG,QAAD,CAAvB;AACD,OAHD;AAID,KAND,CAME,OAAOE,CAAP,EAAU;AACV;AACD;;AAED,WAAOpG,MAAP;AACD;;AAEDqG,EAAAA,IAAI,CAACxD,GAAD,EAAcC,mBAAmB,GAAG,KAApC,EAA2CC,iBAAiB,GAAG,EAA/D,EAAmE;AACrE,uCAAO,IAAP,4BAAwB;AACtBH,MAAAA,MAAM,EAAErD,WAAW,CAACC,IADE;AAEtBqD,MAAAA,GAAG,EAAEA,GAFiB;AAGtBC,MAAAA,mBAAmB,EAAEA,mBAHC;AAItBC,MAAAA,iBAAiB,EAAEA;AAJG,KAAxB;AAMD;;AACDuD,EAAAA,GAAG,CAACzD,GAAD,EAAcC,mBAAmB,GAAG,KAApC,EAA2CC,iBAAiB,GAAG,EAA/D,EAAmE;AACpE,uCAAO,IAAP,4BAAwB;AACtBH,MAAAA,MAAM,EAAErD,WAAW,CAACE,GADE;AAEtBoD,MAAAA,GAAG,EAAEA,GAFiB;AAGtBC,MAAAA,mBAAmB,EAAEA,mBAHC;AAItBC,MAAAA,iBAAiB,EAAEA;AAJG,KAAxB;AAMD;;AACDwD,EAAAA,IAAI,CAAC1D,GAAD,EAAcG,IAA6B,GAAG,EAA9C,EAAkDF,mBAAmB,GAAG,KAAxE,EAA+EC,iBAAiB,GAAG,EAAnG,EAAuG;AACzG,uCAAO,IAAP,4BAAwB;AACtBH,MAAAA,MAAM,EAAErD,WAAW,CAACG,IADE;AAEtBmD,MAAAA,GAAG,EAAEA,GAFiB;AAGtBC,MAAAA,mBAAmB,EAAEA,mBAHC;AAItBC,MAAAA,iBAAiB,EAAEA,iBAJG;AAKtBC,MAAAA,IAAI,EAAEA;AALgB,KAAxB;AAOD;;AACDwD,EAAAA,GAAG,CAAC3D,GAAD,EAAcG,IAA6B,GAAG,EAA9C,EAAkDF,mBAAmB,GAAG,KAAxE,EAA+EC,iBAAiB,GAAG,EAAnG,EAAuG;AACxG,uCAAO,IAAP,4BAAwB;AACtBH,MAAAA,MAAM,EAAErD,WAAW,CAACI,GADE;AAEtBkD,MAAAA,GAAG,EAAEA,GAFiB;AAGtBC,MAAAA,mBAAmB,EAAEA,mBAHC;AAItBC,MAAAA,iBAAiB,EAAEA,iBAJG;AAKtBC,MAAAA,IAAI,EAAEA;AALgB,KAAxB;AAOD;;AACDyD,EAAAA,KAAK,CAAC5D,GAAD,EAAcG,IAA6B,GAAG,EAA9C,EAAkDF,mBAAmB,GAAG,KAAxE,EAA+EC,iBAAiB,GAAG,EAAnG,EAAuG;AAC1G,uCAAO,IAAP,4BAAwB;AACtBH,MAAAA,MAAM,EAAErD,WAAW,CAACK,KADE;AAEtBiD,MAAAA,GAAG,EAAEA,GAFiB;AAGtBC,MAAAA,mBAAmB,EAAEA,mBAHC;AAItBC,MAAAA,iBAAiB,EAAEA,iBAJG;AAKtBC,MAAAA,IAAI,EAAEA;AALgB,KAAxB;AAOD;;AACD0D,EAAAA,MAAM,CAAC7D,GAAD,EAAcC,mBAAmB,GAAG,KAApC,EAA2CC,iBAAiB,GAAG,EAA/D,EAAmE;AACvE,uCAAO,IAAP,4BAAwB;AACtBH,MAAAA,MAAM,EAAErD,WAAW,CAACM,MADE;AAEtBgD,MAAAA,GAAG,EAAEA,GAFiB;AAGtBC,MAAAA,mBAAmB,EAAEA,mBAHC;AAItBC,MAAAA,iBAAiB,EAAEA;AAJG,KAAxB;AAMD;;AAtrBY;;qCAqDc;AACzB,kEAAoB,EAApB;AACA,oFAA6B,IAAIhB,IAAJ,CAAS,+BAAT,CAA7B;AACA,8DAAkBhB,yBAAyB,CAAC,EAAD,CAA3C;AACA,sEAAsB,IAAtB;AACD;;sBAEW;AAAE6B,EAAAA,MAAF;AAAUC,EAAAA,GAAV;AAAeC,EAAAA,mBAAf;AAAoCC,EAAAA,iBAApC;AAAuDC,EAAAA,IAAvD;AAA6D2D,EAAAA;AAA7D,IAAuG;AACjH/D,EAAAA,MAAM,EAAErD,WAAW,CAACE,GAD6F;AAEjHoD,EAAAA,GAAG,EAAE,EAF4G;AAGjHC,EAAAA,mBAAmB,EAAE,KAH4F;AAIjHC,EAAAA,iBAAiB,EAAE,EAJ8F;AAKjHC,EAAAA,IAAI,EAAE,EAL2G;AAMjH2D,EAAAA,OAAO,EAAE;AANwG,C,EAO5F;AACrB;AACA,MAAI,4BAAApF,QAAQ,mBAAR,mBAA0BqF,OAA1B,CAAkChE,MAAlC,KAA6C,CAAC,CAAlD,EAAqD;AAAE,UAAM,oBAAN;AAA6B,GAF/D,CAIrB;;;AACA,QAAMiE,cAAc,GAAGf,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACgB,SAAL,6BAAe,IAAf,gDAAX,CAAvB;AACAD,EAAAA,cAAc,CAACjE,MAAf,GAAwBA,MAAxB,CANqB,CAQrB;;AACA,MAAI,CAACrD,WAAW,CAACG,IAAb,EAAmBH,WAAW,CAACK,KAA/B,EAAsCL,WAAW,CAACI,GAAlD,EAAuDiH,OAAvD,CAA+DhE,MAA/D,IAAyE,CAAC,CAA9E,EACEiE,cAAc,CAACE,IAAf,GAAsBjB,IAAI,CAACgB,SAAL,CAAe9D,IAAf,CAAtB,CAVmB,CAYrB;;AACA6D,EAAAA,cAAc,CAAC/E,OAAf,CAAuB,cAAvB,gCAAyC,IAAzC,0BAbqB,CAcrB;;AACA,MAAIgB,mBAAJ,EAAyB;AACvB+D,IAAAA,cAAc,CAAC/E,OAAf,CAAuB,eAAvB,IAA0C,wCAAY,IAAZ,6BAA1C;AACD;;AAED,MAAIe,GAAG,CAACmE,QAAJ,CAAa,SAAb,KAA2BnE,GAAG,CAACmE,QAAJ,CAAa,OAAb,CAA/B,EAAsD;AACpDH,IAAAA,cAAc,CAAClF,WAAf,GAA6B,SAA7B;AACD;;AAED,MAAIoB,iBAAJ,EACE,KAAK,MAAM,CAACkE,GAAD,EAAMC,KAAN,CAAX,IAA2BjD,MAAM,CAACkD,OAAP,CAAepE,iBAAf,CAA3B,EACE8D,cAAc,CAAC/E,OAAf,CAAuBmF,GAAvB,IAA8BC,KAA9B,CAzBiB,CA2BrB;AACA;AACA;AAEA;AACA;;AAEA,SAAOE,KAAK,CAAC,0DAAiBvE,GAAlB,EAAuBgE,cAAvB,CAAL,CAA4C1E,IAA5C,CAAkDkF,QAAD,IAAc;AACpE,QAAI,CAACA,QAAL,EAAe;AACb;AACA,YAAM,IAAIhI,UAAJ,CACJ,gCADI,EAEJ,uCAFI,EAEqC,CAAC,CAFtC,EAEyC,KAFzC,EAEgDwF,SAFhD,EAE2DA,SAF3D,EAEsEhC,GAFtE,CAAN;AAGD,KALD,MAKO,IAAI,OAAOwE,QAAQ,CAACC,MAAhB,IAA0BD,QAAQ,CAACC,MAAT,IAAmB,GAAjD,EAAsD;AAAG;AAC9D;AAEA,UAAID,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AAAE;AAC7B;AACA;AACA,eAAO;AACLC,UAAAA,MAAM,EAAEF,QAAQ,CAACvF,OADZ;AAELiF,UAAAA,IAAI,EAAE;AACJ3D,YAAAA,OAAO,EAAE,IADL;AAEJmB,YAAAA,IAAI,EAAE,GAFF;AAGJZ,YAAAA,OAAO,EAAE,kBAHL;AAIJ6D,YAAAA,OAAO,EAAE;AAJL;AAFD,SAAP;AASD;;AAED,aAAOH,QAAQ,CAACI,IAAT,GAAgBtF,IAAhB,CAAsBuF,YAAD,KAAmB;AAAEH,QAAAA,MAAM,EAAEF,QAAQ,CAACvF,OAAnB;AAA4BiF,QAAAA,IAAI,EAAEW;AAAlC,OAAnB,CAArB,CAAP;AACD,KAlBM,MAkBA,IAAI,OAAOL,QAAQ,CAACC,MAAhB,IAA0BD,QAAQ,CAACC,MAAT,IAAmB,GAAjD,EAAsD;AAC3D,UAAID,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,CAACzE,GAAG,CAAC8E,UAAJ,CAAe,UAAf,CAAL,EAAiC;AAC/B,cAAI,CAAChB,OAAL,EACE,OAAO,KAAKzE,sBAAL,CAA4B,IAA5B,EAAkCC,IAAlC,CAAwCyF,GAAD,gCAASA,GAAT,4BAAyB;AACrEhF,YAAAA,MAAM,EAAEA,MAD6D;AAErEC,YAAAA,GAAG,EAAEA,GAFgE;AAGrEC,YAAAA,mBAAmB,EAAEA,mBAHgD;AAIrEC,YAAAA,iBAAiB,EAAEA,iBAJkD;AAI/BC,YAAAA,IAAI,EAAEA,IAJyB;AAKrE2D,YAAAA,OAAO,EAAE;AAL4D,WAAzB,CAAvC,CAAP;AAOF,gBAAM,IAAItH,UAAJ,CACJ,+BADI,EAEJ,sCAAuC,GAAEwD,GAAI,MAAKD,MAAO,0BAAyByE,QAAQ,CAACC,MAAO,EAF9F,EAGJD,QAAQ,CAACC,MAHL,EAGa,KAHb,EAGoBzC,SAHpB,EAG+BA,SAH/B,EAG0ChC,GAH1C,CAAN;AAID;;AAED,eAAOwE,QAAQ,CAACI,IAAT,GAAgBtF,IAAhB,CAAsBuF,YAAD,KAAmB;AAAEH,UAAAA,MAAM,EAAEF,QAAQ,CAACvF,OAAnB;AAA4BiF,UAAAA,IAAI,EAAEW;AAAlC,SAAnB,CAArB,CAAP;AACD,OAlCD,MAkCO,IAAInG,QAAQ,CAACsG,gBAAT,CAA0Bb,QAA1B,CAAmCK,QAAQ,CAACC,MAA5C,CAAJ,EAAyD;AAC9D;AACA;AACA,eAAOD,QAAQ,CAACI,IAAT,GAAgBtF,IAAhB,CAAsBuF,YAAD,KAAmB;AAAEH,UAAAA,MAAM,EAAEF,QAAQ,CAACvF,OAAnB;AAA4BiF,UAAAA,IAAI,EAAEW;AAAlC,SAAnB,CAArB,CAAP;AACD,OAJM,MAIA,IAAIL,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AAClC;AACA,cAAM,IAAIjI,UAAJ,CACJ,0DADI,EAEH,GAAEwD,GAAI,MAAKD,MAAO,0BAAyByE,QAAQ,CAACC,MAAO,EAFxD,EAE2DD,QAAQ,CAACC,MAFpE,EAGJ,KAHI,EAGGzC,SAHH,EAGcA,SAHd,EAGyBhC,GAHzB,CAAN;AAID,OANM,MAMA,IAAIwE,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AAClC;AACA,cAAM,IAAIjI,UAAJ,CACJ,yDADI,EAEH,GAAEwD,GAAI,MAAKD,MAAO,0BAAyByE,QAAQ,CAACC,MAAO,EAFxD,EAE2DD,QAAQ,CAACC,MAFpE,EAGJ,KAHI,EAGGzC,SAHH,EAGcA,SAHd,EAGyBhC,GAHzB,CAAN;AAID,OANM,MAMA,IAAIwE,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AAClC;AACA,cAAM,IAAIjI,UAAJ,CACJ,yDADI,EAEH,GAAEwD,GAAI,MAAKD,MAAO,0BAAyByE,QAAQ,CAACC,MAAO,EAFxD,EAE2DD,QAAQ,CAACC,MAFpE,EAGJ,KAHI,EAGGzC,SAHH,EAGcA,SAHd,EAGyBhC,GAHzB,CAAN;AAID,OANM,MAMA,IAAIwE,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AAClC,cAAM,IAAIjI,UAAJ,CACJ,8BADI,EAEH,gBAFG,EAEc,GAFd,EAEmB,KAFnB,EAE0BwF,SAF1B,EAEqCA,SAFrC,EAEgDhC,GAFhD,CAAN;AAGD,OAJM,MAIA;AACL;AACA,cAAM,IAAIxD,UAAJ,CACJ,uCADI,EAEH,GAAEwD,GAAI,MAAKD,MAAO,0BAAyByE,QAAQ,CAACC,MAAO,EAFxD,EAE2DD,QAAQ,CAACC,MAFpE,EAGJ,KAHI,EAGGzC,SAHH,EAGcA,SAHd,EAGyBhC,GAHzB,CAAN;AAID;AACF,KApEM,MAoEA;AAAG;AACR,YAAM,IAAIxD,UAAJ,CACJ,qCADI,EAEH,eAAcgI,QAAQ,CAACC,MAAO,MAF3B,EAEkCD,QAAQ,CAACC,MAF3C,EAGJ,KAHI,EAGGzC,SAHH,EAGcA,SAHd,EAGyBhC,GAHzB,CAAN;AAID,KAjGmE,CAmGpE;AACA;;;AACA,WAAOwE,QAAQ,CAACI,IAAT,GAAgBtF,IAAhB,CAAsBuF,YAAD,KAAmB;AAAEH,MAAAA,MAAM,EAAEF,QAAQ,CAACvF,OAAnB;AAA4BiF,MAAAA,IAAI,EAAEW;AAAlC,KAAnB,CAArB,CAAP;AACD,GAtGM,EAsGJvF,IAtGI,CAsGEkF,QAAD,IAA8F;AACpG,QAAIA,QAAQ,YAAY/H,SAAxB,EACE,OAAO+H,QAAP;AAEF,UAAMlE,SAAS,GAAG,IAAI7D,SAAJ,CAAc+H,QAAd,CAAlB;;AACA,QAAIlE,SAAS,CAACoB,IAAV,KAAmB,GAAnB,IAA0BpB,SAAS,CAACQ,OAAV,KAAsB,gBAApD,EAAsE;AACpE,YAAM,IAAItE,UAAJ,CACJ,wCADI,EAEJ,oBAFI,EAEkB8D,SAAS,CAACoB,IAF5B,EAEkC,KAFlC,EAEyCpB,SAFzC,EAEoD0B,SAFpD,EAE+DhC,GAF/D,CAAN;AAGD,KATmG,CAUpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,WAAOM,SAAP;AACD,GAjIM,EAiIJqB,KAjII,CAiIGC,MAAD,IAAY;AACnB;AACA,QAAI,OAAQA,MAAR,KAAoB,QAApB,IAAgCA,MAAM,CAACjD,WAAP,CAAmBkE,IAAnB,KAA4B,YAAhE,EAA8E;AAC5E,YAAMjB,MAAN;AACD,KAFD,MAEO;AACL,YAAM,IAAIpF,UAAJ,CACJ,qCADI,EAEH,uCAAsCoF,MAAO,EAF1C,EAE6C,CAAC,CAF9C,EAEiD,KAFjD,EAEwDI,SAFxD,EAEmEA,SAFnE,EAE8EhC,GAF9E,CAAN;AAGD;AACF,GA1IM,CAAP;AA2ID;;sBAhPGtB,Q;;SAE+B,CACjC;AACAhC,EAAAA,WAAW,CAACE,GAFqB,EAGjCF,WAAW,CAACG,IAHqB,EAIjCH,WAAW,CAACI,GAJqB,EAKjCJ,WAAW,CAACK,KALqB,EAMjCL,WAAW,CAACM,MANqB;;AAF/B0B,Q,CAgBYsG,gB,GAAmB,CACjC;AACA;AACA;AACA;AACA,GALiC,EAK5B;AACL,GANiC,EAM5B;AACL,GAPiC,EAO5B;AACL,GARiC,EAQ5B;AACL,GATiC,CAS5B;AAT4B,C;AAyqBrC,eAAetG,QAAf","sourcesContent":["// (c) MUsoftware 2022\r\n'use strict';\r\n\r\nimport { FrostError } from '../common/error';\r\nimport { APIResult } from './api_response';\r\n\r\nconst HTTP_METHOD: Record<string, string> = {\r\n  // We will support only these methods for now\r\n  HEAD: 'HEAD',\r\n  GET: 'GET',\r\n  POST: 'POST',\r\n  PUT: 'PUT',\r\n  PATCH: 'PATCH',\r\n  DELETE: 'DELETE',\r\n};\r\n\r\nconst role2Object = (roleStr: string) => {\r\n  const result: { [roleName: string]: string | boolean } = {};\r\n\r\n  roleStr.split(\"&\").forEach(function (part) {\r\n    const item = part.split(\"=\");\r\n    if (item.length == 2) {\r\n      result[item[0]] = decodeURIComponent(item[1]);\r\n      if (result[item[0]] === 'true' || result[item[0]] === 'false')\r\n        result[item[0]] = (result[item[0]] === 'true') ? true : false;\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\nconst buf2hex = (buffer: ArrayBufferLike) => {\r\n  return [...new Uint8Array(buffer)]\r\n    .map(x => x.toString(16).padStart(2, '0'))\r\n    .join('');\r\n}\r\n\r\n// Generate random safe string\r\nconst generateRandomSecureToken = (bytes: number) => {\r\n  const randArray = new Uint32Array(bytes);\r\n  window.crypto.getRandomValues(randArray);\r\n  return buf2hex(randArray);\r\n}\r\n\r\ninterface FrostAPIRequestArgumentTypes {\r\n  method: 'HEAD' | 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\r\n  url: string;\r\n  accessTokenRequired: boolean;\r\n  additionalHeaders: Record<string, unknown>;\r\n  data: Record<string, unknown>;\r\n  isRetry: boolean;\r\n}\r\n\r\nlet frostApiInstance: FrostAPI;\r\nclass FrostAPI {\r\n  // We only uses these http methods now.\r\n  static readonly #API_USED_METHOD = [\r\n    // HTTP_METHOD.HEAD,  // NOT ALLOWED YET!!!\r\n    HTTP_METHOD.GET,\r\n    HTTP_METHOD.POST,\r\n    HTTP_METHOD.PUT,\r\n    HTTP_METHOD.PATCH,\r\n    HTTP_METHOD.DELETE,\r\n  ]\r\n  // Refresh Token will be saved on cookie storage,\r\n  // And all of these attributes must be private.\r\n  readonly #BASE_URL = 'https://hyperion.mudev.cc/api/dev/';\r\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\r\n  // Although these HTTP Response status code means error,\r\n  // each routes have to handle these codes differently.\r\n  static readonly RETURNABLE_ERROR = [\r\n    // Actually, on 404, we need to filter http.not_found out only,\r\n    // and any other responses must be returned, but we can get subcode after response.json().\r\n    // And response.json() returns Promise<Any> and we cannot get subCode directly,\r\n    // so we need to handle 404 on second stage.\r\n    404, // http || resource not found\r\n    409, // already used / information mismatch, conflict\r\n    410, // resource gone\r\n    412, // resource prediction failed\r\n    422, // request.body.bad_semantics - email address validation failure, etc.\r\n  ];\r\n  // Default fetch options,\r\n  // we'll copy and modify this default option object on every request.\r\n  readonly #DEFAULT_FETCH_OPTION = {\r\n    mode: 'cors',\r\n    cache: 'no-cache',\r\n    credentials: 'same-origin',\r\n    redirect: 'follow',\r\n    referrerPolicy: 'strict-origin-when-cross-origin',\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n\r\n  // Account related properties\r\n  #csrfToken: string = '';\r\n  #accessToken: string = '';\r\n  #accessTokenExpiresAt: Date = new Date('Thu, 01 Jan 1970 00:00:00 GMT');\r\n  #refreshResult?: APIResult['data'] | null = null;\r\n\r\n  constructor() {\r\n    if (frostApiInstance) return frostApiInstance;\r\n\r\n    this.#csrfToken = generateRandomSecureToken(32);\r\n    frostApiInstance = this;\r\n  }\r\n\r\n  #clearAuthenticationInfo() {\r\n    this.#accessToken = '';\r\n    this.#accessTokenExpiresAt = new Date('Thu, 01 Jan 1970 00:00:00 GMT');\r\n    this.#csrfToken = generateRandomSecureToken(32);\r\n    this.#refreshResult = null;\r\n  }\r\n\r\n  #apiRequest({ method, url, accessTokenRequired, additionalHeaders, data, isRetry }: FrostAPIRequestArgumentTypes = {\r\n    method: HTTP_METHOD.GET,\r\n    url: '',\r\n    accessTokenRequired: false,\r\n    additionalHeaders: {},\r\n    data: {},\r\n    isRetry: false,\r\n  }): Promise<APIResult> {\r\n    // check if requested method is allowed\r\n    if (FrostAPI.#API_USED_METHOD.indexOf(method) == -1) { throw 'NOT_ALLOWED_METHOD'; }\r\n\r\n    // deep copy fetch option object\r\n    const reqFetchOption = JSON.parse(JSON.stringify(this.#DEFAULT_FETCH_OPTION));\r\n    reqFetchOption.method = method;\r\n\r\n    // only add body on POST/PATCH/PUT methods\r\n    if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1)\r\n      reqFetchOption.body = JSON.stringify(data);\r\n\r\n    // always send X-Csrf-Token. This won't be a security hole.\r\n    reqFetchOption.headers['X-Csrf-Token'] = this.#csrfToken;\r\n    // add access token on header if accessTokenRequired is true\r\n    if (accessTokenRequired) {\r\n      reqFetchOption.headers['Authorization'] = 'Bearer ' + this.#accessToken;\r\n    }\r\n\r\n    if (url.includes('account') || url.includes('admin')) {\r\n      reqFetchOption.credentials = 'include';\r\n    }\r\n\r\n    if (additionalHeaders)\r\n      for (const [key, value] of Object.entries(additionalHeaders))\r\n        reqFetchOption.headers[key] = value;\r\n\r\n    // // We need to handle HEAD method separately as this method doesn't return any body.\r\n    // if (method === HTTP_METHOD.HEAD) {\r\n    //   return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n\r\n    //   });\r\n    // }\r\n\r\n    return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n      if (!response) {\r\n        // How is this possible???\r\n        throw new FrostError(\r\n          '서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.',\r\n          'fetchResult 객체가 undefined 또는 null입니다.', -1, false, undefined, undefined, url);\r\n      } else if (200 <= response.status && response.status <= 399) {  // this returns response.json()\r\n        // SUCCESS\r\n\r\n        if (response.status === 204) { // resource.deleted\r\n          // As 204 response means that resource is deleted and response does not include a response body,\r\n          // we need to make and return a fake response object.\r\n          return {\r\n            header: response.headers,\r\n            body: {\r\n              success: true,\r\n              code: 204,\r\n              subCode: 'resource.deleted',\r\n              message: 'Resource successfully deleted',\r\n            },\r\n          };\r\n        }\r\n\r\n        return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n      } else if (400 <= response.status && response.status <= 499) {\r\n        if (response.status === 401) {  // this \"possibly\" returns response.json()\r\n          // This code can be returned on both resource and account related routes,\r\n          // and we need to handle those separately.\r\n          //\r\n          // Possible subCodes:\r\n          // > wrong password / account locked / account deactivated (== maybe one of account related routes?)\r\n          //    - These will be raised when we signing in.\r\n          //      We need to throw a proper FrostError.\r\n          // > token not given / token expired / token invalid\r\n          //    - We need to try refreshing access token and retry this.\r\n          //      If access token refresh fails, then raise errors.\r\n          //\r\n          // If the error-occurred-request is related to resource routes,\r\n          // then we'll refresh access token and and retry the request.\r\n          // and if it fails, then we'll throw FrostError.\r\n          //\r\n          // If the error-occurred-request is related to account routes,\r\n          // then we need to parse subCode, so we'll handle this error on second stage.\r\n          if (!url.startsWith('account/')) {\r\n            if (!isRetry)\r\n              return this.refreshAuthentications(true).then((api) => api.#apiRequest({\r\n                method: method,\r\n                url: url,\r\n                accessTokenRequired: accessTokenRequired,\r\n                additionalHeaders: additionalHeaders, data: data,\r\n                isRetry: true,\r\n              }));\r\n            throw new FrostError(\r\n              '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n              '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n              response.status, false, undefined, undefined, url);\r\n          }\r\n\r\n          return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n        } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\r\n          // this \"possibly\" returns response.json().\r\n          // See RETURNABLE_ERROR for more details.\r\n          return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n        } else if (response.status === 403) {\r\n          // Requested action was forbidden\r\n          throw new FrostError(\r\n            '해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status,\r\n            false, undefined, undefined, url);\r\n        } else if (response.status === 405) {\r\n          // Method not permitted\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status,\r\n            false, undefined, undefined, url);\r\n        } else if (response.status === 415) {\r\n          // requested response content-type not supported\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status,\r\n            false, undefined, undefined, url);\r\n        } else if (response.status === 429) {\r\n          throw new FrostError(\r\n            '요청이 너무 빈번해요,\\n조금 천천히 진행해주세요.',\r\n            `429 rate limit`, 429, false, undefined, undefined, url);\r\n        } else {\r\n          // unknown client-fault error\r\n          throw new FrostError(\r\n            '알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status,\r\n            false, undefined, undefined, url);\r\n        }\r\n      } else {  // HTTP status code is more than 500(server error)\r\n        throw new FrostError(\r\n          '서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `statusCode가 ${response.status}입니다.`, response.status,\r\n          false, undefined, undefined, url);\r\n      }\r\n\r\n      // This is just for type-checking, response.status won't be less than 200, right?\r\n      // ...right? please... no......\r\n      return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n    }).then((response: { header: Record<string, unknown>, body: Record<string, unknown> } | APIResult) => {\r\n      if (response instanceof APIResult)\r\n        return response;\r\n\r\n      const apiResult = new APIResult(response);\r\n      if (apiResult.code === 404 && apiResult.subCode === 'http.not_found') {\r\n        throw new FrostError(\r\n          '무엇을 할 지 모르는 요청이에요,\\n사이트 개발자에게 문의해주세요ㅠㅜ',\r\n          'http.not_found입니다.', apiResult.code, false, apiResult, undefined, url);\r\n      }\r\n      // else if (apiResult.code === 401) {\r\n      //   // Possible subCodes:\r\n      //   // > token not given / token expired / token invalid\r\n      //   //   (== resource related routes, !!!ALREADY HANDLED!!!)\r\n      //   //    - We need to try refreshing access token and retry this.\r\n      //   //      If access token refresh fails, then raise errors.\r\n      //   // > wrong password / account locked / account deactivated\r\n      //   //   (== account related routes, we need to handle this here.)\r\n      //   //    - These will be raised when we signing in.\r\n      //   //      We need to throw a proper FrostError.\r\n      //   throw new FrostError(\r\n      //     '로그인을 할 수 없어요.',\r\n      //     '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n      //     apiResult.code, true, apiResult, undefined, url);\r\n      // }\r\n\r\n      return apiResult;\r\n    }).catch((reason) => {\r\n      // catch all exceptions and change it to FrostError\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `on FrostAPI.#apiRequest -> reason = ${reason}`, -1, false, undefined, undefined, url);\r\n      }\r\n    });\r\n  }\r\n\r\n  isSignedIn(checkNetwork = false) {\r\n    if (checkNetwork)\r\n      return this.refreshAuthentications().then((_) => true, (_) => false);\r\n\r\n    return Promise.resolve((this.#accessToken) ? true : false);\r\n  }\r\n\r\n  signUp(id: string, email: string, password: string, nickname: string) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/signup',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, data: { id: id, pw: password, nick: nickname, email: email }\r\n    }).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#accessTokenExpiresAt = new Date(apiResult.data.user.access_token.exp);\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n\r\n      // We need to generate error message from the subcode.\r\n      let errorMsg = '';\r\n      let errorFieldName = '';\r\n      switch (apiResult.subCode) {\r\n        case 'user.already_used': {\r\n          const duplicatedItems: string = apiResult.data.duplicate[0];\r\n          let duplicatedItemsKor = '';\r\n          switch (duplicatedItems) {\r\n            case 'email':\r\n              errorFieldName = 'email';\r\n              duplicatedItemsKor = '이메일은';\r\n              break;\r\n            case 'id':\r\n              errorFieldName = 'id';\r\n              duplicatedItemsKor = '아이디는';\r\n              break;\r\n            case 'nick':\r\n            case 'nickname':\r\n              errorFieldName = 'nick';\r\n              duplicatedItemsKor = '별명은';\r\n              break;\r\n            case 'pw':\r\n            case 'password':\r\n              // WTF??? HOW??????\r\n              errorFieldName = 'pw';\r\n              duplicatedItemsKor = '비밀번호는';\r\n              break;\r\n            default:\r\n              duplicatedItemsKor = '정보는';\r\n              break;\r\n          }\r\n          errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\r\n          break;\r\n        }\r\n        case 'request.body.bad_semantics': {\r\n          // errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\r\n          const badSemanticsReason: Record<string, unknown> = apiResult.data.bad_semantics[0];\r\n          if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'email')) {\r\n            errorFieldName = 'email';\r\n            errorMsg = '올바른 이메일 형식이 아니에요.';\r\n          } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'pw')) {\r\n            const pwBadSemanticsReason: string = badSemanticsReason.pw;\r\n            switch (pwBadSemanticsReason) {\r\n              case 'TOO_SHORT':\r\n                errorMsg = '비밀번호가 너무 짧아요,\\n'; break;\r\n              case 'TOO_LONG':\r\n                errorMsg = '1024자가 넘으면 비밀번호로 쓰기에 너무 길지 않을까요?\\n'; break;\r\n              case 'NEED_MORE_CHAR_TYPE':\r\n                errorMsg = '비밀번호가 너무 단순해요,\\n'; break;\r\n              case 'FORBIDDEN_CHAR':\r\n                errorMsg = '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n'; break;\r\n              case 'PW_REUSED_ON_ID_EMAIL_NICK':\r\n                errorMsg = '비밀번호가 이메일, 별칭, 또는 아이디와 같아요,\\n'; break;\r\n              default:\r\n                errorMsg = '사용할 수 있는 비밀번호가 아니에요,\\n'; break;\r\n            }\r\n            errorFieldName = 'pw';\r\n            // errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\r\n          } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'id')) {\r\n            const idBadSemanticsReason: string = badSemanticsReason.id;\r\n            switch (idBadSemanticsReason) {\r\n              case 'TOO_SHORT':\r\n                errorMsg = '아이디가 너무 짧아요,\\n'; break;\r\n              case 'TOO_LONG':\r\n                errorMsg = '아이디가 너무 길어요,\\n'; break;\r\n              case 'FORBIDDEN_CHAR':\r\n                errorMsg = '아이디에 사용할 수 없는 문자가 들어있어요,\\n'; break;\r\n              default:\r\n                errorMsg = '사용할 수 있는 아이디가 아니에요,\\n'; break;\r\n            }\r\n            errorFieldName = 'id';\r\n            errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\r\n          } else {\r\n            errorMsg += '정보가 올바르지 않아요,\\n새로고침 후 다시 시도해주세요.';\r\n          }\r\n          break;\r\n        }\r\n        default:\r\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n      }\r\n\r\n      throw new FrostError(\r\n        errorMsg,\r\n        `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n        apiResult.code, true, apiResult, errorFieldName, 'account/signup');\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#clearAuthenticationInfo();\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  signIn(idOrEmail: string, password: string) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/signin',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, data: { id: idOrEmail, pw: password },\r\n    }).then((apiResult: APIResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#accessTokenExpiresAt = new Date(apiResult.data.user.access_token.exp);\r\n        this.#refreshResult = apiResult.data;\r\n        this.userData\r\n        return this;\r\n      }\r\n\r\n      let errorMsg = '';\r\n      let errorFieldName = '';\r\n      if (!apiResult)\r\n        throw new FrostError(\r\n          '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n          `account/signin=>!apiResult`, -1, true, undefined, undefined, 'account/signin');\r\n\r\n      // If apiResponse is in FrostError obj, We can generate error message from the subcode.\r\n      switch (apiResult.subCode) {\r\n        case 'user.not_found':\r\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n          break;\r\n        case 'user.wrong_password':\r\n          errorFieldName = 'pw'\r\n          errorMsg = '비밀번호가 맞지 않아요.\\n';\r\n          errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\r\n          break;\r\n        case 'user.locked':\r\n          errorMsg = '계정이 잠겼습니다, 관리자에게 연락해주세요.\\n';\r\n          errorMsg += `(잠긴 이유: ${apiResult.data.reason})`;\r\n          break;\r\n        case 'user.deactivated':\r\n          errorMsg = '계정이 폐쇄되었습니다, 관리자에게 연락해주세요.\\n'\r\n          errorMsg += `(폐쇄된 이유: ${apiResult.data.reason})`;\r\n          break;\r\n        case 'user.email_not_verified':\r\n          errorMsg = '아직 가입 시 적으신 메일 주소를 인증하지 않으셨어요,\\n메일함을 확인 후 메일 인증을 진행해주세요.';\r\n          break;\r\n        default:\r\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후 새로고침을 한 후에 다시 시도해주세요.';\r\n      }\r\n\r\n      throw new FrostError(\r\n        errorMsg,\r\n        `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n        apiResult.code, true, apiResult, errorFieldName, 'account/signin');\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#clearAuthenticationInfo();\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  signOut() {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/signout',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, data: { signout: 'OK' },\r\n    }).then(\r\n      () => {\r\n        // Actually, this action won't fail, except when the server is dead.\r\n        // Just reset the csrf token and access token.\r\n        this.#clearAuthenticationInfo();\r\n        return this;\r\n      });\r\n  }\r\n\r\n  refreshAuthentications(forceRefresh = false) {\r\n    if (!forceRefresh && this.#accessToken && this.#accessTokenExpiresAt > new Date()) {\r\n      return Promise.resolve(this);\r\n    }\r\n\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/refresh',\r\n      accessTokenRequired: false\r\n    }\r\n    ).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#accessTokenExpiresAt = new Date(apiResult.data.user.access_token.exp);\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n      throw new FrostError(\r\n        '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n        `account/refresh=>response.success = false입니다. code = ${apiResult.code}`,\r\n        400, true, apiResult, undefined, 'account/refresh');\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#clearAuthenticationInfo();\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  changePassword(currentPw: string, newPw: string, newPwReType: string) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/change-password',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {},\r\n      data: {\r\n        original_password: currentPw,\r\n        new_password: newPw,\r\n        new_password_check: newPwReType,\r\n      },\r\n    }).then((apiResult: APIResult) => {\r\n      if (apiResult.success) {\r\n        return this;\r\n      }\r\n\r\n      let errorMsg = '';\r\n      let errorFieldName = '';\r\n      if (!apiResult)\r\n        throw new FrostError(\r\n          '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n          `account/change-password=>!apiResult`, -1, true, undefined, undefined,\r\n          'account/change-password');\r\n\r\n      // If apiResponse is in FrostError obj, We can generate error message from the subcode.\r\n      switch (apiResult.subCode) {\r\n        case 'user.not_found':\r\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n          break;\r\n        case 'user.wrong_password':\r\n          errorFieldName = 'currentPw';\r\n          errorMsg = '현재 사용 중인 비밀번호가 맞지 않아요,\\n다시 시도해주세요.';\r\n          break;\r\n        case 'password.change_failed': {\r\n          // apiResult.data.reason can be...\r\n          // RETYPE_MISMATCH, TOO_SHORT, TOO_LONG, NEED_MORE_CHAR_TYPE, FORBIDDEN_CHAR\r\n          const reasonType: string = apiResult.data.reason;\r\n          switch (reasonType) {\r\n            case 'RETYPE_MISMATCH':\r\n              errorFieldName = 'newPwReType';\r\n              errorMsg = '위에 입력하신 새 비밀번호와 일치하지 않아요,\\n새 비밀번호를 다시 입력해주세요.\\n';\r\n              break;\r\n            case 'TOO_SHORT':\r\n              errorFieldName = 'newPw';\r\n              errorMsg = '비밀번호가 너무 짧아요,\\n';\r\n              break;\r\n            case 'TOO_LONG':\r\n              errorFieldName = 'newPw';\r\n              errorMsg = '1024자가 넘으면 비밀번호로 쓰기에 너무 길지 않을까요?\\n';\r\n              break;\r\n            case 'NEED_MORE_CHAR_TYPE':\r\n              errorFieldName = 'newPw';\r\n              errorMsg = '비밀번호가 너무 단순해요,\\n';\r\n              break;\r\n            case 'FORBIDDEN_CHAR':\r\n              errorFieldName = 'newPw';\r\n              errorMsg = '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n';\r\n              break;\r\n            case 'PW_REUSED_ON_ID_EMAIL_NICK':\r\n              errorFieldName = 'newPw';\r\n              errorMsg = '비밀번호가 이메일, 별칭, 또는 아이디와 같아요,\\n';\r\n              break;\r\n            default:\r\n              errorFieldName = 'newPw';\r\n              errorMsg = '사용할 수 있는 비밀번호가 아니에요,\\n';\r\n              break;\r\n          }\r\n          break;\r\n        }\r\n\r\n        default:\r\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n          break;\r\n      }\r\n\r\n      throw new FrostError(\r\n        errorMsg,\r\n        'account/change-password=>\\n'\r\n        + 'response.success=false\\n'\r\n        + `code = ${apiResult.code}\\n`\r\n        + `subCode=${apiResult.subCode}`,\r\n        apiResult.code, true, apiResult, errorFieldName,\r\n        'account/change-password');\r\n    }).catch((reason) => {\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n          `account/change-password=>${reason}`, -1, true, undefined, undefined,\r\n          'account/change-password');\r\n      }\r\n    });\r\n  }\r\n\r\n  deactivate(email: string, pw: string) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/deactivate',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, data: { email: email, password: pw, },\r\n    }).then((apiResult: APIResult) => {\r\n      if (apiResult.success) {\r\n        // User will be signed out if account deactivation succeed.\r\n        this.#clearAuthenticationInfo();\r\n        return this;\r\n      }\r\n\r\n      let errorMsg = '';\r\n      let errorFieldName = '';\r\n      if (!apiResult)\r\n        throw new FrostError(\r\n          '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n          `account/deactivate=>!apiResult`, -1, true, undefined, undefined,\r\n          'account/deactivate');\r\n\r\n      // If apiResponse is in FrostError obj, We can generate error message from the subcode.\r\n      switch (apiResult.subCode) {\r\n        case 'user.not_found':\r\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n          break;\r\n        case 'user.wrong_password':\r\n          errorFieldName = 'currentPw';\r\n          errorMsg = '비밀번호가 맞지 않아요,\\n다시 시도해주세요.';\r\n          break;\r\n        default:\r\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n          break;\r\n      }\r\n\r\n      throw new FrostError(\r\n        errorMsg,\r\n        'account/deactivate=>\\n'\r\n        + 'response.success=false\\n'\r\n        + `code = ${apiResult.code}\\n`\r\n        + `subCode=${apiResult.subCode}`,\r\n        apiResult.code, true, apiResult, errorFieldName,\r\n        'account/deactivate');\r\n    }).catch((reason) => {\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n          `account/deactivate=>${reason}`, -1, true, undefined, undefined,\r\n          'account/deactivate');\r\n      }\r\n    });\r\n  }\r\n\r\n  get userID() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user.id;\r\n  }\r\n\r\n  get userData() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user;\r\n  }\r\n\r\n  get roles() {\r\n    if (!this.#accessToken)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    const result: Array<{ [roleName: string]: string | boolean; }> = [];\r\n    try {\r\n      const token = JSON.parse(atob(this.#accessToken.split('.')[1]));\r\n      JSON.parse(token.role).forEach((rolePart: string) => {\r\n        if (rolePart === 'admin') return;\r\n        result.push(role2Object(rolePart));\r\n      });\r\n    } catch (e) {\r\n      /* tslint:disable:no-empty */\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  head(url: string, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.HEAD,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders\r\n    });\r\n  }\r\n  get(url: string, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.GET,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders\r\n    });\r\n  }\r\n  post(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders,\r\n      data: data\r\n    });\r\n  }\r\n  put(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.PUT,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders,\r\n      data: data\r\n    });\r\n  }\r\n  patch(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.PATCH,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders,\r\n      data: data\r\n    });\r\n  }\r\n  delete(url: string, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.DELETE,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders\r\n    });\r\n  }\r\n}\r\n\r\nexport default FrostAPI;\r\n"]},"metadata":{},"sourceType":"module"}