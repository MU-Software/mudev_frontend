{"ast":null,"code":"import { Manager } from 'socket.io-client';\nimport FrostAPI from 'src/network/api'; // Generate random safe string, borrowed from FrostAPI implementation\n\nconst generateRandomSecureToken = bytes => {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}; // From https://stackoverflow.com/a/40031979\n// Buffer to hex, also borrowed from FrostAPI implementation\n\n\nconst buf2hex = buffer => {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n};\n\nlet playCoSocketIOHandlerInstance;\nexport class PlayCoSocketIOHandler {\n  constructor() {\n    this.socketIoMgr = void 0;\n    this.socketIo = void 0;\n    this.socketIoAuthToken = void 0;\n    this.sioToken = void 0;\n    this.sioTokenExpiresAt = void 0;\n    this.csrfToken = void 0;\n    this.sessionId = void 0;\n    this.socketIoEventHandler = {\n      connect: () => {\n        console.log('connected!');\n        this.sessionId = this.socketIo.id;\n        const engine = this.socketIo.io.engine;\n        console.log(engine.transport.name); // in most cases, prints \"polling\"\n\n        engine.once(\"upgrade\", () => {\n          // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n          console.log(engine.transport.name); // in most cases, prints \"websocket\"\n        });\n        engine.on(\"packet\", ({\n          type,\n          data\n        }) => {\n          // called for each packet received\n          console.log('onPacket');\n          console.log(type);\n          console.log(data);\n        });\n        engine.on(\"packetCreate\", ({\n          type,\n          data\n        }) => {\n          // called for each packet sent\n          console.log('onPacketCreate');\n          console.log(type);\n          console.log(data);\n        }); // engine.on(\"drain\", () => {\n        //   // called when the write buffer is drained\n        // });\n\n        engine.on(\"close\", reason => {\n          // called when the underlying connection is closed\n          console.log(reason);\n        }); // Get SIO Token\n        // this.refreshSIOToken();\n      },\n      disconnect: reason => {\n        console.log('disconnected!');\n        console.log(reason);\n        this.sessionId = '';\n      },\n      playlistUpdate: () => {//\n      }\n    };\n    if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\n    this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\n      reconnectionDelayMax: 5000,\n      path: '/api/dev/ws',\n      transports: ['websocket'],\n      upgrade: false,\n      forceNew: false,\n      autoConnect: false,\n      closeOnBeforeunload: false\n    });\n    this.socketIo = this.socketIoMgr.socket('/playco_ws');\n\n    for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\n      this.socketIo.on(key, value);\n    }\n\n    playCoSocketIOHandlerInstance = this;\n  }\n\n  refreshSIOToken() {\n    // We need to get a new SIO Token by request.\n    this.csrfToken = generateRandomSecureToken(32);\n    new FrostAPI().post('playco/socketio/auth', {\n      'sid': this.sessionId,\n      'sio_csrf_token': this.csrfToken\n    }, true).then(result => {\n      //\n      const sioTokenData = result.data.sio_token;\n      this.sioToken = sioTokenData;\n      this.sioTokenExpiresAt = new Date(sioTokenData.exp);\n    }, reason => {\n      //\n      console.log(reason);\n      console.log(reason.debugMessage);\n    });\n  }\n\n  connect() {\n    // Connect SocketIO if it's not connected\n    if (!this.socketIo.connected) {\n      this.socketIo.connect();\n    }\n  }\n\n  disconnect() {\n    if (!this.socketIo.connected) return;\n    this.socketIo.disconnect();\n  }\n\n  enterPlaylist(playlistId, hook) {\n    const reqData = {\n      eventName: 'onPlaylistEnter',\n      data: {\n        playlist_id: 0\n      }\n    };\n  }\n\n  leavePlaylist(playlistId) {//\n  }\n\n}","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/ui/page/playco/playco/sio.ts"],"names":["Manager","FrostAPI","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","playCoSocketIOHandlerInstance","PlayCoSocketIOHandler","constructor","socketIoMgr","socketIo","socketIoAuthToken","sioToken","sioTokenExpiresAt","csrfToken","sessionId","socketIoEventHandler","connect","console","log","id","engine","io","transport","name","once","on","type","data","reason","disconnect","playlistUpdate","reconnectionDelayMax","path","transports","upgrade","forceNew","autoConnect","closeOnBeforeunload","socket","key","value","Object","entries","refreshSIOToken","post","then","result","sioTokenData","sio_token","Date","exp","debugMessage","connected","enterPlaylist","playlistId","hook","reqData","eventName","playlist_id","leavePlaylist"],"mappings":"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","sourcesContent":["import { io, Manager } from 'socket.io-client';\r\nimport { FrostError } from 'src/common/error';\r\nimport FrostAPI from 'src/network/api';\r\n\r\n// Generate random safe string, borrowed from FrostAPI implementation\r\nconst generateRandomSecureToken = (bytes: number) => {\r\n    const randArray = new Uint32Array(bytes);\r\n    window.crypto.getRandomValues(randArray);\r\n    return buf2hex(randArray);\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\n// Buffer to hex, also borrowed from FrostAPI implementation\r\nconst buf2hex = (buffer: ArrayBufferLike) => {\r\n    return [...new Uint8Array(buffer)]\r\n        .map(x => x.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\nlet playCoSocketIOHandlerInstance: PlayCoSocketIOHandler;\r\nexport class PlayCoSocketIOHandler {\r\n    private socketIoMgr: io.Manager;\r\n    private socketIo: io;\r\n    private socketIoAuthToken: { exp: Date, token: string };\r\n\r\n    private sioToken: string;\r\n    private sioTokenExpiresAt: Date;\r\n    private csrfToken: string;\r\n    private sessionId: string;\r\n\r\n    socketIoEventHandler: Record<string, () => void> = {\r\n        connect: () => {\r\n            console.log('connected!');\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            const engine = this.socketIo.io.engine;\r\n            console.log(engine.transport.name); // in most cases, prints \"polling\"\r\n\r\n            engine.once(\"upgrade\", () => {\r\n              // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\r\n              console.log(engine.transport.name); // in most cases, prints \"websocket\"\r\n            });\r\n\r\n            engine.on(\"packet\", ({ type, data }) => {\r\n              // called for each packet received\r\n              console.log('onPacket');\r\n              console.log(type);\r\n              console.log(data);\r\n            });\r\n\r\n            engine.on(\"packetCreate\", ({ type, data }) => {\r\n              // called for each packet sent\r\n              console.log('onPacketCreate')\r\n              console.log(type);\r\n              console.log(data);\r\n            });\r\n\r\n            // engine.on(\"drain\", () => {\r\n            //   // called when the write buffer is drained\r\n            // });\r\n\r\n            engine.on(\"close\", (reason) => {\r\n              // called when the underlying connection is closed\r\n              console.log(reason);\r\n            });\r\n\r\n\r\n\r\n\r\n\r\n            // Get SIO Token\r\n            // this.refreshSIOToken();\r\n        },\r\n        disconnect: (reason) => {\r\n            console.log('disconnected!');\r\n            console.log(reason);\r\n            this.sessionId = '';\r\n        },\r\n        playlistUpdate: () => {\r\n            //\r\n        }\r\n    };\r\n\r\n    constructor() {\r\n        if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\r\n\r\n        this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\r\n            reconnectionDelayMax: 5000,\r\n            path: '/api/dev/ws',\r\n            transports: ['websocket',],\r\n            upgrade: false,\r\n\r\n            forceNew: false,\r\n            autoConnect: false,\r\n            closeOnBeforeunload: false,\r\n        });\r\n\r\n        this.socketIo = this.socketIoMgr.socket('/playco_ws');\r\n        for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\r\n            this.socketIo.on(key, value);\r\n        }\r\n\r\n        playCoSocketIOHandlerInstance = this;\r\n    }\r\n\r\n    private refreshSIOToken() {\r\n        // We need to get a new SIO Token by request.\r\n        this.csrfToken = generateRandomSecureToken(32);\r\n        (new FrostAPI())\r\n            .post('playco/socketio/auth', { 'sid': this.sessionId, 'sio_csrf_token': this.csrfToken, }, true)\r\n            .then(\r\n                (result) => {\r\n                    //\r\n                    const sioTokenData: {'exp': string, 'token': string} = result.data.sio_token;\r\n                    this.sioToken = sioTokenData;\r\n                    this.sioTokenExpiresAt = new Date(sioTokenData.exp);\r\n                },\r\n                (reason: FrostError) => {\r\n                    //\r\n                    console.log(reason);\r\n                    console.log(reason.debugMessage);\r\n                },\r\n            )\r\n    }\r\n\r\n    connect() {\r\n        // Connect SocketIO if it's not connected\r\n        if (!this.socketIo.connected) {\r\n            this.socketIo.connect();\r\n        }\r\n    }\r\n\r\n    disconnect() {\r\n        if (!this.socketIo.connected)\r\n            return;\r\n\r\n        this.socketIo.disconnect();\r\n    }\r\n\r\n    enterPlaylist(playlistId: number, hook: (unknown) => void) {\r\n        const reqData = {\r\n            eventName: 'onPlaylistEnter',\r\n            data: {\r\n                playlist_id: 0,\r\n            },\r\n        };\r\n    }\r\n\r\n    leavePlaylist(playlistId: number) {\r\n        //\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}