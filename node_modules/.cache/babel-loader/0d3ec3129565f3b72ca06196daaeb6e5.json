{"ast":null,"code":"// (c) MUsoftware 2022\n'use strict';\n\nimport _classPrivateFieldLooseBase from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { FrostError } from '../common/error';\nimport { APIResult } from './api_response';\nconst HTTP_METHOD = {\n  // We will support only these methods for now\n  HEAD: 'HEAD',\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  PATCH: 'PATCH',\n  DELETE: 'DELETE'\n};\n\nfunction role2Object(roleStr) {\n  const result = {};\n  roleStr.split(\"&\").forEach(function (part) {\n    const item = part.split(\"=\");\n\n    if (item.length == 2) {\n      result[item[0]] = decodeURIComponent(item[1]);\n      if (result[item[0]] === 'true' || result[item[0]] === 'false') result[item[0]] = result[item[0]] === 'true' ? true : false;\n    }\n  });\n  return result;\n} // From https://stackoverflow.com/a/40031979\n\n\nfunction buf2hex(buffer) {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n} // Generate random safe string\n\n\nfunction generateRandomSecureToken(bytes) {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}\n\nlet frostApiInstance;\n\nvar _API_USED_METHOD = /*#__PURE__*/_classPrivateFieldLooseKey(\"API_USED_METHOD\");\n\nvar _BASE_URL = /*#__PURE__*/_classPrivateFieldLooseKey(\"BASE_URL\");\n\nvar _DEFAULT_FETCH_OPTION = /*#__PURE__*/_classPrivateFieldLooseKey(\"DEFAULT_FETCH_OPTION\");\n\nvar _csrfToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"csrfToken\");\n\nvar _accessToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"accessToken\");\n\nvar _refreshResult = /*#__PURE__*/_classPrivateFieldLooseKey(\"refreshResult\");\n\nvar _apiRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"apiRequest\");\n\nclass FrostAPI {\n  // We only uses these http methods now.\n  // Refresh Token will be saved on cookie storage,\n  // And all of these attributes must be private.\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\n  // Although these HTTP Response status code means error,\n  // each routes have to handle these codes differently.\n  // Default fetch options,\n  // we'll copy and modify this default option object on every request.\n  // Account related properties\n  constructor() {\n    Object.defineProperty(this, _apiRequest, {\n      value: _apiRequest2\n    });\n    Object.defineProperty(this, _BASE_URL, {\n      writable: true,\n      value: 'https://hyperion.mudev.cc/api/dev/'\n    });\n    Object.defineProperty(this, _DEFAULT_FETCH_OPTION, {\n      writable: true,\n      value: {\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'same-origin',\n        redirect: 'follow',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }\n    });\n    Object.defineProperty(this, _csrfToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _accessToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _refreshResult, {\n      writable: true,\n      value: null\n    });\n    if (frostApiInstance) return frostApiInstance;\n    _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n    frostApiInstance = this;\n  }\n\n  isSignedIn(checkNetwork = false) {\n    if (checkNetwork) return this.refreshAuthentications().then(_ => true, _ => false);\n    return Promise.resolve(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken] ? true : false);\n  }\n\n  signUp(id, email, password, nickname) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/signup',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        id: id,\n        pw: password,\n        nick: nickname,\n        email: email\n      }\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      } // We need to generate error message from the subcode.\n\n\n      let errorMsg = '';\n      let errorFieldName = '';\n\n      switch (apiResult.subCode) {\n        case 'user.already_used':\n          {\n            const duplicatedItems = apiResult.data.duplicate[0];\n            let duplicatedItemsKor = '';\n\n            switch (duplicatedItems) {\n              case 'email':\n                errorFieldName = 'email';\n                duplicatedItemsKor = '이메일은';\n                break;\n\n              case 'id':\n                errorFieldName = 'id';\n                duplicatedItemsKor = '아이디는';\n                break;\n\n              case 'nick':\n              case 'nickname':\n                errorFieldName = 'nick';\n                duplicatedItemsKor = '별명은';\n                break;\n\n              case 'pw':\n              case 'password':\n                // WTF??? HOW??????\n                errorFieldName = 'pw';\n                duplicatedItemsKor = '비밀번호는';\n                break;\n\n              default:\n                duplicatedItemsKor = '정보는';\n                break;\n            }\n\n            errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\n            break;\n          }\n\n        case 'request.body.bad_semantics':\n          {\n            // errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\n            const badSemanticsReason = apiResult.data.bad_semantics[0];\n\n            if (Object.prototype.perty.call(badSemanticsReason, 'email')) {\n              errorFieldName = 'email';\n              errorMsg = '올바른 이메일 형식이 아니에요.';\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'pw')) {\n              const pwBadSemanticsReason = badSemanticsReason.pw;\n\n              switch (pwBadSemanticsReason) {\n                case 'TOO_SHORT':\n                  errorMsg = '비밀번호가 너무 짧아요,\\n';\n                  break;\n\n                case 'TOO_LONG':\n                  errorMsg = '1024자가 넘으면 비밀번호로 쓰기에 너무 길지 않을까요?\\n';\n                  break;\n\n                case 'NEED_MORE_CHAR_TYPE':\n                  errorMsg = '비밀번호가 너무 단순해요,\\n';\n                  break;\n\n                case 'FORBIDDEN_CHAR':\n                  errorMsg = '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n';\n                  break;\n\n                default:\n                  errorMsg = '사용할 수 있는 비밀번호가 아니에요,\\n';\n                  break;\n              }\n\n              errorFieldName = 'pw'; // errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\n            } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'id')) {\n              const idBadSemanticsReason = badSemanticsReason.id;\n\n              switch (idBadSemanticsReason) {\n                case 'TOO_SHORT':\n                  errorMsg = '아이디가 너무 짧아요,\\n';\n                  break;\n\n                case 'TOO_LONG':\n                  errorMsg = '아이디가 너무 길어요,\\n';\n                  break;\n\n                case 'FORBIDDEN_CHAR':\n                  errorMsg = '아이디에 사용할 수 없는 문자가 들어있어요,\\n';\n                  break;\n\n                default:\n                  errorMsg = '사용할 수 있는 아이디가 아니에요,\\n';\n                  break;\n              }\n\n              errorFieldName = 'id';\n              errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\n            } else {\n              errorMsg += '정보가 올바르지 않아요,\\n새로고침 후 다시 시도해주세요.';\n            }\n\n            break;\n          }\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code, true, apiResult, errorFieldName);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signIn(idOrEmail, password) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/signin',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      data: {\n        id: idOrEmail,\n        pw: password\n      }\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        this.userData;\n        return this;\n      }\n\n      let errorMsg = '';\n      let errorFieldName = '';\n      if (!apiResult) throw new FrostError('알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.', `account/signin=>!apiResult`, -1); // If apiResponse is in FrostError obj, We can generate error message from the subcode.\n\n      switch (apiResult.subCode) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorFieldName = 'pw';\n          errorMsg = '비밀번호가 맞지 않습니다, 비밀번호를 다시 입력해주세요.\\n';\n          errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\n          break;\n\n        case 'user.locked':\n          errorMsg = '계정이 잠겼습니다, 관리자에게 연락해주세요.\\n';\n          errorMsg += `(잠긴 이유: ${apiResult.data.reason})`;\n          break;\n\n        case 'user.deactivated':\n          errorMsg = '계정이 폐쇄되었습니다, 관리자에게 연락해주세요.\\n';\n          errorMsg += `(폐쇄된 이유: ${apiResult.data.reason})`;\n          break;\n\n        default:\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후 새로고침을 한 후에 다시 시도해주세요.';\n      }\n\n      throw new FrostError(errorMsg, `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code, true, apiResult, errorFieldName);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signOut() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/signout',\n      accessTokenRequired: false,\n      additionalHeaders: {},\n      body: {\n        signout: true\n      }\n    }).then(() => {\n      // Actually, this action won't fail, except when the server is dead.\n      // Just reset the csrf token and access token.\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      return this;\n    });\n  }\n\n  refreshAuthentications() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: 'account/refresh',\n      accessTokenRequired: false\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n\n      throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400, true, apiResult);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  get userID() {\n    var _classPrivateFieldLoo;\n\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user.id;\n  }\n\n  get userData() {\n    var _classPrivateFieldLoo2;\n\n    if (!((_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo2 === void 0 ? void 0 : _classPrivateFieldLoo2.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user;\n  }\n\n  get roles() {\n    if (!_classPrivateFieldLooseBase(this, _accessToken)[_accessToken]) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    const result = [];\n\n    try {\n      const token = JSON.parse(atob(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken].split('.')[1]));\n      JSON.parse(token.role).forEach(rolePart => {\n        if (rolePart === 'admin') return;\n        result.push(role2Object(rolePart));\n      });\n    } catch (e) {\n      /* tslint:disable:no-empty */\n    }\n\n    return result;\n  }\n\n  head(url, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.HEAD,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders\n    });\n  }\n\n  get(url, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.GET,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders\n    });\n  }\n\n  post(url, data = {}, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.POST,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders,\n      data: data\n    });\n  }\n\n  put(url, data = {}, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.PUT,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders,\n      data: data\n    });\n  }\n\n  patch(url, data = {}, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.PATCH,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders,\n      data: data\n    });\n  }\n\n  delete(url, accessTokenRequired = false, additionalHeaders = {}) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest]({\n      method: HTTP_METHOD.DELETE,\n      url: url,\n      accessTokenRequired: accessTokenRequired,\n      additionalHeaders: additionalHeaders\n    });\n  }\n\n}\n\nfunction _apiRequest2({\n  method,\n  url,\n  accessTokenRequired,\n  additionalHeaders,\n  data,\n  isRetry\n} = {\n  method: HTTP_METHOD.GET,\n  url: '',\n  accessTokenRequired: false,\n  additionalHeaders: {},\n  data: {},\n  isRetry: false\n}) {\n  // check if requested method is allowed\n  if (_classPrivateFieldLooseBase(FrostAPI, _API_USED_METHOD)[_API_USED_METHOD].indexOf(method) == -1) {\n    throw 'NOT_ALLOWED_METHOD';\n  } // deep copy fetch option object\n\n\n  const reqFetchOption = JSON.parse(JSON.stringify(_classPrivateFieldLooseBase(this, _DEFAULT_FETCH_OPTION)[_DEFAULT_FETCH_OPTION]));\n  reqFetchOption.method = method; // only add body on POST/PATCH/PUT methods\n\n  if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1) reqFetchOption.body = JSON.stringify(data); // always send X-Csrf-Token. This won't be a security hole.\n\n  reqFetchOption.headers['X-Csrf-Token'] = _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken]; // add access token on header if accessTokenRequired is true\n\n  if (accessTokenRequired) {\n    reqFetchOption.headers['Authorization'] = 'Bearer ' + _classPrivateFieldLooseBase(this, _accessToken)[_accessToken];\n  }\n\n  if (url.includes('account') || url.includes('admin')) {\n    reqFetchOption.credentials = 'include';\n  }\n\n  if (additionalHeaders) for (const [key, value] of Object.entries(additionalHeaders)) reqFetchOption.headers[key] = value; // // We need to handle HEAD method separately as this method doesn't return any body.\n  // if (method === HTTP_METHOD.HEAD) {\n  //   return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\n  //   });\n  // }\n\n  return fetch(_classPrivateFieldLooseBase(this, _BASE_URL)[_BASE_URL] + url, reqFetchOption).then(response => {\n    console.log(response);\n\n    if (!response) {\n      // How is this possible???\n      throw new FrostError('서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.', 'fetchResult 객체가 undefined 또는 null입니다.', -1);\n    } else if (200 <= response.status && response.status <= 399) {\n      // this returns response.json()\n      // SUCCESS\n      if (response.status === 204) {\n        // resource.deleted\n        // As 204 response means that resource is deleted and response does not include a response body,\n        // we need to make and return a fake response object.\n        return {\n          header: response.headers,\n          body: {\n            success: true,\n            code: 204,\n            subCode: 'resource.deleted',\n            message: 'Resource successfully deleted'\n          }\n        };\n      }\n\n      return response.json().then(responseBody => ({\n        header: response.headers,\n        body: responseBody\n      }));\n    } else if (400 <= response.status && response.status <= 499) {\n      if (response.status === 401) {\n        // this \"possibly\" returns response.json()\n        // This code can be returned on both resource and account related routes,\n        // and we need to handle those separately.\n        //\n        // Possible subCodes:\n        // > wrong password / account locked / account deactivated (== maybe one of account related routes?)\n        //    - These will be raised when we signing in.\n        //      We need to throw a proper FrostError.\n        // > token not given / token expired / token invalid\n        //    - We need to try refreshing access token and retry this.\n        //      If access token refresh fails, then raise errors.\n        //\n        // If the error-occurred-request is related to resource routes,\n        // then we'll refresh access token and and retry the request.\n        // and if it fails, then we'll throw FrostError.\n        //\n        // If the error-occurred-request is related to account routes,\n        // then we need to parse subCode, so we'll handle this error on second stage.\n        if (!url.startsWith('account/')) {\n          if (!isRetry) return this.refreshAuthentications().then(api => _classPrivateFieldLooseBase(api, _apiRequest)[_apiRequest]({\n            method: method,\n            url: url,\n            accessTokenRequired: accessTokenRequired,\n            additionalHeaders: additionalHeaders,\n            data: data,\n            isRetry: true\n          }));\n          throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`, response.status);\n        }\n\n        return response.json().then(responseBody => ({\n          header: response.headers,\n          body: responseBody\n        }));\n      } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\n        // this \"possibly\" returns response.json().\n        // See RETURNABLE_ERROR for more details.\n        return response.json().then(responseBody => ({\n          header: response.headers,\n          body: responseBody\n        }));\n      } else if (response.status === 403) {\n        // Requested action was forbidden\n        throw new FrostError('해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 405) {\n        // Method not permitted\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 415) {\n        // requested response content-type not supported\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 429) {\n        throw new FrostError('요청이 너무 빈번해요,\\n조금 천천히 진행해주세요.', `429 rate limit`, 429);\n      } else {\n        // unknown client-fault error\n        throw new FrostError('알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      }\n    } else {\n      // HTTP status code is more than 500(server error)\n      throw new FrostError('서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `statusCode가 ${response.status}입니다.`, response.status);\n    } // This is just for type-checking, response.status won't be less than 200, right?\n    // ...right? please... no......\n\n\n    return response.json().then(responseBody => ({\n      header: response.headers,\n      body: responseBody\n    }));\n  }).then(response => {\n    console.log(response);\n    if (response instanceof APIResult) return response;\n    const apiResult = new APIResult(response);\n\n    if (apiResult.code === 404 && apiResult.subCode === 'http.not_found') {\n      throw new FrostError('무엇을 할 지 모르는 요청이에요,\\n사이트 개발자에게 문의해주세요ㅠㅜ', 'http.not_found입니다.', apiResult.code, false);\n    } // else if (apiResult.code === 401) {\n    //   // Possible subCodes:\n    //   // > token not given / token expired / token invalid\n    //   //   (== resource related routes, !!!ALREADY HANDLED!!!)\n    //   //    - We need to try refreshing access token and retry this.\n    //   //      If access token refresh fails, then raise errors.\n    //   // > wrong password / account locked / account deactivated\n    //   //   (== account related routes, we need to handle this here.)\n    //   //    - These will be raised when we signing in.\n    //   //      We need to throw a proper FrostError.\n    //   throw new FrostError(\n    //     '로그인을 할 수 없어요.',\n    //     '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\n    //     apiResult.code, true, apiResult);\n    // }\n\n\n    return apiResult;\n  }).catch(reason => {\n    // catch all exceptions and change it to FrostError\n    if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n      throw reason;\n    } else {\n      throw new FrostError('알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\n    }\n  });\n}\n\nObject.defineProperty(FrostAPI, _API_USED_METHOD, {\n  writable: true,\n  value: [// HTTP_METHOD.HEAD,  // NOT ALLOWED YET!!!\n  HTTP_METHOD.GET, HTTP_METHOD.POST, HTTP_METHOD.PUT, HTTP_METHOD.PATCH, HTTP_METHOD.DELETE]\n});\nFrostAPI.RETURNABLE_ERROR = [// Actually, on 404, we need to filter http.not_found out only,\n// and any other responses must be returned, but we can get subcode after response.json().\n// And response.json() returns Promise<Any> and we cannot get subCode directly,\n// so we need to handle 404 on second stage.\n404, // http || resource not found\n409, // already used / information mismatch, conflict\n410, // resource gone\n412, // resource prediction failed\n422 // request.body.bad_semantics - email address validation failure, etc.\n];\nexport default FrostAPI;","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/network/api.ts"],"names":["FrostError","APIResult","HTTP_METHOD","HEAD","GET","POST","PUT","PATCH","DELETE","role2Object","roleStr","result","split","forEach","part","item","length","decodeURIComponent","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","frostApiInstance","FrostAPI","constructor","mode","cache","credentials","redirect","referrerPolicy","headers","isSignedIn","checkNetwork","refreshAuthentications","then","_","Promise","resolve","signUp","id","email","password","nickname","method","url","accessTokenRequired","additionalHeaders","data","pw","nick","apiResult","success","user","access_token","token","errorMsg","errorFieldName","subCode","duplicatedItems","duplicate","duplicatedItemsKor","badSemanticsReason","bad_semantics","Object","prototype","perty","call","hasOwnProperty","pwBadSemanticsReason","idBadSemanticsReason","code","catch","reason","signIn","idOrEmail","userData","left_chance","signOut","body","signout","userID","roles","JSON","parse","atob","role","rolePart","push","e","head","get","post","put","patch","delete","isRetry","indexOf","reqFetchOption","stringify","includes","key","value","entries","fetch","response","console","log","status","header","message","json","responseBody","startsWith","api","RETURNABLE_ERROR","name"],"mappings":"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","sourcesContent":["// (c) MUsoftware 2022\r\n'use strict';\r\n\r\nimport { FrostError } from '../common/error';\r\nimport { APIResult } from './api_response';\r\n\r\nconst HTTP_METHOD: Record<string, string> = {\r\n  // We will support only these methods for now\r\n  HEAD: 'HEAD',\r\n  GET: 'GET',\r\n  POST: 'POST',\r\n  PUT: 'PUT',\r\n  PATCH: 'PATCH',\r\n  DELETE: 'DELETE',\r\n};\r\n\r\nfunction role2Object(roleStr: string) {\r\n  const result: { [roleName: string]: string | boolean } = {};\r\n\r\n  roleStr.split(\"&\").forEach(function (part) {\r\n    const item = part.split(\"=\");\r\n    if (item.length == 2) {\r\n      result[item[0]] = decodeURIComponent(item[1]);\r\n      if (result[item[0]] === 'true' || result[item[0]] === 'false')\r\n        result[item[0]] = (result[item[0]] === 'true') ? true : false;\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\nfunction buf2hex(buffer: ArrayBufferLike) {\r\n  return [...new Uint8Array(buffer)]\r\n    .map(x => x.toString(16).padStart(2, '0'))\r\n    .join('');\r\n}\r\n\r\n// Generate random safe string\r\nfunction generateRandomSecureToken(bytes: number) {\r\n  const randArray = new Uint32Array(bytes);\r\n  window.crypto.getRandomValues(randArray);\r\n  return buf2hex(randArray);\r\n}\r\n\r\ninterface FrostAPIRequestArgumentTypes {\r\n  method: 'HEAD' | 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\r\n  url: string;\r\n  accessTokenRequired: boolean;\r\n  additionalHeaders: Record<string, unknown>;\r\n  data: Record<string, unknown>;\r\n  isRetry: boolean;\r\n}\r\n\r\nlet frostApiInstance: FrostAPI;\r\nclass FrostAPI {\r\n  // We only uses these http methods now.\r\n  static readonly #API_USED_METHOD = [\r\n    // HTTP_METHOD.HEAD,  // NOT ALLOWED YET!!!\r\n    HTTP_METHOD.GET,\r\n    HTTP_METHOD.POST,\r\n    HTTP_METHOD.PUT,\r\n    HTTP_METHOD.PATCH,\r\n    HTTP_METHOD.DELETE,\r\n  ]\r\n  // Refresh Token will be saved on cookie storage,\r\n  // And all of these attributes must be private.\r\n  readonly #BASE_URL = 'https://hyperion.mudev.cc/api/dev/';\r\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\r\n  // Although these HTTP Response status code means error,\r\n  // each routes have to handle these codes differently.\r\n  static readonly RETURNABLE_ERROR = [\r\n    // Actually, on 404, we need to filter http.not_found out only,\r\n    // and any other responses must be returned, but we can get subcode after response.json().\r\n    // And response.json() returns Promise<Any> and we cannot get subCode directly,\r\n    // so we need to handle 404 on second stage.\r\n    404, // http || resource not found\r\n    409, // already used / information mismatch, conflict\r\n    410, // resource gone\r\n    412, // resource prediction failed\r\n    422, // request.body.bad_semantics - email address validation failure, etc.\r\n  ];\r\n  // Default fetch options,\r\n  // we'll copy and modify this default option object on every request.\r\n  readonly #DEFAULT_FETCH_OPTION = {\r\n    mode: 'cors',\r\n    cache: 'no-cache',\r\n    credentials: 'same-origin',\r\n    redirect: 'follow',\r\n    referrerPolicy: 'strict-origin-when-cross-origin',\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n\r\n  // Account related properties\r\n  #csrfToken: string = '';\r\n  #accessToken: string = '';\r\n  #refreshResult?: APIResult['data'] | null = null;\r\n\r\n  constructor() {\r\n    if (frostApiInstance) return frostApiInstance;\r\n\r\n    this.#csrfToken = generateRandomSecureToken(32);\r\n    frostApiInstance = this;\r\n  }\r\n\r\n  #apiRequest({ method, url, accessTokenRequired, additionalHeaders, data, isRetry }: FrostAPIRequestArgumentTypes = {\r\n    method: HTTP_METHOD.GET,\r\n    url: '',\r\n    accessTokenRequired: false,\r\n    additionalHeaders: {},\r\n    data: {},\r\n    isRetry: false,\r\n  }): Promise<APIResult> {\r\n    // check if requested method is allowed\r\n    if (FrostAPI.#API_USED_METHOD.indexOf(method) == -1) { throw 'NOT_ALLOWED_METHOD'; }\r\n\r\n    // deep copy fetch option object\r\n    const reqFetchOption = JSON.parse(JSON.stringify(this.#DEFAULT_FETCH_OPTION));\r\n    reqFetchOption.method = method;\r\n\r\n    // only add body on POST/PATCH/PUT methods\r\n    if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1)\r\n      reqFetchOption.body = JSON.stringify(data);\r\n\r\n    // always send X-Csrf-Token. This won't be a security hole.\r\n    reqFetchOption.headers['X-Csrf-Token'] = this.#csrfToken;\r\n    // add access token on header if accessTokenRequired is true\r\n    if (accessTokenRequired) {\r\n      reqFetchOption.headers['Authorization'] = 'Bearer ' + this.#accessToken;\r\n    }\r\n\r\n    if (url.includes('account') || url.includes('admin')) {\r\n      reqFetchOption.credentials = 'include';\r\n    }\r\n\r\n    if (additionalHeaders)\r\n      for (const [key, value] of Object.entries(additionalHeaders))\r\n        reqFetchOption.headers[key] = value;\r\n\r\n    // // We need to handle HEAD method separately as this method doesn't return any body.\r\n    // if (method === HTTP_METHOD.HEAD) {\r\n    //   return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n\r\n    //   });\r\n    // }\r\n\r\n    return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n      console.log(response);\r\n      if (!response) {\r\n        // How is this possible???\r\n        throw new FrostError(\r\n          '서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.',\r\n          'fetchResult 객체가 undefined 또는 null입니다.', -1);\r\n      } else if (200 <= response.status && response.status <= 399) {  // this returns response.json()\r\n        // SUCCESS\r\n\r\n        if (response.status === 204) { // resource.deleted\r\n          // As 204 response means that resource is deleted and response does not include a response body,\r\n          // we need to make and return a fake response object.\r\n          return {\r\n            header: response.headers,\r\n            body: {\r\n              success: true,\r\n              code: 204,\r\n              subCode: 'resource.deleted',\r\n              message: 'Resource successfully deleted',\r\n            },\r\n          };\r\n        }\r\n\r\n        return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n      } else if (400 <= response.status && response.status <= 499) {\r\n        if (response.status === 401) {  // this \"possibly\" returns response.json()\r\n          // This code can be returned on both resource and account related routes,\r\n          // and we need to handle those separately.\r\n          //\r\n          // Possible subCodes:\r\n          // > wrong password / account locked / account deactivated (== maybe one of account related routes?)\r\n          //    - These will be raised when we signing in.\r\n          //      We need to throw a proper FrostError.\r\n          // > token not given / token expired / token invalid\r\n          //    - We need to try refreshing access token and retry this.\r\n          //      If access token refresh fails, then raise errors.\r\n          //\r\n          // If the error-occurred-request is related to resource routes,\r\n          // then we'll refresh access token and and retry the request.\r\n          // and if it fails, then we'll throw FrostError.\r\n          //\r\n          // If the error-occurred-request is related to account routes,\r\n          // then we need to parse subCode, so we'll handle this error on second stage.\r\n          if (!url.startsWith('account/')) {\r\n            if (!isRetry)\r\n              return this.refreshAuthentications().then((api) => api.#apiRequest({\r\n                method: method,\r\n                url: url,\r\n                accessTokenRequired: accessTokenRequired,\r\n                additionalHeaders: additionalHeaders, data: data,\r\n                isRetry: true,\r\n              }));\r\n            throw new FrostError(\r\n              '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n              '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n              response.status);\r\n          }\r\n\r\n          return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n        } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\r\n          // this \"possibly\" returns response.json().\r\n          // See RETURNABLE_ERROR for more details.\r\n          return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n        } else if (response.status === 403) {\r\n          // Requested action was forbidden\r\n          throw new FrostError(\r\n            '해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 405) {\r\n          // Method not permitted\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 415) {\r\n          // requested response content-type not supported\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 429) {\r\n          throw new FrostError(\r\n            '요청이 너무 빈번해요,\\n조금 천천히 진행해주세요.',\r\n            `429 rate limit`, 429);\r\n        } else {\r\n          // unknown client-fault error\r\n          throw new FrostError(\r\n            '알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        }\r\n      } else {  // HTTP status code is more than 500(server error)\r\n        throw new FrostError(\r\n          '서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `statusCode가 ${response.status}입니다.`, response.status);\r\n      }\r\n\r\n      // This is just for type-checking, response.status won't be less than 200, right?\r\n      // ...right? please... no......\r\n      return response.json().then((responseBody) => ({ header: response.headers, body: responseBody }));\r\n    }).then((response: { header: Record<string, unknown>, body: Record<string, unknown> } | APIResult) => {\r\n      console.log(response);\r\n      if (response instanceof APIResult)\r\n        return response;\r\n\r\n      const apiResult = new APIResult(response);\r\n      if (apiResult.code === 404 && apiResult.subCode === 'http.not_found') {\r\n        throw new FrostError(\r\n          '무엇을 할 지 모르는 요청이에요,\\n사이트 개발자에게 문의해주세요ㅠㅜ',\r\n          'http.not_found입니다.', apiResult.code, false);\r\n      }\r\n      // else if (apiResult.code === 401) {\r\n      //   // Possible subCodes:\r\n      //   // > token not given / token expired / token invalid\r\n      //   //   (== resource related routes, !!!ALREADY HANDLED!!!)\r\n      //   //    - We need to try refreshing access token and retry this.\r\n      //   //      If access token refresh fails, then raise errors.\r\n      //   // > wrong password / account locked / account deactivated\r\n      //   //   (== account related routes, we need to handle this here.)\r\n      //   //    - These will be raised when we signing in.\r\n      //   //      We need to throw a proper FrostError.\r\n      //   throw new FrostError(\r\n      //     '로그인을 할 수 없어요.',\r\n      //     '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n      //     apiResult.code, true, apiResult);\r\n      // }\r\n\r\n      return apiResult;\r\n    }).catch((reason) => {\r\n      // catch all exceptions and change it to FrostError\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  isSignedIn(checkNetwork = false) {\r\n    if (checkNetwork)\r\n      return this.refreshAuthentications().then((_) => true, (_) => false);\r\n\r\n    return Promise.resolve((this.#accessToken) ? true : false);\r\n  }\r\n\r\n  signUp(id: string, email: string, password: string, nickname: string) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/signup',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, data: { id: id, pw: password, nick: nickname, email: email }\r\n    }).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n\r\n      // We need to generate error message from the subcode.\r\n      let errorMsg = '';\r\n      let errorFieldName = '';\r\n      switch (apiResult.subCode) {\r\n        case 'user.already_used': {\r\n          const duplicatedItems: string = apiResult.data.duplicate[0];\r\n          let duplicatedItemsKor = '';\r\n          switch (duplicatedItems) {\r\n            case 'email':\r\n              errorFieldName = 'email';\r\n              duplicatedItemsKor = '이메일은';\r\n              break;\r\n            case 'id':\r\n              errorFieldName = 'id';\r\n              duplicatedItemsKor = '아이디는';\r\n              break;\r\n            case 'nick':\r\n            case 'nickname':\r\n              errorFieldName = 'nick';\r\n              duplicatedItemsKor = '별명은';\r\n              break;\r\n            case 'pw':\r\n            case 'password':\r\n              // WTF??? HOW??????\r\n              errorFieldName = 'pw';\r\n              duplicatedItemsKor = '비밀번호는';\r\n              break;\r\n            default:\r\n              duplicatedItemsKor = '정보는';\r\n              break;\r\n          }\r\n          errorMsg = `입력하신 ${duplicatedItemsKor} 이미 다른 계정에서 사용 중이에요.`;\r\n          break;\r\n        }\r\n        case 'request.body.bad_semantics': {\r\n          // errorMsg = '입력하신 정보로 회원가입을 하실 수 없어요.\\n';\r\n          const badSemanticsReason: Record<string, unknown> = apiResult.data.bad_semantics[0];\r\n          if (Object.prototype.perty.call(badSemanticsReason, 'email')) {\r\n            errorFieldName = 'email';\r\n            errorMsg = '올바른 이메일 형식이 아니에요.';\r\n          } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'pw')) {\r\n            const pwBadSemanticsReason: string = badSemanticsReason.pw;\r\n            switch (pwBadSemanticsReason) {\r\n              case 'TOO_SHORT':\r\n                errorMsg = '비밀번호가 너무 짧아요,\\n'; break;\r\n              case 'TOO_LONG':\r\n                errorMsg = '1024자가 넘으면 비밀번호로 쓰기에 너무 길지 않을까요?\\n'; break;\r\n              case 'NEED_MORE_CHAR_TYPE':\r\n                errorMsg = '비밀번호가 너무 단순해요,\\n'; break;\r\n              case 'FORBIDDEN_CHAR':\r\n                errorMsg = '비밀번호에 쉽게 입력할 수 없는 문자가 들어있어요,\\n'; break;\r\n              default:\r\n                errorMsg = '사용할 수 있는 비밀번호가 아니에요,\\n'; break;\r\n            }\r\n            errorFieldName = 'pw';\r\n            // errorMsg += '비밀번호는 영문 대소문자/숫자/특수문자 중 2가지를 혼용해서 최소 9자로 입력해주세요.';\r\n          } else if (Object.prototype.hasOwnProperty.call(badSemanticsReason, 'id')) {\r\n            const idBadSemanticsReason: string = badSemanticsReason.id;\r\n            switch (idBadSemanticsReason) {\r\n              case 'TOO_SHORT':\r\n                errorMsg = '아이디가 너무 짧아요,\\n'; break;\r\n              case 'TOO_LONG':\r\n                errorMsg = '아이디가 너무 길어요,\\n'; break;\r\n              case 'FORBIDDEN_CHAR':\r\n                errorMsg = '아이디에 사용할 수 없는 문자가 들어있어요,\\n'; break;\r\n              default:\r\n                errorMsg = '사용할 수 있는 아이디가 아니에요,\\n'; break;\r\n            }\r\n            errorFieldName = 'id';\r\n            errorMsg += '아이디는 4 ~ 47자 사이의 길이로 입력해주세요.';\r\n          } else {\r\n            errorMsg += '정보가 올바르지 않아요,\\n새로고침 후 다시 시도해주세요.';\r\n          }\r\n          break;\r\n        }\r\n        default:\r\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.';\r\n      }\r\n\r\n      throw new FrostError(\r\n        errorMsg,\r\n        `account/signup=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n        apiResult.code, true, apiResult, errorFieldName);\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#accessToken = '';\r\n      this.#csrfToken = generateRandomSecureToken(32);\r\n      this.#refreshResult = null;\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  signIn(idOrEmail: string, password: string) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/signin',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, data: { id: idOrEmail, pw: password },\r\n    }).then((apiResult: APIResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#refreshResult = apiResult.data;\r\n        this.userData\r\n        return this;\r\n      }\r\n\r\n      let errorMsg = '';\r\n      let errorFieldName = '';\r\n      if (!apiResult)\r\n        throw new FrostError(\r\n          '알 수 없는 오류가 발생했어요,\\n10분 후에 다시 시도해주세요.',\r\n          `account/signin=>!apiResult`, -1);\r\n\r\n      // If apiResponse is in FrostError obj, We can generate error message from the subcode.\r\n      switch (apiResult.subCode) {\r\n        case 'user.not_found':\r\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n          break;\r\n        case 'user.wrong_password':\r\n          errorFieldName = 'pw'\r\n          errorMsg = '비밀번호가 맞지 않습니다, 비밀번호를 다시 입력해주세요.\\n';\r\n          errorMsg += `(${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\r\n          break;\r\n        case 'user.locked':\r\n          errorMsg = '계정이 잠겼습니다, 관리자에게 연락해주세요.\\n';\r\n          errorMsg += `(잠긴 이유: ${apiResult.data.reason})`;\r\n          break;\r\n        case 'user.deactivated':\r\n          errorMsg = '계정이 폐쇄되었습니다, 관리자에게 연락해주세요.\\n'\r\n          errorMsg += `(폐쇄된 이유: ${apiResult.data.reason})`;\r\n          break;\r\n        default:\r\n          errorMsg = '알 수 없는 오류가 발생했어요,\\n10분 후 새로고침을 한 후에 다시 시도해주세요.';\r\n      }\r\n\r\n      throw new FrostError(\r\n        errorMsg,\r\n        `account/signin=>response.success=false\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n        apiResult.code, true, apiResult, errorFieldName);\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#accessToken = '';\r\n      this.#csrfToken = generateRandomSecureToken(32);\r\n      this.#refreshResult = null;\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  signOut() {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/signout',\r\n      accessTokenRequired: false,\r\n      additionalHeaders: {}, body: { signout: true },\r\n    }).then(\r\n      () => {\r\n        // Actually, this action won't fail, except when the server is dead.\r\n        // Just reset the csrf token and access token.\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#accessToken = '';\r\n        this.#refreshResult = null;\r\n        return this;\r\n      });\r\n  }\r\n\r\n  refreshAuthentications() {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: 'account/refresh',\r\n      accessTokenRequired: false\r\n    }\r\n    ).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n      throw new FrostError(\r\n        '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n        `account/refresh=>response.success = false입니다. code = ${apiResult.code}`,\r\n        400, true, apiResult);\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#accessToken = '';\r\n      this.#csrfToken = generateRandomSecureToken(32);\r\n      this.#refreshResult = null;\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  get userID() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user.id;\r\n  }\r\n\r\n  get userData() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user;\r\n  }\r\n\r\n  get roles() {\r\n    if (!this.#accessToken)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    const result: Array<{ [roleName: string]: string | boolean; }> = [];\r\n    try {\r\n      const token = JSON.parse(atob(this.#accessToken.split('.')[1]));\r\n      JSON.parse(token.role).forEach((rolePart: string) => {\r\n        if (rolePart === 'admin') return;\r\n        result.push(role2Object(rolePart));\r\n      });\r\n    } catch (e) {\r\n      /* tslint:disable:no-empty */\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  head(url: string, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.HEAD,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders\r\n    });\r\n  }\r\n  get(url: string, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.GET,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders\r\n    });\r\n  }\r\n  post(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.POST,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders,\r\n      data: data\r\n    });\r\n  }\r\n  put(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.PUT,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders,\r\n      data: data\r\n    });\r\n  }\r\n  patch(url: string, data: Record<string, unknown> = {}, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.PATCH,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders,\r\n      data: data\r\n    });\r\n  }\r\n  delete(url: string, accessTokenRequired = false, additionalHeaders = {}) {\r\n    return this.#apiRequest({\r\n      method: HTTP_METHOD.DELETE,\r\n      url: url,\r\n      accessTokenRequired: accessTokenRequired,\r\n      additionalHeaders: additionalHeaders\r\n    });\r\n  }\r\n}\r\n\r\nexport default FrostAPI;\r\n"]},"metadata":{},"sourceType":"module"}