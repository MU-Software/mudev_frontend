{"ast":null,"code":"import { Manager } from 'socket.io-client';\nimport { FrostError } from 'src/common/error';\nimport FrostAPI from 'src/network/api';\n\n// Generate random safe string, borrowed from FrostAPI implementation\nconst generateRandomSecureToken = bytes => {\n  const randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}; // From https://stackoverflow.com/a/40031979\n// Buffer to hex, also borrowed from FrostAPI implementation\n\n\nconst buf2hex = buffer => {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n};\n\nlet playCoSocketIOHandlerInstance;\nexport class PlayCoSocketIOHandler {\n  constructor() {\n    this.socketIoMgr = void 0;\n    this.socketIo = void 0;\n    this.sioToken = void 0;\n    this.sioTokenExpiresAt = void 0;\n    this.csrfToken = void 0;\n    this.sessionId = void 0;\n    this.socketIoEventHandler = {\n      connect: () => {\n        this.sessionId = this.socketIo.id; // Get SIO Token and register session\n\n        this.refreshSIOToken(true);\n      },\n      reconnect: () => {\n        // Same as connect\n        this.sessionId = this.socketIo.id; // Get SIO Token and register session\n\n        this.refreshSIOToken(true);\n      },\n      disconnect: reason => {\n        this.sessionId = '';\n        this.sioToken = '';\n        this.sioTokenExpiresAt = new Date();\n        this.csrfToken = generateRandomSecureToken(32);\n      },\n      REQUEST_RESPONSE_0: data => {\n        console.log('Unknown response received! Received data >>> ---------------');\n        console.log(data);\n        console.log('------------------------------------------------------------');\n      },\n      PLAYLIST_USER_ENTERED: data => {//\n      },\n      PLAYLIST_USER_EXITED: data => {//\n      },\n      PLAYLIST_MODIFIED: data => {//\n      },\n      OFFICIAL_ANNOUNCEMENT: data => {\n        // RESERVED\n        console.log('OFFICIAL_ANNOUNCEMENT event received! Received data >>> ----');\n        console.log(data);\n        console.log('------------------------------------------------------------');\n      }\n    };\n    if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\n    this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\n      reconnectionDelayMax: 5000,\n      path: '/api/dev/ws',\n      transports: ['websocket'],\n      upgrade: false,\n      forceNew: false,\n      autoConnect: false,\n      closeOnBeforeunload: false\n    });\n    this.socketIo = this.socketIoMgr.socket('/playco_ws');\n\n    for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\n      this.socketIo.on(key, value);\n    }\n\n    playCoSocketIOHandlerInstance = this;\n  }\n\n  emitEvent(event, data = undefined, onResponse = undefined) {\n    const requestId = generateRandomSecureToken(16);\n    if (data) data['requestId'] = requestId;\n    if (onResponse) this.socketIo.once(`REQUEST_RESPONSE_${requestId}`, onResponse);\n    this.socketIo.emit(event, data);\n  }\n\n  refreshSIOToken(isOnConnect = false) {\n    // Check if Socket.IO is connected, and every statement is fulfilled.\n    if (!this.socketIo.connected || !this.sessionId) {\n      this.disconnect();\n      return Promise.reject(new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결에 실패했어요.', `this.socketIo.connected = ${this.socketIo.connected}, !this.sessionId = ${this.sessionId}`, -1, false));\n    } // We need to get a new SIO Token by request.\n\n\n    this.csrfToken = generateRandomSecureToken(32);\n    return new FrostAPI().post('playco/socketio/auth', {\n      'sid': this.sessionId,\n      'sio_csrf_token': this.csrfToken\n    }, true).then(result => {\n      // Get SIO token from response\n      const sioTokenData = result.data.sio_token;\n      this.sioToken = sioTokenData;\n      this.sioTokenExpiresAt = new Date(sioTokenData.exp); // Register session if this function is called on SocketIO onConnect event.\n\n      if (isOnConnect) {\n        this.emitEvent('playco_connect', {\n          sio_token: this.sioToken,\n          sio_csrf_token: this.csrfToken\n        }, response => {\n          if (response.success) {// Request success\n          } else {\n            // Request failed = Session creation failed\n            throw new FrostError(response.message, `sio:playco_connect=>response.success=false, ${response.code}`);\n          }\n        });\n      }\n    }, reason => {\n      console.log(reason);\n      console.log(reason.debugMessage); // Failed to get SIO token, disconnect from SocketIO.\n\n      this.disconnect(); // Continue onRejected.\n\n      reason.message = '재생목록의 실시간 정보를 받아오기 위한 연결을 인증하는데 실패했어요.';\n      throw reason;\n    });\n  }\n\n  connect() {\n    if (!this.socketIo.connected) // Connect SocketIO if it's not connected.\n      // This will fire this.socketIoEventHandler.connect if the connection is successfully established.\n      this.socketIo.connect();\n  }\n\n  disconnect() {\n    if (this.socketIo.connected) this.socketIo.disconnect();\n  }\n\n  enterPlaylist(playlistId, hook) {\n    if (!this.socketIo.connected) {\n      return Promise.reject(new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.', 'enterPlaylist->this.socketIo.connected == false', -1, false));\n    }\n\n    const reqData = {\n      eventName: 'playlist_enter',\n      data: {\n        playlist_id: playlistId,\n        sio_token: this.sioToken,\n        sio_csrf_token: this.csrfToken\n      },\n      onResponse: response => {\n        if (response.success) {// Request success\n        } else {// Request failed\n          }\n      }\n    };\n  }\n\n  leavePlaylist(playlistId) {\n    if (!this.socketIo.connected) {\n      return Promise.reject(new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.', 'leavePlaylist->this.socketIo.connected == false', -1, false));\n    }\n\n    const reqData = {\n      eventName: 'playlist_leave',\n      data: {\n        playlist_id: playlistId,\n        sio_token: this.sioToken,\n        sio_csrf_token: this.csrfToken\n      },\n      onResponse: response => {\n        if (response.success) {// Request success\n        } else {// Request failed\n          }\n      }\n    };\n  }\n\n  setSessionCurrentPlaying(playlistId, currentPlaying) {\n    if (!this.socketIo.connected) {\n      return Promise.reject(new FrostError('재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.', 'setSessionCurrentPlaying->this.socketIo.connected == false', -1, false));\n    }\n\n    const reqData = {\n      eventName: 'playlist_set_status',\n      data: {\n        sio_token: this.sioToken,\n        sio_csrf_token: this.csrfToken,\n        playlist_id: playlistId,\n        currently_playing: currentPlaying\n      },\n      onResponse: undefined\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/ui/page/playco/playco/sio.ts"],"names":["Manager","FrostError","FrostAPI","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","playCoSocketIOHandlerInstance","PlayCoSocketIOHandler","constructor","socketIoMgr","socketIo","sioToken","sioTokenExpiresAt","csrfToken","sessionId","socketIoEventHandler","connect","id","refreshSIOToken","reconnect","disconnect","reason","Date","REQUEST_RESPONSE_0","data","console","log","PLAYLIST_USER_ENTERED","PLAYLIST_USER_EXITED","PLAYLIST_MODIFIED","OFFICIAL_ANNOUNCEMENT","reconnectionDelayMax","path","transports","upgrade","forceNew","autoConnect","closeOnBeforeunload","socket","key","value","Object","entries","on","emitEvent","event","undefined","onResponse","requestId","once","emit","isOnConnect","connected","Promise","reject","post","then","result","sioTokenData","sio_token","exp","sio_csrf_token","response","success","message","code","debugMessage","enterPlaylist","playlistId","hook","reqData","eventName","playlist_id","leavePlaylist","setSessionCurrentPlaying","currentPlaying","currently_playing"],"mappings":"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","sourcesContent":["import { io, Manager } from 'socket.io-client';\r\nimport { FrostError } from 'src/common/error';\r\nimport FrostAPI from 'src/network/api';\r\n\r\ninterface PlayCoSocketIOResponse {\r\n    code: number;\r\n    subCode: string;\r\n    success: boolean;\r\n    message: string;\r\n    data: Record<string, unknown> | undefined;\r\n}\r\n\r\n// Generate random safe string, borrowed from FrostAPI implementation\r\nconst generateRandomSecureToken = (bytes: number) => {\r\n    const randArray = new Uint32Array(bytes);\r\n    window.crypto.getRandomValues(randArray);\r\n    return buf2hex(randArray);\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\n// Buffer to hex, also borrowed from FrostAPI implementation\r\nconst buf2hex = (buffer: ArrayBufferLike) => {\r\n    return [...new Uint8Array(buffer)]\r\n        .map(x => x.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\nlet playCoSocketIOHandlerInstance: PlayCoSocketIOHandler;\r\nexport class PlayCoSocketIOHandler {\r\n    private socketIoMgr: io.Manager;\r\n    private socketIo: io;\r\n\r\n    private sioToken: string;\r\n    private sioTokenExpiresAt: Date;\r\n    private csrfToken: string;\r\n    private sessionId: string;\r\n\r\n    private socketIoEventHandler: Record<string, () => void> = {\r\n        connect: () => {\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            // Get SIO Token and register session\r\n            this.refreshSIOToken(true);\r\n        },\r\n        reconnect: () => {\r\n            // Same as connect\r\n            this.sessionId = this.socketIo.id;\r\n\r\n            // Get SIO Token and register session\r\n            this.refreshSIOToken(true);\r\n        },\r\n        disconnect: (reason) => {\r\n            this.sessionId = '';\r\n            this.sioToken = '';\r\n            this.sioTokenExpiresAt = new Date();\r\n            this.csrfToken = generateRandomSecureToken(32);\r\n        },\r\n        REQUEST_RESPONSE_0: (data: PlayCoSocketIOResponse | undefined) => {\r\n            console.log('Unknown response received! Received data >>> ---------------');\r\n            console.log(data);\r\n            console.log('------------------------------------------------------------');\r\n        },\r\n        PLAYLIST_USER_ENTERED: (data: PlayCoSocketIOResponse) => {\r\n            //\r\n        },\r\n        PLAYLIST_USER_EXITED: (data: PlayCoSocketIOResponse) => {\r\n            //\r\n        },\r\n        PLAYLIST_MODIFIED: (data: PlayCoSocketIOResponse) => {\r\n            //\r\n        },\r\n        OFFICIAL_ANNOUNCEMENT: (data: PlayCoSocketIOResponse | undefined) => {\r\n            // RESERVED\r\n            console.log('OFFICIAL_ANNOUNCEMENT event received! Received data >>> ----');\r\n            console.log(data)\r\n            console.log('------------------------------------------------------------');\r\n        },\r\n    };\r\n\r\n    constructor() {\r\n        if (playCoSocketIOHandlerInstance) return playCoSocketIOHandlerInstance;\r\n\r\n        this.socketIoMgr = new Manager('https://hyperion.mudev.cc', {\r\n            reconnectionDelayMax: 5000,\r\n            path: '/api/dev/ws',\r\n            transports: ['websocket',],\r\n            upgrade: false,\r\n\r\n            forceNew: false,\r\n            autoConnect: false,\r\n\r\n            closeOnBeforeunload: false,\r\n        });\r\n\r\n        this.socketIo = this.socketIoMgr.socket('/playco_ws');\r\n        for (const [key, value] of Object.entries(this.socketIoEventHandler)) {\r\n            this.socketIo.on(key, value);\r\n        }\r\n\r\n        playCoSocketIOHandlerInstance = this;\r\n    }\r\n\r\n    private emitEvent(\r\n        event: string,\r\n        data: Record<string, unknown> | undefined = undefined,\r\n        onResponse: (response: PlayCoSocketIOResponse) => void | undefined = undefined) {\r\n\r\n        const requestId = generateRandomSecureToken(16);\r\n        if (data)\r\n            data['requestId'] = requestId;\r\n\r\n        if (onResponse)\r\n            this.socketIo.once(`REQUEST_RESPONSE_${requestId}`, onResponse);\r\n\r\n        this.socketIo.emit(event, data);\r\n    }\r\n\r\n    private refreshSIOToken(isOnConnect = false) {\r\n        // Check if Socket.IO is connected, and every statement is fulfilled.\r\n        if (!this.socketIo.connected || !this.sessionId) {\r\n            this.disconnect();\r\n            return Promise.reject(new FrostError(\r\n                '재생목록의 실시간 정보를 받아오기 위한 연결에 실패했어요.',\r\n                `this.socketIo.connected = ${this.socketIo.connected}, !this.sessionId = ${this.sessionId}`,\r\n                -1, false\r\n            ));\r\n        }\r\n\r\n        // We need to get a new SIO Token by request.\r\n        this.csrfToken = generateRandomSecureToken(32);\r\n        return (new FrostAPI())\r\n            .post('playco/socketio/auth', { 'sid': this.sessionId, 'sio_csrf_token': this.csrfToken, }, true)\r\n            .then(\r\n                (result) => {\r\n                    // Get SIO token from response\r\n                    const sioTokenData: { 'exp': string, 'token': string } = result.data.sio_token;\r\n                    this.sioToken = sioTokenData;\r\n                    this.sioTokenExpiresAt = new Date(sioTokenData.exp);\r\n\r\n                    // Register session if this function is called on SocketIO onConnect event.\r\n                    if (isOnConnect) {\r\n                        this.emitEvent(\r\n                            'playco_connect',\r\n                            {\r\n                                sio_token: this.sioToken,\r\n                                sio_csrf_token: this.csrfToken,\r\n                            },\r\n                            (response: PlayCoSocketIOResponse) => {\r\n                                if (response.success) {\r\n                                    // Request success\r\n                                } else {\r\n                                    // Request failed = Session creation failed\r\n                                    throw new FrostError(\r\n                                        response.message, `sio:playco_connect=>response.success=false, ${response.code}`\r\n                                    )\r\n                                }\r\n                            }\r\n                        );\r\n                    }\r\n                },\r\n                (reason: FrostError) => {\r\n                    console.log(reason);\r\n                    console.log(reason.debugMessage);\r\n\r\n                    // Failed to get SIO token, disconnect from SocketIO.\r\n                    this.disconnect();\r\n\r\n                    // Continue onRejected.\r\n                    reason.message = '재생목록의 실시간 정보를 받아오기 위한 연결을 인증하는데 실패했어요.';\r\n                    throw reason;\r\n                },\r\n            );\r\n    }\r\n\r\n    connect() {\r\n        if (!this.socketIo.connected) // Connect SocketIO if it's not connected.\r\n            // This will fire this.socketIoEventHandler.connect if the connection is successfully established.\r\n            this.socketIo.connect();\r\n    }\r\n\r\n    disconnect() {\r\n        if (this.socketIo.connected)\r\n            this.socketIo.disconnect();\r\n    }\r\n\r\n    enterPlaylist(playlistId: number, hook: (unknown) => void) {\r\n        if (!this.socketIo.connected) {\r\n            return Promise.reject(new FrostError(\r\n                '재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n                'enterPlaylist->this.socketIo.connected == false', -1, false));\r\n        }\r\n\r\n        const reqData = {\r\n            eventName: 'playlist_enter',\r\n            data: {\r\n                playlist_id: playlistId,\r\n                sio_token: this.sioToken,\r\n                sio_csrf_token: this.csrfToken,\r\n            },\r\n            onResponse: (response: PlayCoSocketIOResponse) => {\r\n                if (response.success) {\r\n                    // Request success\r\n                } else {\r\n                    // Request failed\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    leavePlaylist(playlistId: number) {\r\n        if (!this.socketIo.connected) {\r\n            return Promise.reject(new FrostError(\r\n                '재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n                'leavePlaylist->this.socketIo.connected == false', -1, false));\r\n        }\r\n\r\n        const reqData = {\r\n            eventName: 'playlist_leave',\r\n            data: {\r\n                playlist_id: playlistId,\r\n                sio_token: this.sioToken,\r\n                sio_csrf_token: this.csrfToken,\r\n            },\r\n            onResponse: (response: PlayCoSocketIOResponse) => {\r\n                if (response.success) {\r\n                    // Request success\r\n                } else {\r\n                    // Request failed\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    setSessionCurrentPlaying(playlistId: number, currentPlaying: number) {\r\n        if (!this.socketIo.connected) {\r\n            return Promise.reject(new FrostError(\r\n                '재생목록의 실시간 정보를 받아오기 위한 연결이 끊어졌어요,\\n키보드에서 \\'F5\\' 버튼을 눌러서 새로고침을 해 주세요.',\r\n                'setSessionCurrentPlaying->this.socketIo.connected == false', -1, false));\r\n        }\r\n\r\n        const reqData = {\r\n            eventName: 'playlist_set_status',\r\n            data: {\r\n                sio_token: this.sioToken,\r\n                sio_csrf_token: this.csrfToken,\r\n                playlist_id: playlistId,\r\n                currently_playing: currentPlaying,\r\n            },\r\n            onResponse: undefined,\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}