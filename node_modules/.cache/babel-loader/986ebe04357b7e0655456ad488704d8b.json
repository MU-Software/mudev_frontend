{"ast":null,"code":"// (c) MUsoftware 2022\n'use strict';\n\nimport _classPrivateFieldLooseBase from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/.yarn/cache/@babel-runtime-npm-7.12.1-b069f70b16-fb4b4c8f70.zip/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\nimport { FrostError } from '../common/error';\nimport { APIResult } from './api_response';\nconst HTTP_METHOD = {\n  // We will support only these methods for now\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  PATCH: 'PATCH',\n  DELETE: 'DELETE'\n};\n\nfunction role2Object(roleStr) {\n  let result = {};\n  roleStr.split(\"&\").forEach(function (part) {\n    let item = part.split(\"=\");\n\n    if (item.length == 2) {\n      result[item[0]] = decodeURIComponent(item[1]);\n      if (result[item[0]] === 'true' || result[item[0]] === 'false') result[item[0]] = result[item[0]] === 'true' ? true : false;\n    }\n  });\n  return result;\n} // From https://stackoverflow.com/a/40031979\n\n\nfunction buf2hex(buffer) {\n  return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n} // Generate random safe string\n\n\nfunction generateRandomSecureToken(bytes) {\n  let randArray = new Uint32Array(bytes);\n  window.crypto.getRandomValues(randArray);\n  return buf2hex(randArray);\n}\n\nlet frostApiInstance;\n\nvar _API_USED_METHOD = /*#__PURE__*/_classPrivateFieldLooseKey(\"API_USED_METHOD\");\n\nvar _BASE_URL = /*#__PURE__*/_classPrivateFieldLooseKey(\"BASE_URL\");\n\nvar _DEFAULT_FETCH_OPTION = /*#__PURE__*/_classPrivateFieldLooseKey(\"DEFAULT_FETCH_OPTION\");\n\nvar _csrfToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"csrfToken\");\n\nvar _accessToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"accessToken\");\n\nvar _refreshResult = /*#__PURE__*/_classPrivateFieldLooseKey(\"refreshResult\");\n\nvar _apiRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"apiRequest\");\n\nclass FrostAPI {\n  // We only uses these http methods now.\n  // Refresh Token will be saved on cookie storage,\n  // And all of these attributes must be private.\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\n  // Although these HTTP Response status code means error,\n  // each routes have to handle these codes differently.\n  // Default fetch options,\n  // we'll copy and modify this default option object on every request.\n  // Account related properties\n  constructor() {\n    Object.defineProperty(this, _apiRequest, {\n      value: _apiRequest2\n    });\n    Object.defineProperty(this, _BASE_URL, {\n      writable: true,\n      value: 'https://hyperion.mudev.cc/api/dev/'\n    });\n    Object.defineProperty(this, _DEFAULT_FETCH_OPTION, {\n      writable: true,\n      value: {\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'same-origin',\n        redirect: 'follow',\n        referrerPolicy: 'strict-origin-when-cross-origin',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }\n    });\n    Object.defineProperty(this, _csrfToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _accessToken, {\n      writable: true,\n      value: ''\n    });\n    Object.defineProperty(this, _refreshResult, {\n      writable: true,\n      value: null\n    });\n    if (frostApiInstance) return frostApiInstance;\n    _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n    frostApiInstance = this;\n  }\n\n  isSignedIn(checkNetwork = false) {\n    if (checkNetwork) this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] ? true : false;\n  }\n\n  signUp(id, email, password, nickname) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signup', false, {\n      id: id,\n      pw: password,\n      nick: nickname,\n      email: email\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n\n      throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signIn(idOrEmail, password) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signin', false, {\n      id: idOrEmail,\n      pw: password\n    }).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      } // We need to generate error message from the subcode.\n\n\n      let errorMsg = '';\n\n      switch (apiResult) {\n        case 'user.not_found':\n          errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\n          break;\n\n        case 'user.wrong_password':\n          errorMsg = '비밀번호가 맞지 않습니다,\\n비밀번호를 다시 입력해주세요.\\n';\n          errorMsg += `(만약 ${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\n          break;\n\n        case 'user.locked':\n          errorMsg = '계정이 잠겼습니다,\\n관리자에게 연락해주세요.\\n';\n          let accountLockReason = apiResult.data.reason;\n          errorMsg += `(잠긴 사유: ${accountLockReason})`;\n          break;\n\n        case 'user.deactivated':\n          errorMsg = '계정이 폐쇄되었습니다.,\\n관리자에게 연락해주세요.';\n          let accountDeactivateReason = apiResult.data.reason;\n          errorMsg += `(폐쇄된 사유: ${accountDeactivateReason})`;\n          break;\n      }\n\n      throw new FrostError(errorMsg, `account/refresh=>response.success = false입니다.\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`, apiResult.code);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  signout() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/signout', false, {\n      signout: true\n    }).then(apiResult => {\n      // Actually, this action won't fail, except when the server is dead.\n      // Just reset the csrf token and access token.\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      return this;\n    });\n  }\n\n  refreshAuthentications() {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, 'account/refresh', false).then(apiResult => {\n      if (apiResult.success) {\n        _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = apiResult.data.user.access_token.token;\n        _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = apiResult.data;\n        return this;\n      }\n\n      throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\n    }).catch(reason => {\n      // as reason might be a 'FrostError',\n      // we can just reset auth data and throw it directly.\n      _classPrivateFieldLooseBase(this, _accessToken)[_accessToken] = '';\n      _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken] = generateRandomSecureToken(32);\n      _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult] = null;\n      throw reason;\n    });\n  }\n\n  get userID() {\n    var _classPrivateFieldLoo;\n\n    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.user)) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    return _classPrivateFieldLooseBase(this, _refreshResult)[_refreshResult].user.id;\n  }\n\n  get roles() {\n    if (!_classPrivateFieldLooseBase(this, _accessToken)[_accessToken]) // This can cause FrostError, and this is intended.\n      this.refreshAuthentications();\n    let result = [];\n\n    try {\n      let token = JSON.parse(atob(_classPrivateFieldLooseBase(this, _accessToken)[_accessToken].split('.')[1]));\n      JSON.parse(token.role).forEach(rolePart => {\n        if (rolePart === 'admin') return;\n        result.push(role2Object(rolePart));\n      });\n    } catch (e) {}\n\n    return result;\n  }\n\n  get(url, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.GET, url, accessTokenRequired);\n  }\n\n  post(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.POST, url, accessTokenRequired, data);\n  }\n\n  put(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.PUT, url, accessTokenRequired, data);\n  }\n\n  patch(url, data = {}, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.PATCH, url, accessTokenRequired, data);\n  }\n\n  delete(url, accessTokenRequired = false) {\n    return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](HTTP_METHOD.DELETE, url, accessTokenRequired);\n  }\n\n}\n\nfunction _apiRequest2(method = HTTP_METHOD.GET, url = '', accessTokenRequired = false, data = {}) {\n  // check if requested method is allowed\n  if (_classPrivateFieldLooseBase(FrostAPI, _API_USED_METHOD)[_API_USED_METHOD].indexOf(method) == -1) {\n    throw 'NOT_ALLOWED_METHOD';\n  } // deep copy fetch option object\n\n\n  let reqFetchOption = JSON.parse(JSON.stringify(_classPrivateFieldLooseBase(this, _DEFAULT_FETCH_OPTION)[_DEFAULT_FETCH_OPTION]));\n  reqFetchOption.method = method; // only add body on POST/PATCH/PUT methods\n\n  if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1) reqFetchOption.body = JSON.stringify(data); // always send X-Csrf-Token. This won't be a security hole.\n\n  reqFetchOption.headers['X-Csrf-Token'] = _classPrivateFieldLooseBase(this, _csrfToken)[_csrfToken]; // add access token on header if accessTokenRequired is true\n\n  if (accessTokenRequired) {\n    reqFetchOption.headers['Authorization'] = 'Bearer ' + _classPrivateFieldLooseBase(this, _accessToken)[_accessToken];\n  }\n\n  if (url.includes('account') || url.includes('admin')) {\n    reqFetchOption.credentials = 'include';\n  }\n\n  return fetch(_classPrivateFieldLooseBase(this, _BASE_URL)[_BASE_URL] + url, reqFetchOption).then(response => {\n    if (!response) {\n      // How is this possible???\n      throw new FrostError('서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.', 'fetchResult 객체가 undefined 또는 null입니다.', -1);\n    } else if (200 <= response.status && response.status <= 399) {\n      // this returns response.json()\n      // SUCCESS\n      return response.json();\n    } else if (400 <= response.status && response.status <= 499) {\n      if (response.status === 401) {\n        // this \"possibly\" returns response.json()\n        // token not given / token expired / token invalid\n        // wrong password / account locked / account deactivated\n        // We need to try refreshing access token and retry this.\n        // If access token refresh fails, then raise errors.\n        if (url !== 'account/refresh') return this.refreshAuthentications().then(_ => {\n          return _classPrivateFieldLooseBase(this, _apiRequest)[_apiRequest](method, url, accessTokenRequired, data);\n        });else throw new FrostError('인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.', '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\n        // this \"possibly\" returns response.json().\n        // See RETURNABLE_ERROR for more details.\n        return response.json();\n      } else if (response.status === 403) {\n        // Requested action was forbidden\n        throw new FrostError('해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 405) {\n        // Method not permitted\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else if (response.status === 415) {\n        // requested response content-type not supported\n        throw new FrostError('잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      } else {\n        // unknown client-fault error\n        throw new FrostError('알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.', `${url} | ${method} | response.status === ${response.status}`, response.status);\n      }\n    } else {\n      // HTTP status code is more than 500(server error)\n      throw new FrostError('서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `statusCode가 ${response.status}입니다.`, response.status);\n    } // This is just for type-checking, response.status won't be less than 200, right?\n    // ...right? please... no......\n\n\n    return response.json();\n  }).then(response => new APIResult(response)).catch(reason => {\n    // catch all exceptions and change it to FrostError\n    if (typeof reason === 'object' && reason.constructor.name === 'FrostError') {\n      throw reason;\n    } else {\n      throw new FrostError('알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.', `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\n    }\n  });\n}\n\nObject.defineProperty(FrostAPI, _API_USED_METHOD, {\n  writable: true,\n  value: [HTTP_METHOD.GET, HTTP_METHOD.POST, HTTP_METHOD.PUT, HTTP_METHOD.PATCH, HTTP_METHOD.DELETE]\n});\nFrostAPI.RETURNABLE_ERROR = [// Actually, on 404, we need to filter http.not_found out,\n// and any other responses must be returned... but we can get subcode after response.json(),\n// And response.json() returns Promise<Any>, so we cannot get subCode directly... shit...\n404, // http || resource not found\n409, // already used / information mismatch, conflict\n410, // resource gone\n412, // resource prediction failed\n422 // request.body.bad_semantics - email address validation failure, etc.\n];\nexport default FrostAPI;","map":{"version":3,"sources":["C:/Users/MUsoftware/Desktop/project/MUsoftware/mudev.cc/src/network/api.ts"],"names":["FrostError","APIResult","HTTP_METHOD","GET","POST","PUT","PATCH","DELETE","role2Object","roleStr","result","split","forEach","part","item","length","decodeURIComponent","buf2hex","buffer","Uint8Array","map","x","toString","padStart","join","generateRandomSecureToken","bytes","randArray","Uint32Array","window","crypto","getRandomValues","frostApiInstance","FrostAPI","constructor","mode","cache","credentials","redirect","referrerPolicy","headers","isSignedIn","checkNetwork","refreshAuthentications","signUp","id","email","password","nickname","pw","nick","then","apiResult","success","data","user","access_token","token","code","catch","reason","signIn","idOrEmail","errorMsg","left_chance","accountLockReason","accountDeactivateReason","subCode","signout","userID","roles","JSON","parse","atob","role","rolePart","push","e","get","url","accessTokenRequired","post","put","patch","delete","method","indexOf","reqFetchOption","stringify","body","includes","fetch","response","status","json","_","RETURNABLE_ERROR","name"],"mappings":"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","sourcesContent":["// (c) MUsoftware 2022\r\n'use strict';\r\n\r\nimport { FrostError } from '../common/error';\r\nimport { APIResult } from './api_response';\r\n\r\nconst HTTP_METHOD = {\r\n  // We will support only these methods for now\r\n  GET: 'GET',\r\n  POST: 'POST',\r\n  PUT: 'PUT',\r\n  PATCH: 'PATCH',\r\n  DELETE: 'DELETE',\r\n};\r\n\r\nfunction role2Object(roleStr: string) {\r\n  let result: { [roleName: string]: string | boolean } = {};\r\n\r\n  roleStr.split(\"&\").forEach(function (part) {\r\n    let item = part.split(\"=\");\r\n    if (item.length == 2) {\r\n      result[item[0]] = decodeURIComponent(item[1]);\r\n      if (result[item[0]] === 'true' || result[item[0]] === 'false')\r\n        result[item[0]] = (result[item[0]] === 'true') ? true : false;\r\n    }\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\n// From https://stackoverflow.com/a/40031979\r\nfunction buf2hex(buffer: ArrayBufferLike) {\r\n  return [...new Uint8Array(buffer)]\r\n    .map(x => x.toString(16).padStart(2, '0'))\r\n    .join('');\r\n}\r\n\r\n// Generate random safe string\r\nfunction generateRandomSecureToken(bytes: number) {\r\n  let randArray = new Uint32Array(bytes);\r\n  window.crypto.getRandomValues(randArray);\r\n  return buf2hex(randArray);\r\n}\r\n\r\nlet frostApiInstance: FrostAPI;\r\nclass FrostAPI {\r\n  // We only uses these http methods now.\r\n  static readonly #API_USED_METHOD = [\r\n    HTTP_METHOD.GET,\r\n    HTTP_METHOD.POST,\r\n    HTTP_METHOD.PUT,\r\n    HTTP_METHOD.PATCH,\r\n    HTTP_METHOD.DELETE,\r\n  ]\r\n  // Refresh Token will be saved on cookie storage,\r\n  // And all of these attributes must be private.\r\n  readonly #BASE_URL = 'https://hyperion.mudev.cc/api/dev/';\r\n  // We \"possibly\" returns response.json() on these HTTP Response status code.\r\n  // Although these HTTP Response status code means error,\r\n  // each routes have to handle these codes differently.\r\n  static readonly RETURNABLE_ERROR = [\r\n    // Actually, on 404, we need to filter http.not_found out,\r\n    // and any other responses must be returned... but we can get subcode after response.json(),\r\n    // And response.json() returns Promise<Any>, so we cannot get subCode directly... shit...\r\n    404, // http || resource not found\r\n    409, // already used / information mismatch, conflict\r\n    410, // resource gone\r\n    412, // resource prediction failed\r\n    422, // request.body.bad_semantics - email address validation failure, etc.\r\n  ];\r\n  // Default fetch options,\r\n  // we'll copy and modify this default option object on every request.\r\n  readonly #DEFAULT_FETCH_OPTION = {\r\n    mode: 'cors',\r\n    cache: 'no-cache',\r\n    credentials: 'same-origin',\r\n    redirect: 'follow',\r\n    referrerPolicy: 'strict-origin-when-cross-origin',\r\n    headers: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  };\r\n\r\n  // Account related properties\r\n  #csrfToken: string = '';\r\n  #accessToken: string = '';\r\n  #refreshResult?: APIResult['data'] | null = null;\r\n\r\n  constructor() {\r\n    if (frostApiInstance) return frostApiInstance;\r\n\r\n    this.#csrfToken = generateRandomSecureToken(32);\r\n    frostApiInstance = this;\r\n  }\r\n\r\n  #apiRequest(method = HTTP_METHOD.GET, url = '', accessTokenRequired = false, data = {}): Promise<APIResult> {\r\n    // check if requested method is allowed\r\n    if (FrostAPI.#API_USED_METHOD.indexOf(method) == -1) { throw 'NOT_ALLOWED_METHOD'; }\r\n\r\n    // deep copy fetch option object\r\n    let reqFetchOption = JSON.parse(JSON.stringify(this.#DEFAULT_FETCH_OPTION));\r\n    reqFetchOption.method = method;\r\n\r\n    // only add body on POST/PATCH/PUT methods\r\n    if ([HTTP_METHOD.POST, HTTP_METHOD.PATCH, HTTP_METHOD.PUT].indexOf(method) > -1)\r\n      reqFetchOption.body = JSON.stringify(data);\r\n\r\n    // always send X-Csrf-Token. This won't be a security hole.\r\n    reqFetchOption.headers['X-Csrf-Token'] = this.#csrfToken;\r\n    // add access token on header if accessTokenRequired is true\r\n    if (accessTokenRequired) {\r\n      reqFetchOption.headers['Authorization'] = 'Bearer ' + this.#accessToken;\r\n    }\r\n\r\n    if (url.includes('account') || url.includes('admin')) {\r\n      reqFetchOption.credentials = 'include';\r\n    }\r\n\r\n    return fetch(this.#BASE_URL + url, reqFetchOption).then((response) => {\r\n      if (!response) {\r\n        // How is this possible???\r\n        throw new FrostError(\r\n          '서버가 응답이 없어요,\\n잠시 후에 다시 시도해주세요.',\r\n          'fetchResult 객체가 undefined 또는 null입니다.', -1);\r\n      } else if (200 <= response.status && response.status <= 399) {  // this returns response.json()\r\n        // SUCCESS\r\n        return response.json();\r\n      } else if (400 <= response.status && response.status <= 499) {\r\n        if (response.status === 401) {  // this \"possibly\" returns response.json()\r\n          // token not given / token expired / token invalid\r\n          // wrong password / account locked / account deactivated\r\n          // We need to try refreshing access token and retry this.\r\n          // If access token refresh fails, then raise errors.\r\n          if (url !== 'account/refresh')\r\n            return this.refreshAuthentications().then((_) => {\r\n              return this.#apiRequest(method, url, accessTokenRequired, data);\r\n            });\r\n          else\r\n            throw new FrostError(\r\n              '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n              '인증 실패 & url !== account/refresh\\n' + `${url} | ${method} | response.status === ${response.status}`,\r\n              response.status);\r\n        } else if (FrostAPI.RETURNABLE_ERROR.includes(response.status)) {\r\n          // this \"possibly\" returns response.json().\r\n          // See RETURNABLE_ERROR for more details.\r\n          return response.json();\r\n        } else if (response.status === 403) {\r\n          // Requested action was forbidden\r\n          throw new FrostError(\r\n            '해당 동작에 대한 권한이 없습니다.\\n만약 권한을 가지고 계셔야 한다면 관리자에게 연락 부탁드립니다.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 405) {\r\n          // Method not permitted\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else if (response.status === 415) {\r\n          // requested response content-type not supported\r\n          throw new FrostError(\r\n            '잘못된 요청입니다.\\n사이트 관리자에게 어떻게 이 메시지를 보게 됐는지 알려주시면 감사하겠습니다ㅠㅜ',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        } else {\r\n          // unknown client-fault error\r\n          throw new FrostError(\r\n            '알 수 없는 문제가 발생하였습니다,\\n10분 후 다시 시도해주세요.',\r\n            `${url} | ${method} | response.status === ${response.status}`, response.status);\r\n        }\r\n      } else {  // HTTP status code is more than 500(server error)\r\n        throw new FrostError(\r\n          '서버가 잠시 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `statusCode가 ${response.status}입니다.`, response.status);\r\n      }\r\n\r\n      // This is just for type-checking, response.status won't be less than 200, right?\r\n      // ...right? please... no......\r\n      return response.json();\r\n    }).then((response) => new APIResult(response)).catch((reason) => {\r\n      // catch all exceptions and change it to FrostError\r\n      if (typeof (reason) === 'object' && reason.constructor.name === 'FrostError') {\r\n        throw reason;\r\n      } else {\r\n        throw new FrostError(\r\n          '알 수 없는 문제가 생겼어요,\\n10분 후에 다시 시도해주세요.',\r\n          `on FrostAPI.#apiRequest -> reason = ${reason}`, -1);\r\n      }\r\n    });\r\n  }\r\n\r\n  isSignedIn(checkNetwork: boolean = false) {\r\n    if (checkNetwork)\r\n      this.refreshAuthentications();\r\n\r\n    return (this.#accessToken) ? true : false;\r\n  }\r\n\r\n  signUp(id: string, email: string, password: string, nickname: string) {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signup', false,\r\n      { id: id, pw: password, nick: nickname, email: email }).then((apiResult) => {\r\n        if (apiResult.success) {\r\n          this.#accessToken = apiResult.data.user.access_token.token;\r\n          this.#refreshResult = apiResult.data;\r\n          return this;\r\n        }\r\n        throw new FrostError(\r\n          '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n          `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\r\n      }).catch((reason) => {\r\n        // as reason might be a 'FrostError',\r\n        // we can just reset auth data and throw it directly.\r\n        this.#accessToken = '';\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#refreshResult = null;\r\n        throw reason;\r\n      });\r\n  }\r\n\r\n  signIn(idOrEmail: string, password: string) {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signin', false,\r\n      { id: idOrEmail, pw: password }).then((apiResult) => {\r\n        if (apiResult.success) {\r\n          this.#accessToken = apiResult.data.user.access_token.token;\r\n          this.#refreshResult = apiResult.data;\r\n          return this;\r\n        }\r\n\r\n        // We need to generate error message from the subcode.\r\n        let errorMsg: string = '';\r\n        switch (apiResult) {\r\n          case 'user.not_found':\r\n            errorMsg = '계정을 찾지 못했어요,\\n아이디나 이메일을 다시 확인해주세요.';\r\n            break;\r\n          case 'user.wrong_password':\r\n            errorMsg = '비밀번호가 맞지 않습니다,\\n비밀번호를 다시 입력해주세요.\\n';\r\n            errorMsg += `(만약 ${apiResult.data.left_chance}번을 더 틀리시면 계정이 잠겨요.)`;\r\n            break;\r\n          case 'user.locked':\r\n            errorMsg = '계정이 잠겼습니다,\\n관리자에게 연락해주세요.\\n';\r\n            let accountLockReason: string = apiResult.data.reason;\r\n            errorMsg += `(잠긴 사유: ${accountLockReason})`;\r\n            break;\r\n          case 'user.deactivated':\r\n            errorMsg = '계정이 폐쇄되었습니다.,\\n관리자에게 연락해주세요.';\r\n            let accountDeactivateReason: string = apiResult.data.reason;\r\n            errorMsg += `(폐쇄된 사유: ${accountDeactivateReason})`;\r\n            break;\r\n        }\r\n\r\n\r\n        throw new FrostError(\r\n          errorMsg,\r\n          `account/refresh=>response.success = false입니다.\\ncode = ${apiResult.code}\\nsubCode=${apiResult.subCode}`,\r\n          apiResult.code);\r\n      }).catch((reason) => {\r\n        // as reason might be a 'FrostError',\r\n        // we can just reset auth data and throw it directly.\r\n        this.#accessToken = '';\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#refreshResult = null;\r\n        throw reason;\r\n      });\r\n  }\r\n\r\n  signout() {\r\n    return this.#apiRequest(HTTP_METHOD.POST, 'account/signout', false, { signout: true }).then(\r\n      (apiResult) => {\r\n        // Actually, this action won't fail, except when the server is dead.\r\n        // Just reset the csrf token and access token.\r\n        this.#csrfToken = generateRandomSecureToken(32);\r\n        this.#accessToken = '';\r\n        this.#refreshResult = null;\r\n        return this;\r\n      });\r\n  }\r\n\r\n  refreshAuthentications() {\r\n    return this.#apiRequest(\r\n      HTTP_METHOD.POST,\r\n      'account/refresh',\r\n      false\r\n    ).then((apiResult) => {\r\n      if (apiResult.success) {\r\n        this.#accessToken = apiResult.data.user.access_token.token;\r\n        this.#refreshResult = apiResult.data;\r\n        return this;\r\n      }\r\n      throw new FrostError(\r\n        '인증 정보 갱신에 실패했어요,\\n다시 로그인해주세요.',\r\n        `account/refresh=>response.success = false입니다. code = ${apiResult.code}`, 400);\r\n    }).catch((reason) => {\r\n      // as reason might be a 'FrostError',\r\n      // we can just reset auth data and throw it directly.\r\n      this.#accessToken = '';\r\n      this.#csrfToken = generateRandomSecureToken(32);\r\n      this.#refreshResult = null;\r\n      throw reason;\r\n    });\r\n  }\r\n\r\n  get userID() {\r\n    if (!this.#refreshResult?.user)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    return this.#refreshResult.user.id;\r\n  }\r\n\r\n  get roles() {\r\n    if (!this.#accessToken)\r\n      // This can cause FrostError, and this is intended.\r\n      this.refreshAuthentications();\r\n\r\n    let result: Array<{ [roleName: string]: string | boolean; }> = [];\r\n    try {\r\n      let token = JSON.parse(atob(this.#accessToken.split('.')[1]));\r\n      JSON.parse(token.role).forEach((rolePart: string) => {\r\n        if (rolePart === 'admin') return;\r\n        result.push(role2Object(rolePart));\r\n      });\r\n    } catch (e) { }\r\n\r\n    return result;\r\n  }\r\n\r\n  get(url: string, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.GET, url, accessTokenRequired); }\r\n  post(url: string, data: object = {}, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.POST, url, accessTokenRequired, data); }\r\n  put(url: string, data: object = {}, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.PUT, url, accessTokenRequired, data); }\r\n  patch(url: string, data: object = {}, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.PATCH, url, accessTokenRequired, data); }\r\n  delete(url: string, accessTokenRequired: boolean = false) { return this.#apiRequest(HTTP_METHOD.DELETE, url, accessTokenRequired); }\r\n}\r\n\r\nexport default FrostAPI;\r\n"]},"metadata":{},"sourceType":"module"}